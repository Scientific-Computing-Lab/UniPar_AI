{"kernel_name": "affine", "parallel_api": "cuda", "code": {"main.cu": "\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <chrono>\n#include <cuda.h>\n#include \"reference.h\"\n#include \"kernel.h\"\n\nint main(int argc, char** argv)\n{\n  if (argc != 4)\n  {\n    printf(\"Usage: %s <input image> <output image> <iterations>\\n\", argv[0]) ;\n    return -1 ;\n  }\n\n  unsigned short input_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short output_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short output_image_ref[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n\n  \n\n  std::cout << \"Reading input image...\\n\";\n\n  \n\n  const char *inputImageFilename = argv[1];\n  FILE *input_file = fopen(inputImageFilename, \"rb\");\n  if (!input_file)\n  {\n    printf(\"Error: Unable to open input image file %s!\\n\", inputImageFilename);\n    return 1;\n  }\n\n  printf(\"\\n\");\n  printf(\"   Reading RAW Image\\n\");\n  size_t items_read = fread(input_image, sizeof(input_image), 1, input_file);\n  printf(\"   Bytes read = %d\\n\\n\", (int)(items_read * sizeof(input_image)));\n  fclose(input_file);\n\n  const int iterations = atoi(argv[3]);\n\n  size_t image_size_bytes = sizeof(unsigned short) * X_SIZE * Y_SIZE;\n\n  unsigned short *d_input_image;\n  cudaMalloc((void**)&d_input_image, image_size_bytes);\n  cudaMemcpy(d_input_image, input_image, image_size_bytes, cudaMemcpyHostToDevice);\n\n  unsigned short *d_output_image;\n  cudaMalloc((void**)&d_output_image, image_size_bytes);\n\n  dim3 grids (X_SIZE/16,Y_SIZE/16);\n  dim3 threads (16,16);\n\n  cudaDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < iterations; i++) {\n    affine<<<grids, threads>>>(d_input_image, d_output_image);\n  }\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  std::cout << \"   Average kernel execution time \" << (time * 1e-9f) / iterations << \" (s)\\n\";\n\n  cudaMemcpy(output_image, d_output_image, image_size_bytes, cudaMemcpyDeviceToHost);\n  cudaFree(d_input_image);\n  cudaFree(d_output_image);\n\n  \n\n  affine_reference(input_image, output_image_ref);\n  int max_error = 0;\n  for (int y = 0; y < Y_SIZE; y++) {\n    for (int x = 0; x < X_SIZE; x++) {\n      max_error = std::max(max_error, std::abs(output_image[y*X_SIZE+x] - output_image_ref[y*X_SIZE+x]));\n    }\n  }\n  printf(\"   Max output error is %d\\n\\n\", max_error);\n\n  printf(\"   Writing RAW Image\\n\");\n  const char *outputImageFilename = argv[2];\n  FILE *output_file = fopen(outputImageFilename, \"wb\");\n  if (!output_file)\n  {\n    printf(\"Error: Unable to write  image file %s!\\n\", outputImageFilename);\n    return 1;\n  }\n  size_t items_written = fwrite(output_image, sizeof(output_image), 1, output_file);\n  printf(\"   Bytes written = %d\\n\\n\", (int)(items_written * sizeof(output_image)));\n  fclose(output_file);\n\n  return 0 ;\n}\n"}}
{"kernel_name": "affine", "parallel_api": "omp", "code": {"main.cpp": "\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cstring>\n#include <cmath>\n#include <chrono>\n#include <iostream>\n#include \"reference.h\"\n\nint main(int argc, char** argv)\n{\n  if (argc != 4)\n  {\n    printf(\"Usage: %s <input image> <output image> <iterations>\\n\", argv[0]) ;\n    return -1 ;\n  }\n\n  unsigned short    input_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short    output_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short    output_image_ref[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n\n  \n\n  std::cout << \"Reading input image...\\n\";\n\n  \n\n  const char *inputImageFilename = argv[1];\n  FILE *input_file = fopen(inputImageFilename, \"rb\");\n  if (!input_file)\n  {\n    printf(\"Error: Unable to open input image file %s!\\n\", inputImageFilename);\n    return 1;\n  }\n\n  printf(\"\\n\");\n  printf(\"   Reading RAW Image\\n\");\n  size_t items_read = fread(input_image, sizeof(input_image), 1, input_file);\n  printf(\"   Bytes read = %d\\n\\n\", (int)(items_read * sizeof(input_image)));\n  fclose(input_file);\n\n  const int iterations = atoi(argv[3]);\n\n  #pragma omp target data map(to: input_image[0:X_SIZE*Y_SIZE]) \\\n                          map(from:output_image[0:X_SIZE*Y_SIZE])\n  {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < iterations; i++) {\n      #pragma omp target teams distribute parallel for collapse(2) thread_limit(256)\n      for (int y = 0; y < Y_SIZE; y++)\n        for (int x = 0; x < X_SIZE; x++) {\n\n          const float lx_rot   = 30.0f;\n          const float ly_rot   = 0.0f; \n          const float lx_expan = 0.5f;\n          const float ly_expan = 0.5f; \n          int   lx_move  = 0;\n          int   ly_move  = 0;\n          float affine[2][2];   \n\n          float i_affine[2][2];\n          float beta[2];\n          float i_beta[2];\n          float det;\n          float x_new, y_new;\n          float x_frac, y_frac;\n          float gray_new;\n          int   m, n;\n          unsigned short output_buffer;\n\n          \n\n          affine[0][0] = lx_expan * cosf(lx_rot*PI/180.0f);\n          affine[0][1] = ly_expan * sinf(ly_rot*PI/180.0f);\n          affine[1][0] = lx_expan * sinf(lx_rot*PI/180.0f);\n          affine[1][1] = ly_expan * cosf(ly_rot*PI/180.0f);\n          beta[0]      = lx_move;\n          beta[1]      = ly_move;\n\n          \n\n          det = (affine[0][0] * affine[1][1]) - (affine[0][1] * affine[1][0]);\n          if (det == 0.0f)\n          {\n            i_affine[0][0] = 1.0f;\n            i_affine[0][1] = 0.0f;\n            i_affine[1][0] = 0.0f;\n            i_affine[1][1] = 1.0f;\n            i_beta[0]      = -beta[0];\n            i_beta[1]      = -beta[1];\n          } \n          else \n          {\n            i_affine[0][0] =  affine[1][1]/det;\n            i_affine[0][1] = -affine[0][1]/det;\n            i_affine[1][0] = -affine[1][0]/det;\n            i_affine[1][1] =  affine[0][0]/det;\n            i_beta[0]      = -i_affine[0][0]*beta[0]-i_affine[0][1]*beta[1];\n            i_beta[1]      = -i_affine[1][0]*beta[0]-i_affine[1][1]*beta[1];\n          }\n\n          \n\n\n          x_new  = i_beta[0] + i_affine[0][0]*(x-X_SIZE/2.0f) + i_affine[0][1]*(y-Y_SIZE/2.0f) + X_SIZE/2.0f;\n          y_new  = i_beta[1] + i_affine[1][0]*(x-X_SIZE/2.0f) + i_affine[1][1]*(y-Y_SIZE/2.0f) + Y_SIZE/2.0f;\n\n          m      = (int)floorf(x_new);\n          n      = (int)floorf(y_new);\n\n          x_frac = x_new - m;\n          y_frac = y_new - n;\n\n          if ((m >= 0) && (m + 1 < X_SIZE) && (n >= 0) && (n+1 < Y_SIZE))\n          {\n            gray_new = (1.0f - y_frac) * ((1.0f - x_frac) * (input_image[(n * X_SIZE) + m])  + \n                x_frac * (input_image[(n * X_SIZE) + m + 1])) + \n              y_frac  * ((1.0f - x_frac) * (input_image[((n + 1) * X_SIZE) + m]) + \n                  x_frac * (input_image[((n + 1) * X_SIZE) + m + 1]));\n\n            output_buffer = (unsigned short)gray_new;\n          } \n          else if (((m + 1 == X_SIZE) && (n >= 0) && (n < Y_SIZE)) || ((n + 1 == Y_SIZE) && (m >= 0) && (m < X_SIZE))) \n          {\n            output_buffer = input_image[(n * X_SIZE) + m];\n          } \n          else \n          {\n            output_buffer = WHITE;\n          }\n\n          output_image[(y * X_SIZE)+x] = output_buffer;\n        }\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    std::cout << \"   Average kernel execution time \" << (time * 1e-9f) / iterations << \" (s)\\n\";\n  }\n\n  \n\n  affine_reference(input_image, output_image_ref);\n  int max_error = 0;\n  for (int y = 0; y < Y_SIZE; y++) {\n    for (int x = 0; x < X_SIZE; x++) {\n      max_error = std::max(max_error, std::abs(output_image[y*X_SIZE+x] - output_image_ref[y*X_SIZE+x]));\n    }\n  }\n  printf(\"   Max output error is %d\\n\\n\", max_error);\n\n  printf(\"   Writing RAW Image\\n\");\n  const char *outputImageFilename = argv[2];\n  FILE *output_file = fopen(outputImageFilename, \"wb\");\n  if (!output_file)\n  {\n    printf(\"Error: Unable to write  image file %s!\\n\", outputImageFilename);\n    return 1;\n  }\n  size_t items_written = fwrite(output_image, sizeof(output_image), 1, output_file);\n  printf(\"   Bytes written = %d\\n\\n\", (int)(items_written * sizeof(output_image)));\n  fclose(output_file);\n\n  return 0 ;\n}\n"}}
{"kernel_name": "affine", "parallel_api": "serial", "code": {"main.cpp": "\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <cstring>\n#include <cmath>\n#include <chrono>\n#include <iostream>\n#include \"reference.h\"\n\nint main(int argc, char** argv)\n{\n  if (argc != 4)\n  {\n    printf(\"Usage: %s <input image> <output image> <iterations>\\n\", argv[0]) ;\n    return -1 ;\n  }\n\n  unsigned short    input_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short    output_image[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n  unsigned short    output_image_ref[Y_SIZE*X_SIZE] __attribute__((aligned(1024)));\n\n  \n\n  std::cout << \"Reading input image...\\n\";\n\n  \n\n  const char *inputImageFilename = argv[1];\n  FILE *input_file = fopen(inputImageFilename, \"rb\");\n  if (!input_file)\n  {\n    printf(\"Error: Unable to open input image file %s!\\n\", inputImageFilename);\n    return 1;\n  }\n\n  printf(\"\\n\");\n  printf(\"   Reading RAW Image\\n\");\n  size_t items_read = fread(input_image, sizeof(input_image), 1, input_file);\n  printf(\"   Bytes read = %d\\n\\n\", (int)(items_read * sizeof(input_image)));\n  fclose(input_file);\n\n  const int iterations = atoi(argv[3]);\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < iterations; i++) {\n            for (int y = 0; y < Y_SIZE; y++)\n        for (int x = 0; x < X_SIZE; x++) {\n\n          const float lx_rot   = 30.0f;\n          const float ly_rot   = 0.0f; \n          const float lx_expan = 0.5f;\n          const float ly_expan = 0.5f; \n          int   lx_move  = 0;\n          int   ly_move  = 0;\n          float affine[2][2];   \n\n          float i_affine[2][2];\n          float beta[2];\n          float i_beta[2];\n          float det;\n          float x_new, y_new;\n          float x_frac, y_frac;\n          float gray_new;\n          int   m, n;\n          unsigned short output_buffer;\n\n          \n\n          affine[0][0] = lx_expan * cosf(lx_rot*PI/180.0f);\n          affine[0][1] = ly_expan * sinf(ly_rot*PI/180.0f);\n          affine[1][0] = lx_expan * sinf(lx_rot*PI/180.0f);\n          affine[1][1] = ly_expan * cosf(ly_rot*PI/180.0f);\n          beta[0]      = lx_move;\n          beta[1]      = ly_move;\n\n          \n\n          det = (affine[0][0] * affine[1][1]) - (affine[0][1] * affine[1][0]);\n          if (det == 0.0f)\n          {\n            i_affine[0][0] = 1.0f;\n            i_affine[0][1] = 0.0f;\n            i_affine[1][0] = 0.0f;\n            i_affine[1][1] = 1.0f;\n            i_beta[0]      = -beta[0];\n            i_beta[1]      = -beta[1];\n          } \n          else \n          {\n            i_affine[0][0] =  affine[1][1]/det;\n            i_affine[0][1] = -affine[0][1]/det;\n            i_affine[1][0] = -affine[1][0]/det;\n            i_affine[1][1] =  affine[0][0]/det;\n            i_beta[0]      = -i_affine[0][0]*beta[0]-i_affine[0][1]*beta[1];\n            i_beta[1]      = -i_affine[1][0]*beta[0]-i_affine[1][1]*beta[1];\n          }\n\n          \n\n\n          x_new  = i_beta[0] + i_affine[0][0]*(x-X_SIZE/2.0f) + i_affine[0][1]*(y-Y_SIZE/2.0f) + X_SIZE/2.0f;\n          y_new  = i_beta[1] + i_affine[1][0]*(x-X_SIZE/2.0f) + i_affine[1][1]*(y-Y_SIZE/2.0f) + Y_SIZE/2.0f;\n\n          m      = (int)floorf(x_new);\n          n      = (int)floorf(y_new);\n\n          x_frac = x_new - m;\n          y_frac = y_new - n;\n\n          if ((m >= 0) && (m + 1 < X_SIZE) && (n >= 0) && (n+1 < Y_SIZE))\n          {\n            gray_new = (1.0f - y_frac) * ((1.0f - x_frac) * (input_image[(n * X_SIZE) + m])  + \n                x_frac * (input_image[(n * X_SIZE) + m + 1])) + \n              y_frac  * ((1.0f - x_frac) * (input_image[((n + 1) * X_SIZE) + m]) + \n                  x_frac * (input_image[((n + 1) * X_SIZE) + m + 1]));\n\n            output_buffer = (unsigned short)gray_new;\n          } \n          else if (((m + 1 == X_SIZE) && (n >= 0) && (n < Y_SIZE)) || ((n + 1 == Y_SIZE) && (m >= 0) && (m < X_SIZE))) \n          {\n            output_buffer = input_image[(n * X_SIZE) + m];\n          } \n          else \n          {\n            output_buffer = WHITE;\n          }\n\n          output_image[(y * X_SIZE)+x] = output_buffer;\n        }\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    std::cout << \"   Average kernel execution time \" << (time * 1e-9f) / iterations << \" (s)\\n\";\n  }\n\n  \n\n  affine_reference(input_image, output_image_ref);\n  int max_error = 0;\n  for (int y = 0; y < Y_SIZE; y++) {\n    for (int x = 0; x < X_SIZE; x++) {\n      max_error = std::max(max_error, std::abs(output_image[y*X_SIZE+x] - output_image_ref[y*X_SIZE+x]));\n    }\n  }\n  printf(\"   Max output error is %d\\n\\n\", max_error);\n\n  printf(\"   Writing RAW Image\\n\");\n  const char *outputImageFilename = argv[2];\n  FILE *output_file = fopen(outputImageFilename, \"wb\");\n  if (!output_file)\n  {\n    printf(\"Error: Unable to write  image file %s!\\n\", outputImageFilename);\n    return 1;\n  }\n  size_t items_written = fwrite(output_image, sizeof(output_image), 1, output_file);\n  printf(\"   Bytes written = %d\\n\\n\", (int)(items_written * sizeof(output_image)));\n  fclose(output_file);\n\n  return 0 ;\n}"}}
