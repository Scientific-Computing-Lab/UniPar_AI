{"kernel_name": "ace", "parallel_api": "cuda", "code": {"main.cu": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include <cuda.h>\n\n\n\n#define DATAXSIZE 400\n#define DATAYSIZE 400\n#define DATAZSIZE 400\n\ntypedef double nRarray[DATAYSIZE][DATAXSIZE];\n\n\n\n#define SQ(x) ((x)*(x))\n\n#ifdef VERIFY\n#include <string.h>\n#include \"reference.h\"\n#endif\n\n__device__\ndouble dFphi(double phi, double u, double lambda)\n{\n  return (-phi*(1.0-phi*phi)+lambda*u*(1.0-phi*phi)*(1.0-phi*phi));\n}\n\n__device__\ndouble GradientX(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x+1][y][z] - phi[x-1][y][z]) / (2.0*dx);\n}\n\n__device__\ndouble GradientY(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y+1][z] - phi[x][y-1][z]) / (2.0*dy);\n}\n\n__device__\ndouble GradientZ(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y][z+1] - phi[x][y][z-1]) / (2.0*dz);\n}\n\n__device__\ndouble Divergence(double phix[][DATAYSIZE][DATAXSIZE], \n                  double phiy[][DATAYSIZE][DATAXSIZE],\n                  double phiz[][DATAYSIZE][DATAXSIZE], \n                  double dx, double dy, double dz, int x, int y, int z)\n{\n  return GradientX(phix,dx,dy,dz,x,y,z) + \n         GradientY(phiy,dx,dy,dz,x,y,z) +\n         GradientZ(phiz,dx,dy,dz,x,y,z);\n}\n\n__device__\ndouble Laplacian(double phi[][DATAYSIZE][DATAXSIZE],\n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  double phixx = (phi[x+1][y][z] + phi[x-1][y][z] - 2.0 * phi[x][y][z]) / SQ(dx);\n  double phiyy = (phi[x][y+1][z] + phi[x][y-1][z] - 2.0 * phi[x][y][z]) / SQ(dy);\n  double phizz = (phi[x][y][z+1] + phi[x][y][z-1] - 2.0 * phi[x][y][z]) / SQ(dz);\n  return phixx + phiyy + phizz;\n}\n\n__device__\ndouble An(double phix, double phiy, double phiz, double epsilon)\n{\n  if (phix != 0.0 || phiy != 0.0 || phiz != 0.0){\n    return ((1.0 - 3.0 * epsilon) * (1.0 + (((4.0 * epsilon) / (1.0-3.0*epsilon))*\n           ((SQ(phix)*SQ(phix)+SQ(phiy)*SQ(phiy)+SQ(phiz)*SQ(phiz)) /\n           ((SQ(phix)+SQ(phiy)+SQ(phiz))*(SQ(phix)+SQ(phiy)+SQ(phiz)))))));\n  }\n  else\n  {\n    return (1.0-((5.0/3.0)*epsilon));\n  }\n}\n\n__device__\ndouble Wn(double phix, double phiy, double phiz, double epsilon, double W0)\n{\n  return (W0*An(phix,phiy,phiz,epsilon));\n}\n\n__device__\ndouble taun(double phix, double phiy, double phiz, double epsilon, double tau0)\n{\n  return tau0 * SQ(An(phix,phiy,phiz,epsilon));\n}\n\n__device__\ndouble dFunc(double l, double m, double n)\n{\n  if (l != 0.0 || m != 0.0 || n != 0.0){\n    return (((l*l*l*(SQ(m)+SQ(n)))-(l*(SQ(m)*SQ(m)+SQ(n)*SQ(n)))) /\n            ((SQ(l)+SQ(m)+SQ(n))*(SQ(l)+SQ(m)+SQ(n))));\n  }\n  else\n  {\n    return 0.0;\n  }\n}\n\n__global__\nvoid calculateForce(double phi[][DATAYSIZE][DATAXSIZE], \n                    double Fx[][DATAYSIZE][DATAXSIZE],\n                    double Fy[][DATAYSIZE][DATAXSIZE],\n                    double Fz[][DATAYSIZE][DATAXSIZE],\n                    double dx, double dy, double dz,\n                    double epsilon, double W0, double tau0)\n{\n\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n      (iz < (DATAZSIZE-1)) && (ix > (0)) && \n      (iy > (0)) && (iz > (0))) {\n\n    double phix = GradientX(phi,dx,dy,dz,ix,iy,iz);\n    double phiy = GradientY(phi,dx,dy,dz,ix,iy,iz);\n    double phiz = GradientZ(phi,dx,dy,dz,ix,iy,iz);\n    double sqGphi = SQ(phix) + SQ(phiy) + SQ(phiz);\n    double c = 16.0 * W0 * epsilon;\n    double w = Wn(phix,phiy,phiz,epsilon,W0);\n    double w2 = SQ(w);\n    \n\n    Fx[ix][iy][iz] = w2 * phix + sqGphi * w * c * dFunc(phix,phiy,phiz);\n    Fy[ix][iy][iz] = w2 * phiy + sqGphi * w * c * dFunc(phiy,phiz,phix);\n    Fz[ix][iy][iz] = w2 * phiz + sqGphi * w * c * dFunc(phiz,phix,phiy);\n  }\n  else\n  {\n    Fx[ix][iy][iz] = 0.0;\n    Fy[ix][iy][iz] = 0.0;\n    Fz[ix][iy][iz] = 0.0;\n  }\n\n}\n\n\n\n__global__\nvoid allenCahn(double phinew[][DATAYSIZE][DATAXSIZE], \n               double phiold[][DATAYSIZE][DATAXSIZE],\n               double uold[][DATAYSIZE][DATAXSIZE],\n               double Fx[][DATAYSIZE][DATAXSIZE],\n               double Fy[][DATAYSIZE][DATAXSIZE],\n               double Fz[][DATAYSIZE][DATAXSIZE],\n               double epsilon, double W0, double tau0, double lambda,\n               double dt, double dx, double dy, double dz)\n{\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n      (iz < (DATAZSIZE-1)) && (ix > (0)) && \n      (iy > (0)) && (iz > (0))) {\n\n    double phix = GradientX(phiold,dx,dy,dz,ix,iy,iz);\n    double phiy = GradientY(phiold,dx,dy,dz,ix,iy,iz);\n    double phiz = GradientZ(phiold,dx,dy,dz,ix,iy,iz); \n\n    phinew[ix][iy][iz] = phiold[ix][iy][iz] + \n     (dt / taun(phix,phiy,phiz,epsilon,tau0)) * \n     (Divergence(Fx,Fy,Fz,dx,dy,dz,ix,iy,iz) - \n      dFphi(phiold[ix][iy][iz], uold[ix][iy][iz],lambda));\n  }\n}\n\n__global__\nvoid boundaryConditionsPhi(double phinew[][DATAYSIZE][DATAXSIZE])\n{\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if (ix == 0){\n    phinew[ix][iy][iz] = -1.0;\n  }\n  else if (ix == DATAXSIZE-1){\n    phinew[ix][iy][iz] = -1.0;\n  }\n  else if (iy == 0){\n    phinew[ix][iy][iz] = -1.0;\n  }\n  else if (iy == DATAYSIZE-1){\n    phinew[ix][iy][iz] = -1.0;\n  }\n  else if (iz == 0){\n    phinew[ix][iy][iz] = -1.0;\n  }\n  else if (iz == DATAZSIZE-1){\n    phinew[ix][iy][iz] = -1.0;\n  }\n}\n\n__global__\nvoid thermalEquation(double unew[][DATAYSIZE][DATAXSIZE],\n                     double uold[][DATAYSIZE][DATAXSIZE],\n                     double phinew[][DATAYSIZE][DATAXSIZE],\n                     double phiold[][DATAYSIZE][DATAXSIZE],\n                     double D, double dt, double dx, double dy, double dz)\n{\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n      (iz < (DATAZSIZE-1)) && (ix > (0)) && \n      (iy > (0)) && (iz > (0))){\n    unew[ix][iy][iz] = uold[ix][iy][iz] + \n      0.5*(phinew[ix][iy][iz]- phiold[ix][iy][iz]) +\n      dt * D * Laplacian(uold,dx,dy,dz,ix,iy,iz);\n  }\n}\n\n__global__\nvoid boundaryConditionsU(double unew[][DATAYSIZE][DATAXSIZE], double delta)\n{\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if (ix == 0){\n    unew[ix][iy][iz] =  -delta;\n  }\n  else if (ix == DATAXSIZE-1){\n    unew[ix][iy][iz] =  -delta;\n  }\n  else if (iy == 0){\n    unew[ix][iy][iz] =  -delta;\n  }\n  else if (iy == DATAYSIZE-1){\n    unew[ix][iy][iz] =  -delta;\n  }\n  else if (iz == 0){\n    unew[ix][iy][iz] =  -delta;\n  }\n  else if (iz == DATAZSIZE-1){\n    unew[ix][iy][iz] =  -delta;\n  }\n}\n\n__global__\nvoid swapGrid(double cnew[][DATAYSIZE][DATAXSIZE],\n              double cold[][DATAYSIZE][DATAXSIZE])\n{\n  unsigned iz = blockIdx.x*blockDim.x + threadIdx.x;\n  unsigned iy = blockIdx.y*blockDim.y + threadIdx.y;\n  unsigned ix = blockIdx.z*blockDim.z + threadIdx.z;\n\n  if ((ix < (DATAXSIZE)) && \n      (iy < (DATAYSIZE)) &&\n      (iz < (DATAZSIZE))) {\n    double tmp = cnew[ix][iy][iz];\n    cnew[ix][iy][iz] = cold[ix][iy][iz];\n    cold[ix][iy][iz] = tmp;\n  }\n}\n\nvoid initializationPhi(double phi[][DATAYSIZE][DATAXSIZE], double r0)\n{\n#ifdef _OPENMP\n  #pragma omp parallel for collapse(3)\n#endif\n  for (int idx = 0; idx < DATAXSIZE; idx++) {\n    for (int idy = 0; idy < DATAYSIZE; idy++) {\n      for (int idz = 0; idz < DATAZSIZE; idz++) {\n        double r = std::sqrt(SQ(idx-0.5*DATAXSIZE) + SQ(idy-0.5*DATAYSIZE) + SQ(idz-0.5*DATAZSIZE));\n        if (r < r0){\n          phi[idx][idy][idz] = 1.0;\n        }\n        else\n        {\n          phi[idx][idy][idz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid initializationU(double u[][DATAYSIZE][DATAXSIZE], double r0, double delta)\n{\n#ifdef _OPENMP\n  #pragma omp parallel for collapse(3)\n#endif\n  for (int idx = 0; idx < DATAXSIZE; idx++) {\n    for (int idy = 0; idy < DATAYSIZE; idy++) {\n      for (int idz = 0; idz < DATAZSIZE; idz++) {\n        double r = std::sqrt(SQ(idx-0.5*DATAXSIZE) + SQ(idy-0.5*DATAYSIZE) + SQ(idz-0.5*DATAZSIZE));\n        if (r < r0) {\n          u[idx][idy][idz] = 0.0;\n        }\n        else\n        {\n          u[idx][idy][idz] = -delta * (1.0 - std::exp(-(r-r0)));\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  const int num_steps = atoi(argv[1]);  \n\n  const double dx = 0.4;\n  const double dy = 0.4;\n  const double dz = 0.4;\n  const double dt = 0.01;\n  const double delta = 0.8;\n  const double r0 = 5.0;\n  const double epsilon = 0.07;\n  const double W0 = 1.0;\n  const double beta0 = 0.0;\n  const double D = 2.0;\n  const double d0 = 0.5;\n  const double a1 = 1.25 / std::sqrt(2.0);\n  const double a2 = 0.64;\n  const double lambda = (W0*a1)/(d0);\n  const double tau0 = ((W0*W0*W0*a1*a2)/(d0*D)) + ((W0*W0*beta0)/(d0));\n\n  \n\n  const int nx = DATAXSIZE;\n  const int ny = DATAYSIZE;\n  const int nz = DATAZSIZE;\n  const int vol = nx * ny * nz;\n  const size_t vol_in_bytes = sizeof(double) * vol;\n\n  \n\n  nRarray *phi_host;\n  nRarray *d_phiold;\n  nRarray *u_host;\n  nRarray *d_phinew;\n  nRarray *d_uold;\n  nRarray *d_unew;\n  nRarray *d_Fx;\n  nRarray *d_Fy;\n  nRarray *d_Fz;\n\n  phi_host = (nRarray *)malloc(vol_in_bytes);\n  u_host = (nRarray *)malloc(vol_in_bytes);\n\n  initializationPhi(phi_host,r0);\n  initializationU(u_host,r0,delta);\n\n#ifdef VERIFY\n  nRarray *phi_ref = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_ref = (nRarray *)malloc(vol_in_bytes);\n  memcpy(phi_ref, phi_host, vol_in_bytes);\n  memcpy(u_ref, u_host, vol_in_bytes);\n  reference(phi_ref, u_ref, vol, num_steps);\n#endif \n\n  auto offload_start = std::chrono::steady_clock::now();\n\n  \n\n  dim3 grid ((DATAZSIZE+7)/8, (DATAYSIZE+7)/8, (DATAXSIZE+3)/4);\n  dim3 block (8, 8, 4);\n\n  \n\n  cudaMalloc((void **) &d_phiold, vol_in_bytes);\n  cudaMalloc((void **) &d_phinew, vol_in_bytes);\n  cudaMalloc((void **) &d_uold, vol_in_bytes);\n  cudaMalloc((void **) &d_unew, vol_in_bytes);\n  cudaMalloc((void **) &d_Fx, vol_in_bytes);\n  cudaMalloc((void **) &d_Fy, vol_in_bytes);\n  cudaMalloc((void **) &d_Fz, vol_in_bytes);\n\n  cudaMemcpy(d_phiold, phi_host, vol_in_bytes, cudaMemcpyHostToDevice);\n  cudaMemcpy(d_uold, u_host, vol_in_bytes, cudaMemcpyHostToDevice);\n\n  int t = 0;\n\n  cudaDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  while (t <= num_steps) {\n\n    calculateForce<<<grid, block>>>(d_phiold,d_Fx,d_Fy,d_Fz,\n                                    dx,dy,dz,epsilon,W0,tau0);\n\n    allenCahn<<<grid, block>>>(d_phinew,d_phiold,d_uold,\n                               d_Fx,d_Fy,d_Fz,\n                               epsilon,W0,tau0,lambda,\n                               dt,dx,dy,dz);\n\n    boundaryConditionsPhi<<<grid, block>>>(d_phinew);\n\n    thermalEquation<<<grid, block>>>(d_unew,d_uold,d_phinew,d_phiold,\n                                     D,dt,dx,dy,dz);\n\n    boundaryConditionsU<<<grid, block>>>(d_unew,delta);\n\n    swapGrid<<<grid, block>>>(d_phinew, d_phiold);\n\n    swapGrid<<<grid, block>>>(d_unew, d_uold);\n\n    t++;\n  }\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Total kernel execution time: %.3f (ms)\\n\", time * 1e-6f);\n\n  cudaMemcpy(phi_host, d_phiold, vol_in_bytes, cudaMemcpyDeviceToHost);\n  cudaMemcpy(u_host, d_uold, vol_in_bytes, cudaMemcpyDeviceToHost);\n\n  cudaFree(d_phiold);\n  cudaFree(d_phinew);\n  cudaFree(d_uold);\n  cudaFree(d_unew);\n  cudaFree(d_Fx);\n  cudaFree(d_Fy);\n  cudaFree(d_Fz);\n\n  auto offload_end = std::chrono::steady_clock::now();\n  auto offload_time = std::chrono::duration_cast<std::chrono::nanoseconds>(offload_end - offload_start).count();\n  printf(\"Offload time: %.3f (ms)\\n\", offload_time * 1e-6f);\n\n#ifdef VERIFY\n  bool ok = true;\n  for (int idx = 0; idx < nx; idx++)\n    for (int idy = 0; idy < ny; idy++)\n      for (int idz = 0; idz < nz; idz++) {\n        if (fabs(phi_ref[idx][idy][idz] - phi_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"phi: %lf %lf\\n\", phi_ref[idx][idy][idz], phi_host[idx][idy][idz]);\n\t}\n        if (fabs(u_ref[idx][idy][idz] - u_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"u: %lf %lf\\n\", u_ref[idx][idy][idz], u_host[idx][idy][idz]);\n        }\n      }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n  free(phi_ref);\n  free(u_ref);\n#endif\n\n  free(phi_host);\n  free(u_host);\n  return 0;\n}\n"}}
{"kernel_name": "ace", "parallel_api": "omp", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <chrono>\n#include <omp.h>\n\n\n\n#define DATAXSIZE 400\n#define DATAYSIZE 400\n#define DATAZSIZE 400\n\n#define SQ(x) ((x)*(x))\n\ntypedef double nRarray[DATAYSIZE][DATAXSIZE];\n\n#ifdef VERIFY\n#include <string.h>\n#include \"reference.h\"\n#endif\n\n#pragma omp declare target\ndouble dFphi(double phi, double u, double lambda)\n{\n  return (-phi*(1.0-phi*phi)+lambda*u*(1.0-phi*phi)*(1.0-phi*phi));\n}\n\n\ndouble GradientX(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x+1][y][z] - phi[x-1][y][z]) / (2.0*dx);\n}\n\n\ndouble GradientY(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y+1][z] - phi[x][y-1][z]) / (2.0*dy);\n}\n\n\ndouble GradientZ(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y][z+1] - phi[x][y][z-1]) / (2.0*dz);\n}\n\n\ndouble Divergence(double phix[][DATAYSIZE][DATAXSIZE], \n                  double phiy[][DATAYSIZE][DATAXSIZE],\n                  double phiz[][DATAYSIZE][DATAXSIZE], \n                  double dx, double dy, double dz, int x, int y, int z)\n{\n  return GradientX(phix,dx,dy,dz,x,y,z) + \n         GradientY(phiy,dx,dy,dz,x,y,z) +\n         GradientZ(phiz,dx,dy,dz,x,y,z);\n}\n\n\ndouble Laplacian(double phi[][DATAYSIZE][DATAXSIZE],\n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  double phixx = (phi[x+1][y][z] + phi[x-1][y][z] - 2.0 * phi[x][y][z]) / SQ(dx);\n  double phiyy = (phi[x][y+1][z] + phi[x][y-1][z] - 2.0 * phi[x][y][z]) / SQ(dy);\n  double phizz = (phi[x][y][z+1] + phi[x][y][z-1] - 2.0 * phi[x][y][z]) / SQ(dz);\n  return phixx + phiyy + phizz;\n}\n\n\ndouble An(double phix, double phiy, double phiz, double epsilon)\n{\n  if (phix != 0.0 || phiy != 0.0 || phiz != 0.0){\n    return ((1.0 - 3.0 * epsilon) * (1.0 + (((4.0 * epsilon) / (1.0-3.0*epsilon))*\n           ((SQ(phix)*SQ(phix)+SQ(phiy)*SQ(phiy)+SQ(phiz)*SQ(phiz)) /\n           ((SQ(phix)+SQ(phiy)+SQ(phiz))*(SQ(phix)+SQ(phiy)+SQ(phiz)))))));\n  }\n  else\n  {\n    return (1.0-((5.0/3.0)*epsilon));\n  }\n}\n\n\ndouble Wn(double phix, double phiy, double phiz, double epsilon, double W0)\n{\n  return (W0*An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble taun(double phix, double phiy, double phiz, double epsilon, double tau0)\n{\n  return tau0 * SQ(An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble dFunc(double l, double m, double n)\n{\n  if (l != 0.0 || m != 0.0 || n != 0.0){\n    return (((l*l*l*(SQ(m)+SQ(n)))-(l*(SQ(m)*SQ(m)+SQ(n)*SQ(n)))) /\n            ((SQ(l)+SQ(m)+SQ(n))*(SQ(l)+SQ(m)+SQ(n))));\n  }\n  else\n  {\n    return 0.0;\n  }\n}\n#pragma omp end declare target\n\nvoid calculateForce(double phi[][DATAYSIZE][DATAXSIZE], \n                    double Fx[][DATAYSIZE][DATAXSIZE],\n                    double Fy[][DATAYSIZE][DATAXSIZE],\n                    double Fz[][DATAYSIZE][DATAXSIZE],\n                    double dx, double dy, double dz,\n                    double epsilon, double W0, double tau0)\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n            (iz < (DATAZSIZE-1)) && (ix > (0)) && \n            (iy > (0)) && (iz > (0))) {\n\n          double phix = GradientX(phi,dx,dy,dz,ix,iy,iz);\n          double phiy = GradientY(phi,dx,dy,dz,ix,iy,iz);\n          double phiz = GradientZ(phi,dx,dy,dz,ix,iy,iz);\n          double sqGphi = SQ(phix) + SQ(phiy) + SQ(phiz);\n          double c = 16.0 * W0 * epsilon;\n          double w = Wn(phix,phiy,phiz,epsilon,W0);\n          double w2 = SQ(w);\n          \n\n          Fx[ix][iy][iz] = w2 * phix + sqGphi * w * c * dFunc(phix,phiy,phiz);\n          Fy[ix][iy][iz] = w2 * phiy + sqGphi * w * c * dFunc(phiy,phiz,phix);\n          Fz[ix][iy][iz] = w2 * phiz + sqGphi * w * c * dFunc(phiz,phix,phiy);\n        }\n        else\n        {\n          Fx[ix][iy][iz] = 0.0;\n          Fy[ix][iy][iz] = 0.0;\n          Fz[ix][iy][iz] = 0.0;\n        }\n      }\n    }\n  }\n}\n\n\n\nvoid allenCahn(double phinew[][DATAYSIZE][DATAXSIZE], \n               double phiold[][DATAYSIZE][DATAXSIZE],\n               double uold[][DATAYSIZE][DATAXSIZE],\n               double Fx[][DATAYSIZE][DATAXSIZE],\n               double Fy[][DATAYSIZE][DATAXSIZE],\n               double Fz[][DATAYSIZE][DATAXSIZE],\n               double epsilon, double W0, double tau0, double lambda,\n               double dt, double dx, double dy, double dz)\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        double phix = GradientX(phiold,dx,dy,dz,ix,iy,iz);\n        double phiy = GradientY(phiold,dx,dy,dz,ix,iy,iz);\n        double phiz = GradientZ(phiold,dx,dy,dz,ix,iy,iz); \n\n        phinew[ix][iy][iz] = phiold[ix][iy][iz] + \n         (dt / taun(phix,phiy,phiz,epsilon,tau0)) * \n         (Divergence(Fx,Fy,Fz,dx,dy,dz,ix,iy,iz) - \n          dFphi(phiold[ix][iy][iz], uold[ix][iy][iz],lambda));\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsPhi(double phinew[][DATAYSIZE][DATAXSIZE])\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (ix == DATAXSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == DATAYSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == DATAZSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid thermalEquation(double unew[][DATAYSIZE][DATAXSIZE],\n                     double uold[][DATAYSIZE][DATAXSIZE],\n                     double phinew[][DATAYSIZE][DATAXSIZE],\n                     double phiold[][DATAYSIZE][DATAXSIZE],\n                     double D, double dt, double dx, double dy, double dz)\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        unew[ix][iy][iz] = uold[ix][iy][iz] + \n          0.5*(phinew[ix][iy][iz]-\n               phiold[ix][iy][iz]) +\n          dt * D * Laplacian(uold,dx,dy,dz,ix,iy,iz);\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsU(double unew[][DATAYSIZE][DATAXSIZE], double delta)\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (ix == DATAXSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == DATAYSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == DATAZSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n      }\n    }\n  }\n}\n\nvoid swapGrid(double cnew[][DATAYSIZE][DATAXSIZE],\n              double cold[][DATAYSIZE][DATAXSIZE])\n{\n  #pragma omp target teams distribute parallel for collapse(3) thread_limit(256)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double tmp = cnew[ix][iy][iz];\n        cnew[ix][iy][iz] = cold[ix][iy][iz];\n        cold[ix][iy][iz] = tmp;\n      }\n    }\n  }\n}\n\nvoid initializationPhi(double phi[][DATAYSIZE][DATAXSIZE], double r0)\n{\n  #pragma omp parallel for collapse(3)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0){\n          phi[ix][iy][iz] = 1.0;\n        }\n        else\n        {\n          phi[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid initializationU(double u[][DATAYSIZE][DATAXSIZE], double r0, double delta)\n{\n  #pragma omp parallel for collapse(3)\n  for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0) {\n          u[ix][iy][iz] = 0.0;\n        }\n        else\n        {\n          u[ix][iy][iz] = -delta * (1.0 - std::exp(-(r-r0)));\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  const int num_steps = atoi(argv[1]);  \n\n  const double dx = 0.4;\n  const double dy = 0.4;\n  const double dz = 0.4;\n  const double dt = 0.01;\n  const double delta = 0.8;\n  const double r0 = 5.0;\n  const double epsilon = 0.07;\n  const double W0 = 1.0;\n  const double beta0 = 0.0;\n  const double D = 2.0;\n  const double d0 = 0.5;\n  const double a1 = 1.25 / std::sqrt(2.0);\n  const double a2 = 0.64;\n  const double lambda = (W0*a1)/(d0);\n  const double tau0 = ((W0*W0*W0*a1*a2)/(d0*D)) + ((W0*W0*beta0)/(d0));\n\n  \n\n  const int nx = DATAXSIZE;\n  const int ny = DATAYSIZE;\n  const int nz = DATAZSIZE;\n  const int vol = nx * ny * nz;\n  const size_t vol_in_bytes = sizeof(double) * vol;\n\n  \n\n  nRarray *phi_host = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_host = (nRarray *)malloc(vol_in_bytes);\n  initializationPhi(phi_host,r0);\n  initializationU(u_host,r0,delta);\n\n#ifdef VERIFY\n  nRarray *phi_ref = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_ref = (nRarray *)malloc(vol_in_bytes);\n  memcpy(phi_ref, phi_host, vol_in_bytes);\n  memcpy(u_ref, u_host, vol_in_bytes);\n  reference(phi_ref, u_ref, vol, num_steps);\n#endif \n\n  auto offload_start = std::chrono::steady_clock::now();\n\n  \n\n  double *d_phiold = (double*)phi_host;\n  double *d_uold = (double*)u_host;\n  double *d_phinew = (double*) malloc (vol_in_bytes);\n  double *d_unew = (double*) malloc (vol_in_bytes);\n  double *d_Fx = (double*) malloc (vol_in_bytes);\n  double *d_Fy = (double*) malloc (vol_in_bytes);\n  double *d_Fz = (double*) malloc (vol_in_bytes);\n\n  #pragma omp target data map(tofrom: d_phiold[0:vol], \\\n                                      d_uold[0:vol]) \\\n                          map(alloc: d_phinew[0:vol], \\\n                                     d_unew[0:vol], \\\n                                     d_Fx[0:vol],\\\n                                     d_Fy[0:vol],\\\n                                     d_Fz[0:vol])\n  {\n    int t = 0;\n\n    auto start = std::chrono::steady_clock::now();\n  \n    while (t <= num_steps) {\n  \n      calculateForce((nRarray*)d_phiold, (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                     dx,dy,dz,epsilon,W0,tau0);\n  \n      allenCahn((nRarray*)d_phinew,(nRarray*)d_phiold,(nRarray*)d_uold,\n                (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                epsilon,W0,tau0,lambda, dt,dx,dy,dz);\n  \n      boundaryConditionsPhi((nRarray*)d_phinew);\n  \n      thermalEquation((nRarray*)d_unew,(nRarray*)d_uold,(nRarray*)d_phinew,(nRarray*)d_phiold,\n                      D,dt,dx,dy,dz);\n  \n      boundaryConditionsU((nRarray*)d_unew,delta);\n  \n      swapGrid((nRarray*)d_phinew, (nRarray*)d_phiold);\n  \n      swapGrid((nRarray*)d_unew, (nRarray*)d_uold);\n  \n      t++;\n    }\n  \n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %.3f (ms)\\n\", time * 1e-6f);\n  }\n\n  auto offload_end = std::chrono::steady_clock::now();\n  auto offload_time = std::chrono::duration_cast<std::chrono::nanoseconds>(offload_end - offload_start).count();\n  printf(\"Offload time: %.3f (ms)\\n\", offload_time * 1e-6f);\n\n#ifdef VERIFY\n  bool ok = true;\n  for (int idx = 0; idx < nx; idx++)\n    for (int idy = 0; idy < ny; idy++)\n      for (int idz = 0; idz < nz; idz++) {\n        if (fabs(phi_ref[idx][idy][idz] - phi_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"phi: %lf %lf\\n\", phi_ref[idx][idy][idz], phi_host[idx][idy][idz]);\n\t}\n        if (fabs(u_ref[idx][idy][idz] - u_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"u: %lf %lf\\n\", u_ref[idx][idy][idz], u_host[idx][idy][idz]);\n        }\n      }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n  free(phi_ref);\n  free(u_ref);\n#endif\n\n  free(phi_host);\n  free(u_host);\n  free(d_phinew);\n  free(d_unew);\n  free(d_Fx);\n  free(d_Fy);\n  free(d_Fz);\n  return 0;\n}\n"}}
{"kernel_name": "ace", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <chrono>\n\n\n\n#define DATAXSIZE 400\n#define DATAYSIZE 400\n#define DATAZSIZE 400\n\n#define SQ(x) ((x)*(x))\n\ntypedef double nRarray[DATAYSIZE][DATAXSIZE];\n\n#ifdef VERIFY\n#include <string.h>\n#include \"reference.h\"\n#endif\n\ndouble dFphi(double phi, double u, double lambda)\n{\n  return (-phi*(1.0-phi*phi)+lambda*u*(1.0-phi*phi)*(1.0-phi*phi));\n}\n\n\ndouble GradientX(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x+1][y][z] - phi[x-1][y][z]) / (2.0*dx);\n}\n\n\ndouble GradientY(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y+1][z] - phi[x][y-1][z]) / (2.0*dy);\n}\n\n\ndouble GradientZ(double phi[][DATAYSIZE][DATAXSIZE], \n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  return (phi[x][y][z+1] - phi[x][y][z-1]) / (2.0*dz);\n}\n\n\ndouble Divergence(double phix[][DATAYSIZE][DATAXSIZE], \n                  double phiy[][DATAYSIZE][DATAXSIZE],\n                  double phiz[][DATAYSIZE][DATAXSIZE], \n                  double dx, double dy, double dz, int x, int y, int z)\n{\n  return GradientX(phix,dx,dy,dz,x,y,z) + \n         GradientY(phiy,dx,dy,dz,x,y,z) +\n         GradientZ(phiz,dx,dy,dz,x,y,z);\n}\n\n\ndouble Laplacian(double phi[][DATAYSIZE][DATAXSIZE],\n                 double dx, double dy, double dz, int x, int y, int z)\n{\n  double phixx = (phi[x+1][y][z] + phi[x-1][y][z] - 2.0 * phi[x][y][z]) / SQ(dx);\n  double phiyy = (phi[x][y+1][z] + phi[x][y-1][z] - 2.0 * phi[x][y][z]) / SQ(dy);\n  double phizz = (phi[x][y][z+1] + phi[x][y][z-1] - 2.0 * phi[x][y][z]) / SQ(dz);\n  return phixx + phiyy + phizz;\n}\n\n\ndouble An(double phix, double phiy, double phiz, double epsilon)\n{\n  if (phix != 0.0 || phiy != 0.0 || phiz != 0.0){\n    return ((1.0 - 3.0 * epsilon) * (1.0 + (((4.0 * epsilon) / (1.0-3.0*epsilon))*\n           ((SQ(phix)*SQ(phix)+SQ(phiy)*SQ(phiy)+SQ(phiz)*SQ(phiz)) /\n           ((SQ(phix)+SQ(phiy)+SQ(phiz))*(SQ(phix)+SQ(phiy)+SQ(phiz)))))));\n  }\n  else\n  {\n    return (1.0-((5.0/3.0)*epsilon));\n  }\n}\n\n\ndouble Wn(double phix, double phiy, double phiz, double epsilon, double W0)\n{\n  return (W0*An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble taun(double phix, double phiy, double phiz, double epsilon, double tau0)\n{\n  return tau0 * SQ(An(phix,phiy,phiz,epsilon));\n}\n\n\ndouble dFunc(double l, double m, double n)\n{\n  if (l != 0.0 || m != 0.0 || n != 0.0){\n    return (((l*l*l*(SQ(m)+SQ(n)))-(l*(SQ(m)*SQ(m)+SQ(n)*SQ(n)))) /\n            ((SQ(l)+SQ(m)+SQ(n))*(SQ(l)+SQ(m)+SQ(n))));\n  }\n  else\n  {\n    return 0.0;\n  }\n}\n\nvoid calculateForce(double phi[][DATAYSIZE][DATAXSIZE], \n                    double Fx[][DATAYSIZE][DATAXSIZE],\n                    double Fy[][DATAYSIZE][DATAXSIZE],\n                    double Fz[][DATAYSIZE][DATAXSIZE],\n                    double dx, double dy, double dz,\n                    double epsilon, double W0, double tau0)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if ((ix < (DATAXSIZE-1)) && (iy < (DATAYSIZE-1)) && \n            (iz < (DATAZSIZE-1)) && (ix > (0)) && \n            (iy > (0)) && (iz > (0))) {\n\n          double phix = GradientX(phi,dx,dy,dz,ix,iy,iz);\n          double phiy = GradientY(phi,dx,dy,dz,ix,iy,iz);\n          double phiz = GradientZ(phi,dx,dy,dz,ix,iy,iz);\n          double sqGphi = SQ(phix) + SQ(phiy) + SQ(phiz);\n          double c = 16.0 * W0 * epsilon;\n          double w = Wn(phix,phiy,phiz,epsilon,W0);\n          double w2 = SQ(w);\n          \n\n          Fx[ix][iy][iz] = w2 * phix + sqGphi * w * c * dFunc(phix,phiy,phiz);\n          Fy[ix][iy][iz] = w2 * phiy + sqGphi * w * c * dFunc(phiy,phiz,phix);\n          Fz[ix][iy][iz] = w2 * phiz + sqGphi * w * c * dFunc(phiz,phix,phiy);\n        }\n        else\n        {\n          Fx[ix][iy][iz] = 0.0;\n          Fy[ix][iy][iz] = 0.0;\n          Fz[ix][iy][iz] = 0.0;\n        }\n      }\n    }\n  }\n}\n\n\n\nvoid allenCahn(double phinew[][DATAYSIZE][DATAXSIZE], \n               double phiold[][DATAYSIZE][DATAXSIZE],\n               double uold[][DATAYSIZE][DATAXSIZE],\n               double Fx[][DATAYSIZE][DATAXSIZE],\n               double Fy[][DATAYSIZE][DATAXSIZE],\n               double Fz[][DATAYSIZE][DATAXSIZE],\n               double epsilon, double W0, double tau0, double lambda,\n               double dt, double dx, double dy, double dz)\n{\n    for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        double phix = GradientX(phiold,dx,dy,dz,ix,iy,iz);\n        double phiy = GradientY(phiold,dx,dy,dz,ix,iy,iz);\n        double phiz = GradientZ(phiold,dx,dy,dz,ix,iy,iz); \n\n        phinew[ix][iy][iz] = phiold[ix][iy][iz] + \n         (dt / taun(phix,phiy,phiz,epsilon,tau0)) * \n         (Divergence(Fx,Fy,Fz,dx,dy,dz,ix,iy,iz) - \n          dFphi(phiold[ix][iy][iz], uold[ix][iy][iz],lambda));\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsPhi(double phinew[][DATAYSIZE][DATAXSIZE])\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (ix == DATAXSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iy == DATAYSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == 0){\n          phinew[ix][iy][iz] = -1.0;\n        }\n        else if (iz == DATAZSIZE-1){\n          phinew[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid thermalEquation(double unew[][DATAYSIZE][DATAXSIZE],\n                     double uold[][DATAYSIZE][DATAXSIZE],\n                     double phinew[][DATAYSIZE][DATAXSIZE],\n                     double phiold[][DATAYSIZE][DATAXSIZE],\n                     double D, double dt, double dx, double dy, double dz)\n{\n    for (int ix = 1; ix < DATAXSIZE-1; ix++) {\n    for (int iy = 1; iy < DATAYSIZE-1; iy++) {\n      for (int iz = 1; iz < DATAZSIZE-1; iz++) {\n\n        unew[ix][iy][iz] = uold[ix][iy][iz] + \n          0.5*(phinew[ix][iy][iz]-\n               phiold[ix][iy][iz]) +\n          dt * D * Laplacian(uold,dx,dy,dz,ix,iy,iz);\n      }\n    }\n  }\n}\n\nvoid boundaryConditionsU(double unew[][DATAYSIZE][DATAXSIZE], double delta)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n\n        if (ix == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (ix == DATAXSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iy == DATAYSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == 0){\n          unew[ix][iy][iz] =  -delta;\n        }\n        else if (iz == DATAZSIZE-1){\n          unew[ix][iy][iz] =  -delta;\n        }\n      }\n    }\n  }\n}\n\nvoid swapGrid(double cnew[][DATAYSIZE][DATAXSIZE],\n              double cold[][DATAYSIZE][DATAXSIZE])\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double tmp = cnew[ix][iy][iz];\n        cnew[ix][iy][iz] = cold[ix][iy][iz];\n        cold[ix][iy][iz] = tmp;\n      }\n    }\n  }\n}\n\nvoid initializationPhi(double phi[][DATAYSIZE][DATAXSIZE], double r0)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0){\n          phi[ix][iy][iz] = 1.0;\n        }\n        else\n        {\n          phi[ix][iy][iz] = -1.0;\n        }\n      }\n    }\n  }\n}\n\nvoid initializationU(double u[][DATAYSIZE][DATAXSIZE], double r0, double delta)\n{\n    for (int ix = 0; ix < DATAXSIZE; ix++) {\n    for (int iy = 0; iy < DATAYSIZE; iy++) {\n      for (int iz = 0; iz < DATAZSIZE; iz++) {\n        double r = std::sqrt(SQ(ix-0.5*DATAXSIZE) + SQ(iy-0.5*DATAYSIZE) + SQ(iz-0.5*DATAZSIZE));\n        if (r < r0) {\n          u[ix][iy][iz] = 0.0;\n        }\n        else\n        {\n          u[ix][iy][iz] = -delta * (1.0 - std::exp(-(r-r0)));\n        }\n      }\n    }\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  const int num_steps = atoi(argv[1]);  \n\n  const double dx = 0.4;\n  const double dy = 0.4;\n  const double dz = 0.4;\n  const double dt = 0.01;\n  const double delta = 0.8;\n  const double r0 = 5.0;\n  const double epsilon = 0.07;\n  const double W0 = 1.0;\n  const double beta0 = 0.0;\n  const double D = 2.0;\n  const double d0 = 0.5;\n  const double a1 = 1.25 / std::sqrt(2.0);\n  const double a2 = 0.64;\n  const double lambda = (W0*a1)/(d0);\n  const double tau0 = ((W0*W0*W0*a1*a2)/(d0*D)) + ((W0*W0*beta0)/(d0));\n\n  \n\n  const int nx = DATAXSIZE;\n  const int ny = DATAYSIZE;\n  const int nz = DATAZSIZE;\n  const int vol = nx * ny * nz;\n  const size_t vol_in_bytes = sizeof(double) * vol;\n\n  \n\n  nRarray *phi_host = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_host = (nRarray *)malloc(vol_in_bytes);\n  initializationPhi(phi_host,r0);\n  initializationU(u_host,r0,delta);\n\n#ifdef VERIFY\n  nRarray *phi_ref = (nRarray *)malloc(vol_in_bytes);\n  nRarray *u_ref = (nRarray *)malloc(vol_in_bytes);\n  memcpy(phi_ref, phi_host, vol_in_bytes);\n  memcpy(u_ref, u_host, vol_in_bytes);\n  reference(phi_ref, u_ref, vol, num_steps);\n#endif \n\n  auto offload_start = std::chrono::steady_clock::now();\n\n  \n\n  double *d_phiold = (double*)phi_host;\n  double *d_uold = (double*)u_host;\n  double *d_phinew = (double*) malloc (vol_in_bytes);\n  double *d_unew = (double*) malloc (vol_in_bytes);\n  double *d_Fx = (double*) malloc (vol_in_bytes);\n  double *d_Fy = (double*) malloc (vol_in_bytes);\n  double *d_Fz = (double*) malloc (vol_in_bytes);\n\n    {\n    int t = 0;\n\n    auto start = std::chrono::steady_clock::now();\n  \n    while (t <= num_steps) {\n  \n      calculateForce((nRarray*)d_phiold, (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                     dx,dy,dz,epsilon,W0,tau0);\n  \n      allenCahn((nRarray*)d_phinew,(nRarray*)d_phiold,(nRarray*)d_uold,\n                (nRarray*)d_Fx,(nRarray*)d_Fy,(nRarray*)d_Fz,\n                epsilon,W0,tau0,lambda, dt,dx,dy,dz);\n  \n      boundaryConditionsPhi((nRarray*)d_phinew);\n  \n      thermalEquation((nRarray*)d_unew,(nRarray*)d_uold,(nRarray*)d_phinew,(nRarray*)d_phiold,\n                      D,dt,dx,dy,dz);\n  \n      boundaryConditionsU((nRarray*)d_unew,delta);\n  \n      swapGrid((nRarray*)d_phinew, (nRarray*)d_phiold);\n  \n      swapGrid((nRarray*)d_unew, (nRarray*)d_uold);\n  \n      t++;\n    }\n  \n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %.3f (ms)\\n\", time * 1e-6f);\n  }\n\n  auto offload_end = std::chrono::steady_clock::now();\n  auto offload_time = std::chrono::duration_cast<std::chrono::nanoseconds>(offload_end - offload_start).count();\n  printf(\"Offload time: %.3f (ms)\\n\", offload_time * 1e-6f);\n\n#ifdef VERIFY\n  bool ok = true;\n  for (int idx = 0; idx < nx; idx++)\n    for (int idy = 0; idy < ny; idy++)\n      for (int idz = 0; idz < nz; idz++) {\n        if (fabs(phi_ref[idx][idy][idz] - phi_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"phi: %lf %lf\\n\", phi_ref[idx][idy][idz], phi_host[idx][idy][idz]);\n\t}\n        if (fabs(u_ref[idx][idy][idz] - u_host[idx][idy][idz]) > 1e-3) {\n          ok = false; printf(\"u: %lf %lf\\n\", u_ref[idx][idy][idz], u_host[idx][idy][idz]);\n        }\n      }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n  free(phi_ref);\n  free(u_ref);\n#endif\n\n  free(phi_host);\n  free(u_host);\n  free(d_phinew);\n  free(d_unew);\n  free(d_Fx);\n  free(d_Fy);\n  free(d_Fz);\n  return 0;\n}"}}
