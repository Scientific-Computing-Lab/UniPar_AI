{"kernel_name": "entropy", "parallel_api": "cuda", "code": {"main.cu": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include <cuda.h>\n#include \"reference.h\"\n\n__global__ \nvoid entropy(\n        float *__restrict__ d_entropy,\n    const char*__restrict__ d_val, \n    int height, int width)\n{\n  const int x = threadIdx.x + blockIdx.x * blockDim.x;\n  const int y = threadIdx.y + blockIdx.y * blockDim.y;\n\n  \n\n  char count[16];\n  for (int i = 0; i < 16; i++) count[i] = 0;\n\n  \n\n  char total = 0;\n\n  \n\n  for(int dy = -2; dy <= 2; dy++) {\n    for(int dx = -2; dx <= 2; dx++) {\n      int xx = x + dx;\n      int yy = y + dy;\n      if(xx >= 0 && yy >= 0 && yy < height && xx < width) {\n        count[d_val[yy * width + xx]]++;\n        total++;\n      }\n    }\n  }\n\n  float entropy = 0;\n  if (total < 1) {\n    total = 1;\n  } else {\n    for(int k = 0; k < 16; k++) {\n      float p = __fdividef((float)count[k], (float)total);\n      entropy -= p * log2f(p);\n    }\n  }\n\n  if(y < height && x < width) d_entropy[y * width + x] = entropy;\n}\n\ntemplate<int bsize_x, int bsize_y>\n__global__ void entropy_opt(\n       float *__restrict__ d_entropy,\n  const  char*__restrict__ d_val, \n  const float*__restrict__ d_logTable,\n  int m, int n)\n{\n  __shared__ int sd_count[16][bsize_y*bsize_x];\n\n  const int x = threadIdx.x + blockIdx.x * blockDim.x;\n  const int y = threadIdx.y + blockIdx.y * blockDim.y;\n  const int idx = threadIdx.y*bsize_x + threadIdx.x;\n\n  for(int i = 0; i < 16;i++) sd_count[i][idx] = 0;\n\n  char total = 0;\n  for(int dy = -2; dy <= 2; dy++) {\n    for(int dx = -2; dx <= 2; dx++) {\n      int xx = x + dx,\n          yy = y + dy;\n\n      if(xx >= 0 && yy >= 0 && yy < m && xx < n) {\n        sd_count[d_val[yy*n+xx]][idx]++;\n        total++;\n      }\n    }\n  }\n\n  float entropy = 0;\n  for(int k = 0; k < 16; k++)\n    entropy -= d_logTable[sd_count[k][idx]];\n  \n  entropy = entropy / total + log2f(total);\n  if(y < m && x < n) d_entropy[y*n+x] = entropy;\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <width> <height> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int width = atoi(argv[1]); \n  const int height = atoi(argv[2]); \n  const int repeat = atoi(argv[3]); \n\n  const int input_bytes = width * height * sizeof(char);\n  const int output_bytes = width * height * sizeof(float);\n  char* input = (char*) malloc (input_bytes);\n  float* output = (float*) malloc (output_bytes);\n  float* output_ref = (float*) malloc (output_bytes);\n\n  srand(123);\n  for (int i = 0; i < height; i++)\n    for (int j = 0; j < width; j++)\n      input[i * width + j] = rand() % 16;\n\n  char* d_input;\n  cudaMalloc((void**)&d_input, input_bytes);\n  cudaMemcpy(d_input, input, input_bytes, cudaMemcpyHostToDevice);\n\n  float* d_output;\n  cudaMalloc((void**)&d_output, output_bytes);\n\n  dim3 grids ((width+15)/16, (height+15)/16);\n  dim3 blocks (16, 16);\n\n  \n\n  cudaDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n  \n  for (int i = 0; i < repeat; i++)\n    entropy <<< grids, blocks >>> (d_output, d_input, height, width);\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel (baseline) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  \n\n\n  float logTable[26];\n  for (int i = 0; i <= 25; i++) logTable[i] = i <= 1 ? 0 : i*log2f(i);\n  float* d_logTable;\n  cudaMalloc((void**)&d_logTable, sizeof(logTable));\n  cudaMemcpy(d_logTable, logTable, sizeof(logTable), cudaMemcpyHostToDevice);\n \n  cudaDeviceSynchronize();\n  start = std::chrono::steady_clock::now();\n\n  for (int i = 0; i < repeat; i++)\n    entropy_opt<16, 16> <<< grids, blocks >>> (d_output, d_input, d_logTable, height, width);\n\n  cudaDeviceSynchronize();\n  end = std::chrono::steady_clock::now();\n  time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel (optimized) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  cudaMemcpy(output, d_output, output_bytes, cudaMemcpyDeviceToHost);\n\n  cudaFree(d_input);\n  cudaFree(d_output);\n  cudaFree(d_logTable);\n\n  \n\n  reference(output_ref, input, height, width);\n\n  bool ok = true;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (fabsf(output[i * width + j] - output_ref[i * width + j]) > 1e-3f) {\n        ok = false; \n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n \n  free(input);\n  free(output);\n  free(output_ref);\n  return 0;\n}\n"}}
{"kernel_name": "entropy", "parallel_api": "omp", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include <omp.h>\n#include \"reference.h\"\n\nvoid entropy(\n      float *__restrict d_entropy,\n  const char*__restrict d_val, \n  int height, int width)\n{\n  #pragma omp target teams distribute parallel for collapse(2) thread_limit(256) \n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      \n\n      char count[16];\n      for (int i = 0; i < 16; i++) count[i] = 0;\n\n      \n\n      char total = 0;\n\n      \n\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx;\n          int yy = y + dy;\n          if(xx >= 0 && yy >= 0 && yy < height && xx < width) {\n            count[d_val[yy * width + xx]]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      if (total < 1) {\n        total = 1;\n      } else {\n        for(int k = 0; k < 16; k++) {\n          float p = (float)count[k] / (float)total;\n          entropy -= p * log2f(p);\n        }\n      }\n\n      d_entropy[y * width + x] = entropy;\n    }\n  }\n}\n\ntemplate<int bsize_x, int bsize_y>\nvoid entropy_opt(\n       float *__restrict d_entropy,\n  const  char*__restrict d_val, \n  const float*__restrict d_logTable,\n  int m, int n)\n{\n  const int teamX = (n+bsize_x-1)/bsize_x;\n  const int teamY = (m+bsize_y-1)/bsize_y;\n  const int numTeams = teamX * teamY;\n\n  #pragma omp target teams num_teams(numTeams) thread_limit(bsize_x*bsize_y)\n  {\n    int sd_count[16][bsize_x*bsize_y];\n    #pragma omp parallel\n    {\n      const int threadIdx_x = omp_get_num_threads() % bsize_x;\n      const int threadIdx_y = omp_get_num_threads() / bsize_x;\n      const int teamIdx_x = omp_get_num_teams() % teamX;\n      const int teamIdx_y = omp_get_num_teams() / teamX;\n      const int x = teamIdx_x * bsize_x + threadIdx_x;\n      const int y = teamIdx_y * bsize_y + threadIdx_y;\n\n      const int idx = threadIdx_y*bsize_x + threadIdx_x;\n\n      for(int i = 0; i < 16; i++) sd_count[i][idx] = 0;\n\n      char total = 0;\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx,\n              yy = y + dy;\n\n          if(xx >= 0 && yy >= 0 && yy < m && xx < n) {\n            sd_count[d_val[yy*n+xx]][idx]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      for(int k = 0; k < 16; k++)\n        entropy -= d_logTable[sd_count[k][idx]];\n      \n      entropy = entropy / total + log2f(total);\n      if(y < m && x < n) d_entropy[y*n+x] = entropy;\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <width> <height> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int width = atoi(argv[1]); \n  const int height = atoi(argv[2]); \n  const int repeat = atoi(argv[3]); \n\n  const int input_bytes = width * height * sizeof(char);\n  const int output_bytes = width * height * sizeof(float);\n  char* input = (char*) malloc (input_bytes);\n  float* output = (float*) malloc (output_bytes);\n  float* output_ref = (float*) malloc (output_bytes);\n\n  float logTable[26];\n  for (int i = 0; i <= 25; i++) logTable[i] = i <= 1 ? 0 : i*log2f(i);\n\n  srand(123);\n  for (int i = 0; i < height; i++)\n    for (int j = 0; j < width; j++)\n      input[i * width + j] = rand() % 16;\n\n  #pragma omp target data map(to: input[0:width*height], logTable[0:26]) \\\n                          map(from: output[0:width*height])\n  {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy(output, input, height, width);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (baseline) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy_opt<16, 16>(output, input, logTable, height, width);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (optimized) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference(output_ref, input, height, width);\n\n  bool ok = true;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (fabsf(output[i * width + j] - output_ref[i * width + j]) > 1e-3f) {\n        ok = false; \n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n \n  free(input);\n  free(output);\n  free(output_ref);\n  return 0;\n}\n"}}
{"kernel_name": "entropy", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <chrono>\n#include \"reference.h\"\n\nvoid entropy(\n      float *__restrict d_entropy,\n  const char*__restrict d_val, \n  int height, int width)\n{\n    for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      \n\n      char count[16];\n      for (int i = 0; i < 16; i++) count[i] = 0;\n\n      \n\n      char total = 0;\n\n      \n\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx;\n          int yy = y + dy;\n          if(xx >= 0 && yy >= 0 && yy < height && xx < width) {\n            count[d_val[yy * width + xx]]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      if (total < 1) {\n        total = 1;\n      } else {\n        for(int k = 0; k < 16; k++) {\n          float p = (float)count[k] / (float)total;\n          entropy -= p * log2f(p);\n        }\n      }\n\n      d_entropy[y * width + x] = entropy;\n    }\n  }\n}\n\ntemplate<int bsize_x, int bsize_y>\nvoid entropy_opt(\n       float *__restrict d_entropy,\n  const  char*__restrict d_val, \n  const float*__restrict d_logTable,\n  int m, int n)\n{\n  const int teamX = (n+bsize_x-1)/bsize_x;\n  const int teamY = (m+bsize_y-1)/bsize_y;\n  const int numTeams = teamX * teamY;\n\n    {\n    int sd_count[16][bsize_x*bsize_y];\n        {\n      const int threadIdx_x = omp_get_num_threads() % bsize_x;\n      const int threadIdx_y = omp_get_num_threads() / bsize_x;\n      const int teamIdx_x = omp_get_num_teams() % teamX;\n      const int teamIdx_y = omp_get_num_teams() / teamX;\n      const int x = teamIdx_x * bsize_x + threadIdx_x;\n      const int y = teamIdx_y * bsize_y + threadIdx_y;\n\n      const int idx = threadIdx_y*bsize_x + threadIdx_x;\n\n      for(int i = 0; i < 16; i++) sd_count[i][idx] = 0;\n\n      char total = 0;\n      for(int dy = -2; dy <= 2; dy++) {\n        for(int dx = -2; dx <= 2; dx++) {\n          int xx = x + dx,\n              yy = y + dy;\n\n          if(xx >= 0 && yy >= 0 && yy < m && xx < n) {\n            sd_count[d_val[yy*n+xx]][idx]++;\n            total++;\n          }\n        }\n      }\n\n      float entropy = 0;\n      for(int k = 0; k < 16; k++)\n        entropy -= d_logTable[sd_count[k][idx]];\n      \n      entropy = entropy / total + log2f(total);\n      if(y < m && x < n) d_entropy[y*n+x] = entropy;\n    }\n  }\n}\n\nint main(int argc, char* argv[]) {\n  if (argc != 4) {\n    printf(\"Usage: %s <width> <height> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n  const int width = atoi(argv[1]); \n  const int height = atoi(argv[2]); \n  const int repeat = atoi(argv[3]); \n\n  const int input_bytes = width * height * sizeof(char);\n  const int output_bytes = width * height * sizeof(float);\n  char* input = (char*) malloc (input_bytes);\n  float* output = (float*) malloc (output_bytes);\n  float* output_ref = (float*) malloc (output_bytes);\n\n  float logTable[26];\n  for (int i = 0; i <= 25; i++) logTable[i] = i <= 1 ? 0 : i*log2f(i);\n\n  srand(123);\n  for (int i = 0; i < height; i++)\n    for (int j = 0; j < width; j++)\n      input[i * width + j] = rand() % 16;\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy(output, input, height, width);\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (baseline) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n    start = std::chrono::steady_clock::now();\n\n    for (int i = 0; i < repeat; i++)\n      entropy_opt<16, 16>(output, input, logTable, height, width);\n\n    end = std::chrono::steady_clock::now();\n    time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel (optimized) execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  reference(output_ref, input, height, width);\n\n  bool ok = true;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (fabsf(output[i * width + j] - output_ref[i * width + j]) > 1e-3f) {\n        ok = false; \n        break;\n      }\n    }\n    if (!ok) break;\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n \n  free(input);\n  free(output);\n  free(output_ref);\n  return 0;\n}"}}