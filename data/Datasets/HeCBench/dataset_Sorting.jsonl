{"kernel_name": "bitonic-sort", "kernel_api": "cuda", "code": {"main.cu": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <math.h>\n#include <string.h>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <cuda.h>\n\n#define BLOCK_SIZE 256\n\n__global__\nvoid bitonic_sort (const int seq_len, const int two_power, int *a)\n{\n  int i = blockDim.x * blockIdx.x + threadIdx.x;\n\n  \n\n  int seq_num = i / seq_len;\n\n  \n\n  int swapped_ele = -1;\n\n  \n\n  \n\n  \n\n  \n\n  int h_len = seq_len / 2;\n\n  if (i < (seq_len * seq_num) + h_len) swapped_ele = i + h_len;\n\n  \n\n  int odd = seq_num / two_power;\n\n  \n\n  \n\n  bool increasing = ((odd % 2) == 0);\n\n  \n\n  if (swapped_ele != -1) {\n    if (((a[i] > a[swapped_ele]) && increasing) ||\n\t((a[i] < a[swapped_ele]) && !increasing)) {\n      int temp = a[i];\n      a[i] = a[swapped_ele];\n      a[swapped_ele] = temp;\n    }\n  }\n}\n\nvoid ParallelBitonicSort(int input[], int n) {\n\n  \n\n  int size = pow(2, n);\n  size_t size_bytes = sizeof(int) * size;\n\n  int *d_input;\n  cudaMalloc((void**)&d_input, size_bytes);\n  cudaMemcpy(d_input, input, size_bytes, cudaMemcpyHostToDevice);\n  \n  auto start = std::chrono::steady_clock::now();\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      \n\n      \n\n      \n\n      int seq_len = pow(2, stage + 1);\n      \n\n      int two_power = 1 << (step - stage);\n      bitonic_sort<<< size/BLOCK_SIZE, BLOCK_SIZE >>> (seq_len, two_power, d_input);\n    }  \n\n  } \n\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Total kernel execution time: %f (ms)\\n\", time * 1e-6f);\n\n  cudaMemcpy(input, d_input, size_bytes, cudaMemcpyDeviceToHost);\n  cudaFree(d_input);\n}\n\n\n\nvoid SwapElements(int step, int stage, int num_sequence, int seq_len,\n                  int *array) {\n  for (int seq_num = 0; seq_num < num_sequence; seq_num++) {\n    int odd = seq_num / (pow(2, (step - stage)));\n    bool increasing = ((odd % 2) == 0);\n\n    int h_len = seq_len / 2;\n\n    \n\n    for (int i = seq_num * seq_len; i < seq_num * seq_len + h_len; i++) {\n      int swapped_ele = i + h_len;\n\n      if (((array[i] > array[swapped_ele]) && increasing) ||\n          ((array[i] < array[swapped_ele]) && !increasing)) {\n        int temp = array[i];\n        array[i] = array[swapped_ele];\n        array[swapped_ele] = temp;\n      }\n    }  \n\n  }    \n\n}\n\n\n\n\n\ninline void BitonicSort(int a[], int n) {\n  \n\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      int num_sequence = pow(2, (n - stage - 1));\n      \n\n      int sequence_len = pow(2, stage + 1);\n\n      SwapElements(step, stage, num_sequence, sequence_len, a);\n    }\n  }\n}\n\nvoid Usage(std::string prog_name, int exponent) {\n  std::cout << \" Incorrect parameters\\n\";\n  std::cout << \" Usage: \" << prog_name << \" n k \\n\\n\";\n  std::cout << \" n: Integer exponent presenting the size of the input array. \"\n               \"The number of element in\\n\";\n  std::cout << \"    the array must be power of 2 (e.g., 1, 2, 4, ...). Please \"\n               \"enter the corresponding\\n\";\n  std::cout << \"    exponent between 0 and \" << exponent - 1 << \".\\n\";\n  std::cout << \" k: Seed used to generate a random sequence.\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  int n, seed, size;\n  int exp_max = log2(std::numeric_limits<int>::max());\n\n  \n\n  try {\n    n = std::stoi(argv[1]);\n\n    \n\n    if (n < 0 || n >= exp_max) {\n      Usage(argv[0], exp_max);\n      return -1;\n    }\n\n    seed = std::stoi(argv[2]);\n    size = pow(2, n);\n  } catch (...) {\n    Usage(argv[0], exp_max);\n    return -1;\n  }\n\n  std::cout << \"\\nArray size: \" << size << \", seed: \" << seed << \"\\n\";\n\n  size_t size_bytes = size * sizeof(int);\n\n  \n\n  int *data_cpu = (int *)malloc(size_bytes);\n\n  \n\n  int *data_gpu = (int *)malloc(size_bytes);\n\n  \n\n  srand(seed);\n\n  for (int i = 0; i < size; i++) {\n    data_gpu[i] = data_cpu[i] = rand() % 1000;\n  }\n\n  std::cout << \"Bitonic sort (parallel)..\\n\";\n  ParallelBitonicSort(data_gpu, n);\n\n\n  std::cout << \"Bitonic sort (serial)..\\n\";\n  BitonicSort(data_cpu, n);\n\n  \n\n  int unequal = memcmp(data_gpu, data_cpu, size_bytes);\n  std::cout << (unequal ? \"FAIL\" : \"PASS\") << std::endl;\n\n  \n\n  free(data_cpu);\n  free(data_gpu);\n\n  return 0;\n}\n"}}
{"kernel_name": "bitonic-sort", "kernel_api": "hip", "code": {"main.cu": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <math.h>\n#include <string.h>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <hip/hip_runtime.h>\n\n#define BLOCK_SIZE 256\n\n__global__\nvoid bitonic_sort (const int seq_len, const int two_power, int *a)\n{\n  int i = blockDim.x * blockIdx.x + threadIdx.x;\n\n  \n\n  int seq_num = i / seq_len;\n\n  \n\n  int swapped_ele = -1;\n\n  \n\n  \n\n  \n\n  \n\n  int h_len = seq_len / 2;\n\n  if (i < (seq_len * seq_num) + h_len) swapped_ele = i + h_len;\n\n  \n\n  int odd = seq_num / two_power;\n\n  \n\n  \n\n  bool increasing = ((odd % 2) == 0);\n\n  \n\n  if (swapped_ele != -1) {\n    if (((a[i] > a[swapped_ele]) && increasing) ||\n\t((a[i] < a[swapped_ele]) && !increasing)) {\n      int temp = a[i];\n      a[i] = a[swapped_ele];\n      a[swapped_ele] = temp;\n    }\n  }\n}\n\nvoid ParallelBitonicSort(int input[], int n) {\n\n  \n\n  int size = pow(2, n);\n  size_t size_bytes = sizeof(int) * size;\n\n  int *d_input;\n  hipMalloc((void**)&d_input, size_bytes);\n  hipMemcpy(d_input, input, size_bytes, hipMemcpyHostToDevice);\n  \n  auto start = std::chrono::steady_clock::now();\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      \n\n      \n\n      \n\n      int seq_len = pow(2, stage + 1);\n      \n\n      int two_power = 1 << (step - stage);\n      bitonic_sort<<< size/BLOCK_SIZE, BLOCK_SIZE >>> (seq_len, two_power, d_input);\n    }  \n\n  } \n\n\n  hipDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Total kernel execution time: %f (ms)\\n\", time * 1e-6f);\n\n  hipMemcpy(input, d_input, size_bytes, hipMemcpyDeviceToHost);\n  hipFree(d_input);\n}\n\n\n\nvoid SwapElements(int step, int stage, int num_sequence, int seq_len,\n                  int *array) {\n  for (int seq_num = 0; seq_num < num_sequence; seq_num++) {\n    int odd = seq_num / (pow(2, (step - stage)));\n    bool increasing = ((odd % 2) == 0);\n\n    int h_len = seq_len / 2;\n\n    \n\n    for (int i = seq_num * seq_len; i < seq_num * seq_len + h_len; i++) {\n      int swapped_ele = i + h_len;\n\n      if (((array[i] > array[swapped_ele]) && increasing) ||\n          ((array[i] < array[swapped_ele]) && !increasing)) {\n        int temp = array[i];\n        array[i] = array[swapped_ele];\n        array[swapped_ele] = temp;\n      }\n    }  \n\n  }    \n\n}\n\n\n\n\n\ninline void BitonicSort(int a[], int n) {\n  \n\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      int num_sequence = pow(2, (n - stage - 1));\n      \n\n      int sequence_len = pow(2, stage + 1);\n\n      SwapElements(step, stage, num_sequence, sequence_len, a);\n    }\n  }\n}\n\nvoid Usage(std::string prog_name, int exponent) {\n  std::cout << \" Incorrect parameters\\n\";\n  std::cout << \" Usage: \" << prog_name << \" n k \\n\\n\";\n  std::cout << \" n: Integer exponent presenting the size of the input array. \"\n               \"The number of element in\\n\";\n  std::cout << \"    the array must be power of 2 (e.g., 1, 2, 4, ...). Please \"\n               \"enter the corresponding\\n\";\n  std::cout << \"    exponent between 0 and \" << exponent - 1 << \".\\n\";\n  std::cout << \" k: Seed used to generate a random sequence.\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  int n, seed, size;\n  int exp_max = log2(std::numeric_limits<int>::max());\n\n  \n\n  try {\n    n = std::stoi(argv[1]);\n\n    \n\n    if (n < 0 || n >= exp_max) {\n      Usage(argv[0], exp_max);\n      return -1;\n    }\n\n    seed = std::stoi(argv[2]);\n    size = pow(2, n);\n  } catch (...) {\n    Usage(argv[0], exp_max);\n    return -1;\n  }\n\n  std::cout << \"\\nArray size: \" << size << \", seed: \" << seed << \"\\n\";\n\n  size_t size_bytes = size * sizeof(int);\n\n  \n\n  int *data_cpu = (int *)malloc(size_bytes);\n\n  \n\n  int *data_gpu = (int *)malloc(size_bytes);\n\n  \n\n  srand(seed);\n\n  for (int i = 0; i < size; i++) {\n    data_gpu[i] = data_cpu[i] = rand() % 1000;\n  }\n\n  std::cout << \"Bitonic sort (parallel)..\\n\";\n  ParallelBitonicSort(data_gpu, n);\n\n  std::cout << \"Bitonic sort (serial)..\\n\";\n  BitonicSort(data_cpu, n);\n\n  \n\n  int unequal = memcmp(data_gpu, data_cpu, size_bytes);\n  std::cout << (unequal ? \"FAIL\" : \"PASS\") << std::endl;\n\n  \n\n  free(data_cpu);\n  free(data_gpu);\n\n  return 0;\n}\n"}}
{"kernel_name": "bitonic-sort", "kernel_api": "omp", "code": {"main.cpp": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <math.h>\n#include <string.h>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <omp.h>\n\nvoid ParallelBitonicSort(int input[], int n) {\n\n  \n\n  int size = pow(2, n);\n\n  \n\n  #pragma omp target data map(tofrom: input[0:size]) \n  {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int step = 0; step < n; step++) {\n      \n\n      for (int stage = step; stage >= 0; stage--) {\n        \n\n        \n\n        \n\n        \n\n        int seq_len = pow(2, stage + 1);\n        \n\n        int two_power = 1 << (step - stage);\n\n        \n\n        #pragma omp target teams distribute parallel for thread_limit(256)\n        for (int i = 0; i < size; i++) {\n          \n\n          int seq_num = i / seq_len;\n\n          \n\n          int swapped_ele = -1;\n\n          \n\n          \n\n          \n\n          \n\n          int h_len = seq_len / 2;\n\n          if (i < (seq_len * seq_num) + h_len) swapped_ele = i + h_len;\n\n          \n\n          int odd = seq_num / two_power;\n\n          \n\n          \n\n          bool increasing = ((odd % 2) == 0);\n\n          \n\n          if (swapped_ele != -1) {\n            if (((input[i] > input[swapped_ele]) && increasing) ||\n                ((input[i] < input[swapped_ele]) && !increasing)) {\n              int temp = input[i];\n              input[i] = input[swapped_ele];\n              input[swapped_ele] = temp;\n            }\n          }\n        }\n      }  \n\n    } \n\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %f (ms)\\n\", time * 1e-6f);\n  }\n}\n\n\n\nvoid SwapElements(int step, int stage, int num_sequence, int seq_len,\n                  int *array) {\n  for (int seq_num = 0; seq_num < num_sequence; seq_num++) {\n    int odd = seq_num / (pow(2, (step - stage)));\n    bool increasing = ((odd % 2) == 0);\n\n    int h_len = seq_len / 2;\n\n    \n\n    for (int i = seq_num * seq_len; i < seq_num * seq_len + h_len; i++) {\n      int swapped_ele = i + h_len;\n\n      if (((array[i] > array[swapped_ele]) && increasing) ||\n          ((array[i] < array[swapped_ele]) && !increasing)) {\n        int temp = array[i];\n        array[i] = array[swapped_ele];\n        array[swapped_ele] = temp;\n      }\n    }  \n\n  }    \n\n}\n\n\n\n\n\ninline void BitonicSort(int a[], int n) {\n  \n\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      int num_sequence = pow(2, (n - stage - 1));\n      \n\n      int sequence_len = pow(2, stage + 1);\n\n      SwapElements(step, stage, num_sequence, sequence_len, a);\n    }\n  }\n}\n\n\n\nvoid DisplayArray(int a[], int array_size) {\n  for (int i = 0; i < array_size; ++i) std::cout << a[i] << \" \";\n  std::cout << \"\\n\";\n}\n\nvoid Usage(std::string prog_name, int exponent) {\n  std::cout << \" Incorrect parameters\\n\";\n  std::cout << \" Usage: \" << prog_name << \" n k \\n\\n\";\n  std::cout << \" n: Integer exponent presenting the size of the input array. \"\n               \"The number of element in\\n\";\n  std::cout << \"    the array must be power of 2 (e.g., 1, 2, 4, ...). Please \"\n               \"enter the corresponding\\n\";\n  std::cout << \"    exponent between 0 and \" << exponent - 1 << \".\\n\";\n  std::cout << \" k: Seed used to generate a random sequence.\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  int n, seed, size;\n  int exp_max = log2(std::numeric_limits<int>::max());\n\n  \n\n  try {\n    n = std::stoi(argv[1]);\n\n    \n\n    if (n < 0 || n >= exp_max) {\n      Usage(argv[0], exp_max);\n      return -1;\n    }\n\n    seed = std::stoi(argv[2]);\n    size = pow(2, n);\n  } catch (...) {\n    Usage(argv[0], exp_max);\n    return -1;\n  }\n\n  std::cout << \"\\nArray size: \" << size << \", seed: \" << seed << \"\\n\";\n\n  size_t size_bytes = size * sizeof(int);\n\n  \n\n  int *data_cpu = (int *)malloc(size_bytes);\n\n  \n\n  int *data_gpu = (int *)malloc(size_bytes);\n\n  \n\n  srand(seed);\n\n  for (int i = 0; i < size; i++) {\n    data_gpu[i] = data_cpu[i] = rand() % 1000;\n  }\n\n  std::cout << \"Bitonic sort (parallel)..\\n\";\n  ParallelBitonicSort(data_gpu, n);\n\n  std::cout << \"Bitonic sort (serial)..\\n\";\n  BitonicSort(data_cpu, n);\n\n  \n\n  int unequal = memcmp(data_gpu, data_cpu, size_bytes);\n  std::cout << (unequal ? \"FAIL\" : \"PASS\") << std::endl;\n\n  \n\n  free(data_cpu);\n  free(data_gpu);\n\n  return 0;\n}\n"}}
{"kernel_name": "bitonic-sort", "kernel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <math.h>\n#include <string.h>\n#include <chrono>\n#include <iostream>\n#include <limits>\n\nvoid ParallelBitonicSort(int input[], int n) {\n\n  \n\n  int size = pow(2, n);\n\n  \n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (int step = 0; step < n; step++) {\n      \n\n      for (int stage = step; stage >= 0; stage--) {\n        \n\n        \n\n        \n\n        \n\n        int seq_len = pow(2, stage + 1);\n        \n\n        int two_power = 1 << (step - stage);\n\n        \n\n                for (int i = 0; i < size; i++) {\n          \n\n          int seq_num = i / seq_len;\n\n          \n\n          int swapped_ele = -1;\n\n          \n\n          \n\n          \n\n          \n\n          int h_len = seq_len / 2;\n\n          if (i < (seq_len * seq_num) + h_len) swapped_ele = i + h_len;\n\n          \n\n          int odd = seq_num / two_power;\n\n          \n\n          \n\n          bool increasing = ((odd % 2) == 0);\n\n          \n\n          if (swapped_ele != -1) {\n            if (((input[i] > input[swapped_ele]) && increasing) ||\n                ((input[i] < input[swapped_ele]) && !increasing)) {\n              int temp = input[i];\n              input[i] = input[swapped_ele];\n              input[swapped_ele] = temp;\n            }\n          }\n        }\n      }  \n\n    } \n\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Total kernel execution time: %f (ms)\\n\", time * 1e-6f);\n  }\n}\n\n\n\nvoid SwapElements(int step, int stage, int num_sequence, int seq_len,\n                  int *array) {\n  for (int seq_num = 0; seq_num < num_sequence; seq_num++) {\n    int odd = seq_num / (pow(2, (step - stage)));\n    bool increasing = ((odd % 2) == 0);\n\n    int h_len = seq_len / 2;\n\n    \n\n    for (int i = seq_num * seq_len; i < seq_num * seq_len + h_len; i++) {\n      int swapped_ele = i + h_len;\n\n      if (((array[i] > array[swapped_ele]) && increasing) ||\n          ((array[i] < array[swapped_ele]) && !increasing)) {\n        int temp = array[i];\n        array[i] = array[swapped_ele];\n        array[swapped_ele] = temp;\n      }\n    }  \n\n  }    \n\n}\n\n\n\n\n\ninline void BitonicSort(int a[], int n) {\n  \n\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      int num_sequence = pow(2, (n - stage - 1));\n      \n\n      int sequence_len = pow(2, stage + 1);\n\n      SwapElements(step, stage, num_sequence, sequence_len, a);\n    }\n  }\n}\n\n\n\nvoid DisplayArray(int a[], int array_size) {\n  for (int i = 0; i < array_size; ++i) std::cout << a[i] << \" \";\n  std::cout << \"\\n\";\n}\n\nvoid Usage(std::string prog_name, int exponent) {\n  std::cout << \" Incorrect parameters\\n\";\n  std::cout << \" Usage: \" << prog_name << \" n k \\n\\n\";\n  std::cout << \" n: Integer exponent presenting the size of the input array. \"\n               \"The number of element in\\n\";\n  std::cout << \"    the array must be power of 2 (e.g., 1, 2, 4, ...). Please \"\n               \"enter the corresponding\\n\";\n  std::cout << \"    exponent between 0 and \" << exponent - 1 << \".\\n\";\n  std::cout << \" k: Seed used to generate a random sequence.\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  int n, seed, size;\n  int exp_max = log2(std::numeric_limits<int>::max());\n\n  \n\n  try {\n    n = std::stoi(argv[1]);\n\n    \n\n    if (n < 0 || n >= exp_max) {\n      Usage(argv[0], exp_max);\n      return -1;\n    }\n\n    seed = std::stoi(argv[2]);\n    size = pow(2, n);\n  } catch (...) {\n    Usage(argv[0], exp_max);\n    return -1;\n  }\n\n  std::cout << \"\\nArray size: \" << size << \", seed: \" << seed << \"\\n\";\n\n  size_t size_bytes = size * sizeof(int);\n\n  \n\n  int *data_cpu = (int *)malloc(size_bytes);\n\n  \n\n  int *data_gpu = (int *)malloc(size_bytes);\n\n  \n\n  srand(seed);\n\n  for (int i = 0; i < size; i++) {\n    data_gpu[i] = data_cpu[i] = rand() % 1000;\n  }\n\n  std::cout << \"Bitonic sort (parallel)..\\n\";\n  ParallelBitonicSort(data_gpu, n);\n\n  std::cout << \"Bitonic sort (serial)..\\n\";\n  BitonicSort(data_cpu, n);\n\n  \n\n  int unequal = memcmp(data_gpu, data_cpu, size_bytes);\n  std::cout << (unequal ? \"FAIL\" : \"PASS\") << std::endl;\n\n  \n\n  free(data_cpu);\n  free(data_gpu);\n\n  return 0;\n}"}}
{"kernel_name": "bitonic-sort", "kernel_api": "sycl", "code": {"main.cpp": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <math.h>\n#include <string.h>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <sycl/sycl.hpp>\n\n#define BLOCK_SIZE 256\n\nvoid ParallelBitonicSort(int input[], int n) {\n\n  \n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  \n\n  int size = pow(2, n);\n  size_t size_bytes = sizeof(int) * size;\n\n  int *d_input = sycl::malloc_device<int>(size, q);\n  q.memcpy(d_input, input, size_bytes).wait();\n\n  auto start = std::chrono::steady_clock::now();\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      \n\n      \n\n      \n\n      int seq_len = pow(2, stage + 1);\n      \n\n      int two_power = 1 << (step - stage);\n\n      \n\n      q.submit([&](sycl::handler &h) {\n        h.parallel_for(sycl::nd_range<1>(\n          sycl::range<1>(size), sycl::range<1>(BLOCK_SIZE)), [=](sycl::nd_item<1> item) {\n          int i = item.get_global_id(0);\n \n          \n\n          int seq_num = i / seq_len;\n\n          \n\n          int swapped_ele = -1;\n\n          \n\n          \n\n          \n\n          \n\n          int h_len = seq_len / 2;\n\n          if (i < (seq_len * seq_num) + h_len) swapped_ele = i + h_len;\n\n          \n\n          int odd = seq_num / two_power;\n\n          \n\n          \n\n          bool increasing = ((odd % 2) == 0);\n\n          \n\n          if (swapped_ele != -1) {\n            if (((d_input[i] > d_input[swapped_ele]) && increasing) ||\n                ((d_input[i] < d_input[swapped_ele]) && !increasing)) {\n              int temp = d_input[i];\n              d_input[i] = d_input[swapped_ele];\n              d_input[swapped_ele] = temp;\n            }\n          }\n        });\n      });\n    }  \n\n  }    \n\n\n  q.wait();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Total kernel execution time: %f (ms)\\n\", time * 1e-6f);\n\n  q.memcpy(input, d_input, size_bytes).wait();\n  sycl::free(d_input, q);\n}\n\n\n\nvoid SwapElements(int step, int stage, int num_sequence, int seq_len,\n                  int *array) {\n  for (int seq_num = 0; seq_num < num_sequence; seq_num++) {\n    int odd = seq_num / (pow(2, (step - stage)));\n    bool increasing = ((odd % 2) == 0);\n\n    int h_len = seq_len / 2;\n\n    \n\n    for (int i = seq_num * seq_len; i < seq_num * seq_len + h_len; i++) {\n      int swapped_ele = i + h_len;\n\n      if (((array[i] > array[swapped_ele]) && increasing) ||\n          ((array[i] < array[swapped_ele]) && !increasing)) {\n        int temp = array[i];\n        array[i] = array[swapped_ele];\n        array[swapped_ele] = temp;\n      }\n    }  \n\n  }    \n\n}\n\n\n\n\n\ninline void BitonicSort(int a[], int n) {\n  \n\n\n  \n\n  for (int step = 0; step < n; step++) {\n    \n\n    for (int stage = step; stage >= 0; stage--) {\n      \n\n      int num_sequence = pow(2, (n - stage - 1));\n      \n\n      int sequence_len = pow(2, stage + 1);\n\n      SwapElements(step, stage, num_sequence, sequence_len, a);\n    }\n  }\n}\n\n\n\nvoid DisplayArray(int a[], int array_size) {\n  for (int i = 0; i < array_size; ++i) std::cout << a[i] << \" \";\n  std::cout << \"\\n\";\n}\n\nvoid Usage(std::string prog_name, int exponent) {\n  std::cout << \" Incorrect parameters\\n\";\n  std::cout << \" Usage: \" << prog_name << \" n k \\n\\n\";\n  std::cout << \" n: Integer exponent presenting the size of the input array. \"\n               \"The number of element in\\n\";\n  std::cout << \"    the array must be power of 2 (e.g., 1, 2, 4, ...). Please \"\n               \"enter the corresponding\\n\";\n  std::cout << \"    exponent between 0 and \" << exponent - 1 << \".\\n\";\n  std::cout << \" k: Seed used to generate a random sequence.\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  int n, seed, size;\n  int exp_max = log2(std::numeric_limits<int>::max());\n\n  \n\n  try {\n    n = std::stoi(argv[1]);\n\n    \n\n    if (n < 0 || n >= exp_max) {\n      Usage(argv[0], exp_max);\n      return -1;\n    }\n\n    seed = std::stoi(argv[2]);\n    size = pow(2, n);\n  } catch (...) {\n    Usage(argv[0], exp_max);\n    return -1;\n  }\n\n  std::cout << \"\\nArray size: \" << size << \", seed: \" << seed << \"\\n\";\n\n  size_t size_bytes = size * sizeof(int);\n\n  \n\n  int *data_cpu = (int *)malloc(size_bytes);\n\n  \n\n  int *data_gpu = (int *)malloc(size_bytes);\n\n  \n\n  srand(seed);\n\n  for (int i = 0; i < size; i++) {\n    data_gpu[i] = data_cpu[i] = rand() % 1000;\n  }\n\n  std::cout << \"Bitonic sort (parallel)..\\n\";\n  ParallelBitonicSort(data_gpu, n);\n\n  std::cout << \"Bitonic sort (serial)..\\n\";\n  BitonicSort(data_cpu, n);\n\n  \n\n  int unequal = memcmp(data_gpu, data_cpu, size_bytes);\n  std::cout << (unequal ? \"FAIL\" : \"PASS\") << std::endl;\n\n  \n\n  free(data_cpu);\n  free(data_gpu);\n\n  return 0;\n}\n"}}
{"kernel_name": "merge", "kernel_api": "cuda", "code": {"main.cu": "#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <float.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <cuda.h>\n#include \"kernels.h\"\n\n#define CSV 0\n#if(CSV)\n#define PS(X, S) std::cout << X << \", \" << S << \", \"; fflush(stdout);\n#define PV(X) std::cout << X << \", \"; fflush(stdout);\n#else\n#define PS(X, S) std::cout << X << \" \" << S <<\" :\\n\"; fflush(stdout);\n#define PV(X) std::cout << \"\\t\" << #X << \" \\t: \" << X << \"\\n\"; fflush(stdout);\n#endif\n\n\n\ntemplate<typename vec_t>\nvec_t rand64() {\n  vec_t rtn;\n  do {\n    uint32_t * rtn32 = (uint32_t *)&rtn;\n    rtn32[0] = rand();\n    if(sizeof(vec_t) > 4) rtn32[1] = rand();\n  } while(!(rtn < getPositiveInfinity<vec_t>() &&\n        rtn > getNegativeInfinity<vec_t>()));\n  return rtn;\n}\n\n\n\n#define PADDING 1024\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nvoid mergeType(const uint64_t size, const uint32_t runs) {\n  \n\n  std::vector<vec_t> hA (size + PADDING);\n  std::vector<vec_t> hB (size + PADDING);\n  std::vector<vec_t> hC (2*size + PADDING);\n\n  vec_t *dA;\n  vec_t *dB;\n  vec_t *dC;\n\n  cudaMalloc((void**)&dA, (size + PADDING) * sizeof(vec_t));\n  cudaMalloc((void**)&dB, (size + PADDING) * sizeof(vec_t));\n  cudaMalloc((void**)&dC, (2*size + PADDING) * sizeof(vec_t));\n\n  uint32_t *dpi; \n\n  cudaMalloc((void**)&dpi, (2 * (blocks + 1)) * sizeof(uint32_t));\n\n  uint32_t errors = 0;\n\n  double total_time = 0.0;\n\n  for(uint32_t r = 0; r < runs; r++) {\n\n    \n\n    for (uint64_t n = 0; n < size; n++) {\n       hA[n] = rand64<vec_t>();\n       hB[n] = rand64<vec_t>();\n    }\n\n    for (uint64_t n = size; n < size + PADDING; n++) {\n      hA[n] = getPositiveInfinity<vec_t>();\n      hB[n] = getPositiveInfinity<vec_t>();\n    }\n\n    std::sort(hA.begin(), hA.end());\n    std::sort(hB.begin(), hB.end());\n\n    cudaMemcpy(dA, hA.data(), (size + PADDING) * sizeof(vec_t), cudaMemcpyHostToDevice);\n    cudaMemcpy(dB, hB.data(), (size + PADDING) * sizeof(vec_t), cudaMemcpyHostToDevice);\n\n    cudaDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    \n\n    workloadDiagonals<vec_t><<<blocks, 32>>> (dA, size, dB, size, dpi);\n\n    \n\n    mergeSinglePath<vec_t,false,false> <<<blocks, threads>>>\n        (dA, size, dB, size, dpi, dC, size * 2);\n\n    cudaDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n  \n    \n\n    cudaMemcpy(hC.data(), dC, size * sizeof(vec_t), cudaMemcpyDeviceToHost);\n    for(uint32_t i = 1; i < size; i++) {\n      errors += hC[i] < hC[i-1];\n    }\n  }\n\n  cudaFree(dA);\n  cudaFree(dB);\n  cudaFree(dC);\n  cudaFree(dpi);\n\n  PV(errors); \n\n  printf(\"%s. \", errors ? \"FAIL\" : \"PASS\");\n\n  if (timing)\n    printf(\"Average kernel execution time: %f (us).\\n\", (total_time * 1e-3f) / runs);\n  else\n    printf(\"Warmup run\\n\");\n}\n\n\n\ntemplate<uint32_t blocks, uint32_t threads>\nvoid mergeAllTypes(const uint64_t size, const uint32_t runs) {\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"double\", size)    mergeType<double,   blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"double\", size)    mergeType<double,   blocks, threads, true>(size, runs); printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length of the arrays> <runs>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  \n\n  const uint64_t length = atol(argv[1]);\n\n  const uint32_t runs = atoi(argv[2]);\n\n  const int blocks = 112;\n  const int threads = 128;  \n\n\n  mergeAllTypes<blocks, threads>(length, runs);\n\n  return 0;\n}\n"}}
{"kernel_name": "merge", "kernel_api": "hip", "code": {"main.cu": "#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <float.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <hip/hip_runtime.h>\n#include \"kernels.h\"\n\n#define CSV 0\n#if(CSV)\n#define PS(X, S) std::cout << X << \", \" << S << \", \"; fflush(stdout);\n#define PV(X) std::cout << X << \", \"; fflush(stdout);\n#else\n#define PS(X, S) std::cout << X << \" \" << S <<\" :\\n\"; fflush(stdout);\n#define PV(X) std::cout << \"\\t\" << #X << \" \\t: \" << X << \"\\n\"; fflush(stdout);\n#endif\n\n\n\ntemplate<typename vec_t>\nvec_t rand64() {\n  vec_t rtn;\n  do {\n    uint32_t * rtn32 = (uint32_t *)&rtn;\n    rtn32[0] = rand();\n    if(sizeof(vec_t) > 4) rtn32[1] = rand();\n  } while(!(rtn < getPositiveInfinity<vec_t>() &&\n        rtn > getNegativeInfinity<vec_t>()));\n  return rtn;\n}\n\n\n\n#define PADDING 1024\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nvoid mergeType(const uint64_t size, const uint32_t runs) {\n  \n\n  std::vector<vec_t> hA (size + PADDING);\n  std::vector<vec_t> hB (size + PADDING);\n  std::vector<vec_t> hC (2*size + PADDING);\n\n  vec_t *dA;\n  vec_t *dB;\n  vec_t *dC;\n\n  hipMalloc((void**)&dA, (size + PADDING) * sizeof(vec_t));\n  hipMalloc((void**)&dB, (size + PADDING) * sizeof(vec_t));\n  hipMalloc((void**)&dC, (2*size + PADDING) * sizeof(vec_t));\n\n  uint32_t *dpi; \n\n  hipMalloc((void**)&dpi, (2 * (blocks + 1)) * sizeof(uint32_t));\n\n  uint32_t errors = 0;\n\n  double total_time = 0.0;\n\n  for(uint32_t r = 0; r < runs; r++) {\n\n    \n\n    for (uint64_t n = 0; n < size; n++) {\n       hA[n] = rand64<vec_t>();\n       hB[n] = rand64<vec_t>();\n    }\n\n    for (uint64_t n = size; n < size + PADDING; n++) {\n      hA[n] = getPositiveInfinity<vec_t>();\n      hB[n] = getPositiveInfinity<vec_t>();\n    }\n\n    std::sort(hA.begin(), hA.end());\n    std::sort(hB.begin(), hB.end());\n\n    hipMemcpy(dA, hA.data(), (size + PADDING) * sizeof(vec_t), hipMemcpyHostToDevice);\n    hipMemcpy(dB, hB.data(), (size + PADDING) * sizeof(vec_t), hipMemcpyHostToDevice);\n\n    hipDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    \n\n    hipLaunchKernelGGL(HIP_KERNEL_NAME(workloadDiagonals<vec_t>), blocks, 32, 0, 0, dA, size, dB, size, dpi);\n\n    \n\n    hipLaunchKernelGGL(HIP_KERNEL_NAME(mergeSinglePath<vec_t,false,false>), blocks, threads, 0, 0, dA, size, dB, size, dpi, dC, size * 2);\n\n    hipDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n  \n    \n\n    hipMemcpy(hC.data(), dC, size * sizeof(vec_t), hipMemcpyDeviceToHost);\n    for(uint32_t i = 1; i < size; i++) {\n      errors += hC[i] < hC[i-1];\n    }\n  }\n\n  hipFree(dA);\n  hipFree(dB);\n  hipFree(dC);\n  hipFree(dpi);\n\n  PV(errors); \n\n  printf(\"%s. \", errors ? \"FAIL\" : \"PASS\");\n\n  if (timing)\n    printf(\"Average kernel execution time: %f (us).\\n\", (total_time * 1e-3f) / runs);\n  else\n    printf(\"Warmup run\\n\");\n}\n\n\n\ntemplate<uint32_t blocks, uint32_t threads>\nvoid mergeAllTypes(const uint64_t size, const uint32_t runs) {\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"double\", size)    mergeType<double,   blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"double\", size)    mergeType<double,   blocks, threads, true>(size, runs); printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length of the arrays> <runs>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  \n\n  const uint64_t length = atol(argv[1]);\n\n  const uint32_t runs = atoi(argv[2]);\n\n  const int blocks = 112;\n  const int threads = 128;  \n\n\n  mergeAllTypes<blocks, threads>(length, runs);\n\n  return 0;\n}\n"}}
{"kernel_name": "merge", "kernel_api": "omp", "code": {"main.cpp": "#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <float.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <omp.h>\n#include \"kernels.h\"\n\n#define CSV 0\n#if(CSV)\n#define PS(X, S) std::cout << X << \", \" << S << \", \"; fflush(stdout);\n#define PV(X) std::cout << X << \", \"; fflush(stdout);\n#else\n#define PS(X, S) std::cout << X << \" \" << S <<\" :\\n\"; fflush(stdout);\n#define PV(X) std::cout << \"\\t\" << #X << \" \\t: \" << X << \"\\n\"; fflush(stdout);\n#endif\n\n\n\ntemplate<typename vec_t>\nvec_t rand64() {\n  vec_t rtn;\n  do {\n    uint32_t * rtn32 = (uint32_t *)&rtn;\n    rtn32[0] = rand();\n    if(sizeof(vec_t) > 4) rtn32[1] = rand();\n  } while(!(rtn < getPositiveInfinity<vec_t>() &&\n        rtn > getNegativeInfinity<vec_t>()));\n  return rtn;\n}\n\n\n\n#define PADDING 1024\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nvoid mergeType(const uint64_t size, const uint32_t runs) {\n  \n\n  std::vector<vec_t> hA (size + PADDING);\n  std::vector<vec_t> hB (size + PADDING);\n  std::vector<vec_t> hC (2*size + PADDING);\n  std::vector<uint32_t> hD (2*(blocks+1));\n\n  uint32_t errors = 0;\n\n  vec_t *dA = hA.data(); \n  vec_t *dB = hB.data(); \n  vec_t *dC = hC.data(); \n  uint32_t *dpi = hD.data(); \n\n\n  #pragma omp target data map(alloc: dC[0:2*size + PADDING], \\\n                                     dpi[0:2*(blocks+1)], \\\n                                     dA[0:size + PADDING], \\\n                                     dB[0:size + PADDING])\n  {\n    double total_time = 0.0;\n\n    for(uint32_t r = 0; r < runs; r++) {\n\n      \n\n      for (uint64_t n = 0; n < size; n++) {\n         hA[n] = rand64<vec_t>();\n         hB[n] = rand64<vec_t>();\n      }\n\n      for (uint64_t n = size; n < size + PADDING; n++) {\n        hA[n] = getPositiveInfinity<vec_t>();\n        hB[n] = getPositiveInfinity<vec_t>();\n      }\n\n      std::sort(hA.begin(), hA.end());\n      std::sort(hB.begin(), hB.end());\n\n      #pragma omp target update to (dA[0:size + PADDING])\n      #pragma omp target update to (dB[0:size + PADDING])\n\n      auto start = std::chrono::steady_clock::now();\n\n      \n\n      workloadDiagonals<vec_t>(blocks, dA, size, dB, size, dpi);\n\n      \n\n      mergeSinglePath<vec_t,false,false> (blocks, threads,\n          dA, size, dB, size, dpi, dC, size * 2);\n\n      auto end = std::chrono::steady_clock::now();\n      auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n      total_time += time;\n\n      \n\n      #pragma omp target update from (dC[0:size])\n      for(uint32_t i = 1; i < size; i++) {\n        errors += hC[i] < hC[i-1];\n      }\n    }\n\n    PV(errors); \n\n    printf(\"%s. \", errors ? \"FAIL\" : \"PASS\");\n\n    if (timing)\n      printf(\"Average kernel execution time: %f (us).\\n\", (total_time * 1e-3f) / runs);\n    else\n      printf(\"Warmup run\\n\");\n  }\n}\n\n\n\ntemplate<uint32_t blocks, uint32_t threads>\nvoid mergeAllTypes(const uint64_t size, const uint32_t runs) {\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"double\", size)    mergeType<double,   blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"double\", size)    mergeType<double,   blocks, threads, true>(size, runs); printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length of the arrays> <runs>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  \n\n  const uint64_t length = atol(argv[1]);\n\n  const uint32_t runs = atoi(argv[2]);\n\n  const int blocks = 112;\n  const int threads = 128;  \n\n\n  mergeAllTypes<blocks, threads>(length, runs);\n\n  return 0;\n}\n"}}
{"kernel_name": "merge", "kernel_api": "serial", "code": {"main.cpp": "#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <float.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include \"kernels.h\"\n\n#define CSV 0\n#if(CSV)\n#define PS(X, S) std::cout << X << \", \" << S << \", \"; fflush(stdout);\n#define PV(X) std::cout << X << \", \"; fflush(stdout);\n#else\n#define PS(X, S) std::cout << X << \" \" << S <<\" :\\n\"; fflush(stdout);\n#define PV(X) std::cout << \"\\t\" << #X << \" \\t: \" << X << \"\\n\"; fflush(stdout);\n#endif\n\n\n\ntemplate<typename vec_t>\nvec_t rand64() {\n  vec_t rtn;\n  do {\n    uint32_t * rtn32 = (uint32_t *)&rtn;\n    rtn32[0] = rand();\n    if(sizeof(vec_t) > 4) rtn32[1] = rand();\n  } while(!(rtn < getPositiveInfinity<vec_t>() &&\n        rtn > getNegativeInfinity<vec_t>()));\n  return rtn;\n}\n\n\n\n#define PADDING 1024\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nvoid mergeType(const uint64_t size, const uint32_t runs) {\n  \n\n  std::vector<vec_t> hA (size + PADDING);\n  std::vector<vec_t> hB (size + PADDING);\n  std::vector<vec_t> hC (2*size + PADDING);\n  std::vector<uint32_t> hD (2*(blocks+1));\n\n  uint32_t errors = 0;\n\n  vec_t *dA = hA.data(); \n  vec_t *dB = hB.data(); \n  vec_t *dC = hC.data(); \n  uint32_t *dpi = hD.data(); \n\n\n    {\n    double total_time = 0.0;\n\n    for(uint32_t r = 0; r < runs; r++) {\n\n      \n\n      for (uint64_t n = 0; n < size; n++) {\n         hA[n] = rand64<vec_t>();\n         hB[n] = rand64<vec_t>();\n      }\n\n      for (uint64_t n = size; n < size + PADDING; n++) {\n        hA[n] = getPositiveInfinity<vec_t>();\n        hB[n] = getPositiveInfinity<vec_t>();\n      }\n\n      std::sort(hA.begin(), hA.end());\n      std::sort(hB.begin(), hB.end());\n\n            \n      auto start = std::chrono::steady_clock::now();\n\n      \n\n      workloadDiagonals<vec_t>(blocks, dA, size, dB, size, dpi);\n\n      \n\n      mergeSinglePath<vec_t,false,false> (blocks, threads,\n          dA, size, dB, size, dpi, dC, size * 2);\n\n      auto end = std::chrono::steady_clock::now();\n      auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n      total_time += time;\n\n      \n\n            for(uint32_t i = 1; i < size; i++) {\n        errors += hC[i] < hC[i-1];\n      }\n    }\n\n    PV(errors); \n\n    printf(\"%s. \", errors ? \"FAIL\" : \"PASS\");\n\n    if (timing)\n      printf(\"Average kernel execution time: %f (us).\\n\", (total_time * 1e-3f) / runs);\n    else\n      printf(\"Warmup run\\n\");\n  }\n}\n\n\n\ntemplate<uint32_t blocks, uint32_t threads>\nvoid mergeAllTypes(const uint64_t size, const uint32_t runs) {\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, true>(size, runs); printf(\"\\n\");\n\n  PS(\"double\", size)    mergeType<double,   blocks, threads, false>(size, runs); printf(\"\\n\");\n  PS(\"double\", size)    mergeType<double,   blocks, threads, true>(size, runs); printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length of the arrays> <runs>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  \n\n  const uint64_t length = atol(argv[1]);\n\n  const uint32_t runs = atoi(argv[2]);\n\n  const int blocks = 112;\n  const int threads = 128;  \n\n\n  mergeAllTypes<blocks, threads>(length, runs);\n\n  return 0;\n}"}}
{"kernel_name": "merge", "kernel_api": "sycl", "code": {"main.cpp": "#include <stdio.h>\n#include <stdint.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <float.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <sycl/sycl.hpp>\n#include \"kernels.h\"\n\n#define CSV 0\n#if(CSV)\n#define PS(X, S) std::cout << X << \", \" << S << \", \"; fflush(stdout);\n#define PV(X) std::cout << X << \", \"; fflush(stdout);\n#else\n#define PS(X, S) std::cout << X << \" \" << S <<\" :\\n\"; fflush(stdout);\n#define PV(X) std::cout << \"\\t\" << #X << \" \\t: \" << X << \"\\n\"; fflush(stdout);\n#endif\n\n\n\ntemplate<typename vec_t>\nvec_t rand64() {\n  vec_t rtn;\n  do {\n    uint32_t * rtn32 = (uint32_t *)&rtn;\n    rtn32[0] = rand();\n    if(sizeof(vec_t) > 4) rtn32[1] = rand();\n  } while(!(rtn < getPositiveInfinity<vec_t>() &&\n        rtn > getNegativeInfinity<vec_t>()));\n  return rtn;\n}\n\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nclass divide;\n\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nclass merge;\n\n\n\n#define PADDING 1024\ntemplate<typename vec_t, uint32_t blocks, uint32_t threads, bool timing>\nvoid mergeType(sycl::queue &q, const uint64_t size, const uint32_t runs) {\n  \n\n  std::vector<vec_t> hA (size + PADDING);\n  std::vector<vec_t> hB (size + PADDING);\n  std::vector<vec_t> hC (2*size + PADDING);\n\n  vec_t *dA = sycl::malloc_device<vec_t>(size + PADDING, q);\n  vec_t *dB = sycl::malloc_device<vec_t>(size + PADDING, q);\n  vec_t *dC = sycl::malloc_device<vec_t>(2*size + PADDING, q);\n\n  \n\n  uint32_t *dpi = sycl::malloc_device<uint32_t>(2 * (blocks + 1), q);\n\n  uint32_t errors = 0;\n\n  double total_time = 0.0;\n\n  for(uint32_t r = 0; r < runs; r++) {\n\n    \n\n    for (uint64_t n = 0; n < size; n++) {\n       hA[n] = rand64<vec_t>();\n       hB[n] = rand64<vec_t>();\n    }\n\n    for (uint64_t n = size; n < size + PADDING; n++) {\n      hA[n] = getPositiveInfinity<vec_t>();\n      hB[n] = getPositiveInfinity<vec_t>();\n    }\n\n    std::sort(hA.begin(), hA.end());\n    std::sort(hB.begin(), hB.end());\n\n    q.memcpy(dA, hA.data(), (size + PADDING) * sizeof(vec_t));\n    q.memcpy(dB, hB.data(), (size + PADDING) * sizeof(vec_t));\n\n    \n\n    sycl::range<1> gws (blocks * 32);\n    sycl::range<1> lws (32);\n\n    q.wait();\n    auto start = std::chrono::steady_clock::now();\n\n    q.submit([&] (sycl::handler &cgh) {\n      sycl::local_accessor<int32_t, 0> xt(cgh);\n      sycl::local_accessor<int32_t, 0> yt(cgh);\n      sycl::local_accessor<int32_t, 0> xb(cgh);\n      sycl::local_accessor<int32_t, 0> yb(cgh);\n      sycl::local_accessor<int32_t, 0> found(cgh);\n      sycl::local_accessor<int32_t, 1> oneorzero(sycl::range<1>(32), cgh);\n      cgh.parallel_for<class divide<vec_t, blocks, threads, timing>>(\n        sycl::nd_range<1>(gws, lws), [=] (sycl::nd_item<1> item) {\n        workloadDiagonals<vec_t>(\n          item, xt, yt, xb, yb,\n          found, oneorzero.get_pointer(),\n          dA, size, dB, size, dpi);\n      });\n    });\n\n    \n\n    sycl::range<1> gws2 (blocks * threads);\n    sycl::range<1> lws2 (threads);\n    q.submit([&] (sycl::handler &cgh) {\n      sycl::local_accessor<vec_t, 1> A(sycl::range<1>((K+2)<<1), cgh);\n      sycl::local_accessor<uint32_t, 0> xt(cgh);\n      sycl::local_accessor<uint32_t, 0> yt(cgh);\n      sycl::local_accessor<uint32_t, 0> xs(cgh);\n      sycl::local_accessor<uint32_t, 0> ys(cgh);\n      cgh.parallel_for<class merge<vec_t, blocks, threads, timing>>(\n        sycl::nd_range<1>(gws2, lws2), [=] (sycl::nd_item<1> item) {\n        mergeSinglePath<vec_t,false,false> (\n          item, A.get_pointer(), xt, yt, xs, ys,\n          dA, size, dB, size,\n          dpi, dC, size * 2);\n      });\n    });\n\n    q.wait();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n\n    \n\n    q.memcpy(hC.data(), dC, size * sizeof(vec_t)).wait();\n\n    for(uint32_t i = 1; i < size; i++) {\n      errors += hC[i] < hC[i-1];\n    }\n  }\n\n  sycl::free(dA, q);\n  sycl::free(dB, q);\n  sycl::free(dC, q);\n  sycl::free(dpi, q);\n\n  PV(errors); \n\n  printf(\"%s. \", errors ? \"FAIL\" : \"PASS\");\n\n  if (timing)\n    printf(\"Average kernel execution time: %f (us).\\n\", (total_time * 1e-3f) / runs);\n  else\n    printf(\"Warmup run\\n\");\n}\n\n\n\ntemplate<uint32_t blocks, uint32_t threads>\nvoid mergeAllTypes(sycl::queue &q, const uint64_t size, const uint32_t runs) {\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, false>(q, size, runs); printf(\"\\n\");\n  PS(\"uint32_t\", size)  mergeType<uint32_t, blocks, threads, true>(q, size, runs); printf(\"\\n\");\n\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, false>(q, size, runs); printf(\"\\n\");\n  PS(\"float\",    size)  mergeType<float,    blocks, threads, true>(q, size, runs); printf(\"\\n\");\n\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, false>(q, size, runs); printf(\"\\n\");\n  PS(\"uint64_t\", size)  mergeType<uint64_t, blocks, threads, true>(q, size, runs); printf(\"\\n\");\n\n  PS(\"double\", size)    mergeType<double,   blocks, threads, false>(q, size, runs); printf(\"\\n\");\n  PS(\"double\", size)    mergeType<double,   blocks, threads, true>(q, size, runs); printf(\"\\n\");\n}\n\nint main(int argc, char *argv[]) {\n  if (argc != 3) {\n    printf(\"Usage: %s <length of the arrays> <runs>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  \n\n  const uint64_t length = atol(argv[1]);\n\n  const uint32_t runs = atoi(argv[2]);\n\n  const int blocks = 112;\n  const int threads = 128;  \n\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  mergeAllTypes<blocks, threads>(q, length, runs);\n\n  return 0;\n}\n\n"}}
{"kernel_name": "quicksort", "kernel_api": "cuda", "code": {"main.cu": "\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n#include <vector>\n#include <map>\n#include <cuda.h>\n\n#define RUN_CPU_SORTS\n\n\n\n#define gpucheck(ans) { gpuAssert((ans), __FILE__, __LINE__); }\ninline void gpuAssert(cudaError_t code, const char *file, int line, bool abort=true)\n{\n  if (code != cudaSuccess)\n  {\n    fprintf(stderr,\"GPUassert: %s %s %d\\n\", cudaGetErrorString(code), file, line);\n    if (abort) exit(code);\n  }\n}\n\n\n\ntypedef unsigned int uint;\n#ifdef min\n#undef min\n#endif\n#ifdef max\n#undef max\n#endif\n\n\n\n\n\ndouble seconds() {\n  struct timespec now;\n  clock_gettime(CLOCK_MONOTONIC, &now);\n  return now.tv_sec + now.tv_nsec / 1000000000.0;\n}\n\n\nbool parseArgs(int argc, char** argv, unsigned int* test_iterations, unsigned int* widthReSz, unsigned int* heightReSz)\n{\n  const char sUsageString[512] = \"Usage: Quicksort [num test iterations] [SurfWidth(^2 only)] [SurfHeight(^2 only)]\";\n\n  if (argc != 4)\n  {\n    printf(sUsageString);\n    return false;\n  }\n  else\n  {\n    *test_iterations  = atoi (argv[1]);\n    *widthReSz  = atoi (argv[2]);\n    *heightReSz  = atoi (argv[3]);\n    return true;\n  }\n}\n\n\n#include \"Quicksort.h\"\n#include \"QuicksortKernels.cuh\"\n\n\ntemplate <class T>\nT* partition(T* left, T* right, T pivot) {\n  \n\n  T temp = *right;\n  *right = pivot;\n  *left = temp;\n\n  T* store = left;\n\n  for(T* p = left; p != right; p++) {\n    if (*p < pivot) {\n      temp = *store;\n      *store = *p;\n      *p = temp;\n      store++;\n    }\n  }\n\n  temp = *store;\n  *store = pivot;\n  *right = temp;\n\n  return store;\n}\n\n  template <class T>\nvoid quicksort(T* data, int left, int right)\n{\n  T* store = partition(data + left, data + right, data[left]);\n  int nright = store-data;\n  int nleft = nright+1;\n\n  if (left < nright) {\n    if (nright - left > 32) {\n      quicksort(data, left, nright);\n    } else\n      std::sort(data + left, data + nright + 1);\n  }\n\n  if (nleft < right) {\n    if (right - nleft > 32)  {\n      quicksort(data, nleft, right);\n    } else {\n      std::sort(data + nleft, data + right + 1);\n    }\n  }\n}\n\ntemplate <class T>\nvoid gqsort(T *db,\n    T *dnb,\n    std::vector<block_record<T>>& blocks,\n    std::vector<parent_record>& parents,\n    std::vector<work_record<T>>& news,\n    bool reset) {\n\n  news.resize(blocks.size()*2);\n\n#ifdef GET_DETAILED_PERFORMANCE\n  static double absoluteTotal = 0.0;\n  static uint count = 0;\n\n  if (reset) {\n    absoluteTotal = 0.0;\n    count = 0;\n  }\n\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n\n  block_record<T> *blocksb;\n  parent_record *parentsb;\n  work_record<T> *newsb;\n  gpucheck(cudaMalloc((void**)&blocksb, sizeof(block_record<T>)*blocks.size()));\n  gpucheck(cudaMalloc((void**)&parentsb, sizeof(parent_record)*parents.size()));\n  gpucheck(cudaMalloc((void**)&newsb, sizeof(work_record<T>)*news.size()));\n  gpucheck(cudaMemcpy(blocksb, blocks.data(), sizeof(block_record<T>)*blocks.size(), cudaMemcpyHostToDevice));\n  gpucheck(cudaMemcpy(parentsb, parents.data(), sizeof(parent_record)*parents.size(), cudaMemcpyHostToDevice));\n  gpucheck(cudaMemcpy(newsb, news.data(), sizeof(work_record<T>)*news.size(), cudaMemcpyHostToDevice));\n\n  gqsort_kernel<<<dim3(blocks.size()), dim3(GQSORT_LOCAL_WORKGROUP_SIZE)>>>(\n      db, dnb, blocksb, parentsb, newsb);\n\n  gpucheck( cudaPeekAtLastError() );\n  gpucheck( cudaDeviceSynchronize() );\n  gpucheck(cudaMemcpy(news.data(), newsb, sizeof(work_record<T>)*news.size(), cudaMemcpyDeviceToHost));\n\n  gpucheck(cudaFree(blocksb));\n  gpucheck(cudaFree(parentsb));\n  gpucheck(cudaFree(newsb));\n\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  absoluteTotal += totalTime;\n  std::cout << ++count << \": gqsort time \" << absoluteTotal * 1000 << \" ms\" << std::endl;\n#endif\n\n#ifdef DEBUG\n  printf(\"\\noutput news\\n\");\n  for (int i = 0; i < news.size(); i++) {\n    printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n  }\n#endif\n}\n\ntemplate <class T>\nvoid lqsort(T *db, T *dnb, std::vector<work_record<T>>& done) {\n\n#ifdef GET_DETAILED_PERFORMANCE\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n  work_record<T>* doneb;\n  \n\n\n  gpucheck(cudaMalloc((void**)&doneb, sizeof(work_record<T>)*done.size()));\n  gpucheck(cudaMemcpy(doneb, done.data(), sizeof(work_record<T>)*done.size(), cudaMemcpyHostToDevice));\n\n  lqsort_kernel<<<dim3(done.size()), dim3(LQSORT_LOCAL_WORKGROUP_SIZE)>>>(db, dnb, doneb);\n  gpucheck( cudaPeekAtLastError() );\n  gpucheck( cudaDeviceSynchronize() );\n\n  \n\n  gpucheck(cudaFree(doneb));\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  std::cout << \"lqsort time \" << totalTime * 1000 << \" ms\" << std::endl;\n#endif\n}\n\nsize_t optp(size_t s, double k, size_t m) {\n  return (size_t)pow(2, floor(log(s*k + m)/log(2.0) + 0.5));\n}\n\ntemplate <class T>\nvoid GPUQSort(size_t size, T* d, T* dn)  {\n\n  \n\n  T *db, *dnb;\n  cudaMalloc((void**)&db, ((sizeof(T)*size)/64 + 1)*64);\n  cudaMemcpy(db, d, ((sizeof(T)*size)/64 + 1)*64, cudaMemcpyHostToDevice);\n  cudaMalloc((void**)&dnb, ((sizeof(T)*size)/64 + 1)*64);\n  cudaMemcpy(dnb, dn, ((sizeof(T)*size)/64 + 1)*64, cudaMemcpyHostToDevice);\n\n  const size_t MAXSEQ = optp(size, 0.00009516, 203);\n  const size_t MAX_SIZE = 12*std::max(MAXSEQ, (size_t)QUICKSORT_BLOCK_SIZE);\n  \n\n  uint startpivot = median_host(d[0], d[size/2], d[size-1]);\n  std::vector<work_record<T>> work, done, news;\n  work.reserve(MAX_SIZE);\n  done.reserve(MAX_SIZE);\n  news.reserve(MAX_SIZE);\n  std::vector<parent_record> parent_records;\n  parent_records.reserve(MAX_SIZE);\n  std::vector<block_record<T>> blocks;\n  blocks.reserve(MAX_SIZE);\n\n  work.push_back(work_record<T>(0, size, startpivot, 1));\n\n  bool reset = true;\n\n  while(!work.empty() \n) {\n    size_t blocksize = 0;\n\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      blocksize += std::max((it->end - it->start)/MAXSEQ, (size_t)1);\n    }\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      uint start = it->start;\n      uint end   = it->end;\n      uint pivot = it->pivot;\n      uint direction = it->direction;\n      uint blockcount = (end - start + blocksize - 1)/blocksize;\n      parent_record prnt(start, end, start, end, blockcount-1);\n      parent_records.push_back(prnt);\n\n      for(uint i = 0; i < blockcount - 1; i++) {\n        uint bstart = start + blocksize*i;\n        block_record<T> br(bstart, bstart+blocksize, pivot, direction, parent_records.size()-1);\n        blocks.push_back(br);\n      }\n      block_record<T> br(start + blocksize*(blockcount - 1), end, pivot, direction, parent_records.size()-1);\n      blocks.push_back(br);\n    }\n    \n\n\n    gqsort<T>(db, dnb, blocks, parent_records, news, reset);\n\n    reset = false;\n    work.clear();\n    parent_records.clear();\n    blocks.clear();\n    for(auto it = news.begin(); it != news.end(); ++it) {\n      if (it->direction != EMPTY_RECORD) {\n        if (it->end - it->start <= QUICKSORT_BLOCK_SIZE \n) {\n          if (it->end - it->start > 0)\n            done.push_back(*it);\n        } else {\n          work.push_back(*it);\n        }\n      }\n    }\n    news.clear();\n  }\n  for(auto it = work.begin(); it != work.end(); ++it) {\n    if (it->end - it->start > 0)\n      done.push_back(*it);\n  }\n\n  if (done.size() > 0)\n    lqsort<T>(db, dnb, done);\n\n  cudaMemcpy(d, db, ((sizeof(T)*size)/64 + 1)*64, cudaMemcpyDeviceToHost);\n  cudaFree(db);\n  cudaFree(dnb);\n}\n\ntemplate <class T>\nint test(uint arraySize, unsigned int  NUM_ITERATIONS,\n         const std::string& type_name)\n{\n  double totalTime, quickSortTime, stdSortTime;\n  double beginClock, endClock;\n\n  printf(\"\\n\\n\\n--------------------------------------------------------------------\\n\");\n  printf(\"Allocating array size of %d (data type: %s)\\n\", arraySize, type_name.c_str());\n  T* pArray = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  T* pArrayCopy = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  std::generate(pArray, pArray + arraySize, [](){static T i = 0; return ++i; });\n  std::shuffle(pArray, pArray + arraySize, std::mt19937(19937));\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Sorting the regular way...\" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  std::sort(pArrayCopy, pArrayCopy + arraySize);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  stdSortTime = totalTime;\n\n  std::cout << \"quicksort on the cpu: \" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  quicksort(pArrayCopy, 0, arraySize-1);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  quickSortTime = totalTime;\n#ifdef TRUST_BUT_VERIFY\n  {\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArrayCopy);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArrayCopy[i]) {\n          \n\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      char y;\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      std::cin >> y;\n    }\n  }\n#endif\n#endif \n\n\n  std::cout << \"Sorting with GPU quicksort: \" << std::endl;\n  std::vector<uint> original(arraySize);\n  std::copy(pArray, pArray + arraySize, original.begin());\n\n  std::vector<double> times;\n  times.resize(NUM_ITERATIONS);\n  double AverageTime = 0.0;\n  uint num_failures = 0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++) {\n    std::copy(original.begin(), original.end(), pArray);\n    std::vector<uint> seqs;\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    beginClock = seconds();\n    GPUQSort(arraySize, pArray, pArrayCopy);\n    endClock = seconds();\n    totalTime = endClock - beginClock;\n    std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n    times[k] = totalTime;\n    AverageTime += totalTime;\n#ifdef TRUST_BUT_VERIFY\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArray);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArray[i]) {\n          std:: cout << \"discrepancy at \" << i << \" \" << pArray[i] << \" expected \" << verify[i] << std::endl;\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      num_failures ++;\n    }\n#endif\n  }\n  std::cout << \" Number of failures: \" << num_failures << \" out of \" << NUM_ITERATIONS << std::endl;\n  AverageTime = AverageTime/NUM_ITERATIONS;\n  std::cout << \"Average Time: \" << AverageTime * 1000 << \" ms\" << std::endl;\n  double stdDev = 0.0, minTime = 1000000.0, maxTime = 0.0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++)\n  {\n    stdDev += (AverageTime - times[k])*(AverageTime - times[k]);\n    minTime = std::min(minTime, times[k]);\n    maxTime = std::max(maxTime, times[k]);\n  }\n\n  if (NUM_ITERATIONS > 1) {\n    stdDev = sqrt(stdDev/(NUM_ITERATIONS - 1));\n    std::cout << \"Standard Deviation: \" << stdDev * 1000 << std::endl;\n    std::cout << \"%error (3*stdDev)/Average: \" << 3*stdDev / AverageTime * 100 << \"%\" << std::endl;\n    std::cout << \"min time: \" << minTime * 1000 << \" ms\" << std::endl;\n    std::cout << \"max time: \" << maxTime * 1000 << \" ms\" << std::endl;\n  }\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Average speedup over CPU quicksort: \" << quickSortTime/AverageTime << std::endl;\n  std::cout << \"Average speedup over CPU std::sort: \" << stdSortTime/AverageTime << std::endl;\n#endif \n\n\n  printf(\"-------done--------------------------------------------------------\\n\");\n  free(pArray);\n  free(pArrayCopy);\n\n  return 0;\n}\n\n\nint main(int argc, char** argv)\n{\n  unsigned int  NUM_ITERATIONS;\n  uint      heightReSz, widthReSz;\n\n\n  bool success = parseArgs (argc, argv, &NUM_ITERATIONS, &widthReSz, &heightReSz);\n  if (!success) return -1;\n  uint arraySize = widthReSz*heightReSz;\n  test<uint>(arraySize, NUM_ITERATIONS, \"uint\");\n  test<float>(arraySize, NUM_ITERATIONS, \"float\");\n  test<double>(arraySize, NUM_ITERATIONS, \"double\");\n  return 0;\n}\n\n\n\n"}}
{"kernel_name": "quicksort", "kernel_api": "hip", "code": {"main.cu": "\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n#include <vector>\n#include <map>\n#include <hip/hip_runtime.h>\n\n#define RUN_CPU_SORTS\n\n\n\n#define gpucheck(ans) { gpuAssert((ans), __FILE__, __LINE__); }\ninline void gpuAssert(hipError_t code, const char *file, int line, bool abort=true)\n{\n  if (code != hipSuccess)\n  {\n    fprintf(stderr,\"GPUassert: %s %s %d\\n\", hipGetErrorString(code), file, line);\n    if (abort) exit(code);\n  }\n}\n\n\n\ntypedef unsigned int uint;\n#ifdef min\n#undef min\n#endif\n#ifdef max\n#undef max\n#endif\n\n\n\n\n\ndouble seconds() {\n  struct timespec now;\n  clock_gettime(CLOCK_MONOTONIC, &now);\n  return now.tv_sec + now.tv_nsec / 1000000000.0;\n}\n\n\nbool parseArgs(int argc, char** argv, unsigned int* test_iterations, unsigned int* widthReSz, unsigned int* heightReSz)\n{\n  const char sUsageString[512] = \"Usage: Quicksort [num test iterations] [SurfWidth(^2 only)] [SurfHeight(^2 only)]\";\n\n  if (argc != 4)\n  {\n    printf(sUsageString);\n    return false;\n  }\n  else\n  {\n    *test_iterations  = atoi (argv[1]);\n    *widthReSz  = atoi (argv[2]);\n    *heightReSz  = atoi (argv[3]);\n    return true;\n  }\n}\n\n\n#include \"Quicksort.h\"\n#include \"QuicksortKernels.cuh\"\n\n\ntemplate <class T>\nT* partition(T* left, T* right, T pivot) {\n  \n\n  T temp = *right;\n  *right = pivot;\n  *left = temp;\n\n  T* store = left;\n\n  for(T* p = left; p != right; p++) {\n    if (*p < pivot) {\n      temp = *store;\n      *store = *p;\n      *p = temp;\n      store++;\n    }\n  }\n\n  temp = *store;\n  *store = pivot;\n  *right = temp;\n\n  return store;\n}\n\n  template <class T>\nvoid quicksort(T* data, int left, int right)\n{\n  T* store = partition(data + left, data + right, data[left]);\n  int nright = store-data;\n  int nleft = nright+1;\n\n  if (left < nright) {\n    if (nright - left > 32) {\n      quicksort(data, left, nright);\n    } else\n      std::sort(data + left, data + nright + 1);\n  }\n\n  if (nleft < right) {\n    if (right - nleft > 32)  {\n      quicksort(data, nleft, right);\n    } else {\n      std::sort(data + nleft, data + right + 1);\n    }\n  }\n}\n\ntemplate <class T>\nvoid gqsort(T *db,\n    T *dnb,\n    std::vector<block_record<T>>& blocks,\n    std::vector<parent_record>& parents,\n    std::vector<work_record<T>>& news,\n    bool reset) {\n\n  news.resize(blocks.size()*2);\n\n#ifdef GET_DETAILED_PERFORMANCE\n  static double absoluteTotal = 0.0;\n  static uint count = 0;\n\n  if (reset) {\n    absoluteTotal = 0.0;\n    count = 0;\n  }\n\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n\n  block_record<T> *blocksb;\n  parent_record *parentsb;\n  work_record<T> *newsb;\n  gpucheck(hipMalloc((void**)&blocksb, sizeof(block_record<T>)*blocks.size()));\n  gpucheck(hipMalloc((void**)&parentsb, sizeof(parent_record)*parents.size()));\n  gpucheck(hipMalloc((void**)&newsb, sizeof(work_record<T>)*news.size()));\n  gpucheck(hipMemcpy(blocksb, blocks.data(), sizeof(block_record<T>)*blocks.size(), hipMemcpyHostToDevice));\n  gpucheck(hipMemcpy(parentsb, parents.data(), sizeof(parent_record)*parents.size(), hipMemcpyHostToDevice));\n  gpucheck(hipMemcpy(newsb, news.data(), sizeof(work_record<T>)*news.size(), hipMemcpyHostToDevice));\n\n  hipLaunchKernelGGL(gqsort_kernel, dim3(blocks.size()), dim3(GQSORT_LOCAL_WORKGROUP_SIZE), 0, 0,\n      db, dnb, blocksb, parentsb, newsb);\n\n  gpucheck( hipPeekAtLastError() );\n  gpucheck( hipDeviceSynchronize() );\n  gpucheck(hipMemcpy(news.data(), newsb, sizeof(work_record<T>)*news.size(), hipMemcpyDeviceToHost));\n\n  gpucheck(hipFree(blocksb));\n  gpucheck(hipFree(parentsb));\n  gpucheck(hipFree(newsb));\n\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  absoluteTotal += totalTime;\n  std::cout << ++count << \": gqsort time \" << absoluteTotal * 1000 << \" ms\" << std::endl;\n#endif\n\n#ifdef DEBUG\n  printf(\"\\noutput news\\n\");\n  for (int i = 0; i < news.size(); i++) {\n    printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n  }\n#endif\n}\n\ntemplate <class T>\nvoid lqsort(T *db, T *dnb, std::vector<work_record<T>>& done) {\n\n#ifdef GET_DETAILED_PERFORMANCE\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n  work_record<T>* doneb;\n  \n\n\n  gpucheck(hipMalloc((void**)&doneb, sizeof(work_record<T>)*done.size()));\n  gpucheck(hipMemcpy(doneb, done.data(), sizeof(work_record<T>)*done.size(), hipMemcpyHostToDevice));\n\n  hipLaunchKernelGGL(lqsort_kernel, dim3(done.size()), dim3(LQSORT_LOCAL_WORKGROUP_SIZE), 0, 0, db, dnb, doneb);\n  gpucheck( hipPeekAtLastError() );\n  gpucheck( hipDeviceSynchronize() );\n\n  \n\n  gpucheck(hipFree(doneb));\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  std::cout << \"lqsort time \" << totalTime * 1000 << \" ms\" << std::endl;\n#endif\n}\n\nsize_t optp(size_t s, double k, size_t m) {\n  return (size_t)pow(2, floor(log(s*k + m)/log(2.0) + 0.5));\n}\n\ntemplate <class T>\nvoid GPUQSort(size_t size, T* d, T* dn)  {\n\n  \n\n  T *db, *dnb;\n  hipMalloc((void**)&db, ((sizeof(T)*size)/64 + 1)*64);\n  hipMemcpy(db, d, ((sizeof(T)*size)/64 + 1)*64, hipMemcpyHostToDevice);\n  hipMalloc((void**)&dnb, ((sizeof(T)*size)/64 + 1)*64);\n  hipMemcpy(dnb, dn, ((sizeof(T)*size)/64 + 1)*64, hipMemcpyHostToDevice);\n\n  const size_t MAXSEQ = optp(size, 0.00009516, 203);\n  const size_t MAX_SIZE = 12*std::max(MAXSEQ, (size_t)QUICKSORT_BLOCK_SIZE);\n  \n\n  uint startpivot = median_host(d[0], d[size/2], d[size-1]);\n  std::vector<work_record<T>> work, done, news;\n  work.reserve(MAX_SIZE);\n  done.reserve(MAX_SIZE);\n  news.reserve(MAX_SIZE);\n  std::vector<parent_record> parent_records;\n  parent_records.reserve(MAX_SIZE);\n  std::vector<block_record<T>> blocks;\n  blocks.reserve(MAX_SIZE);\n\n  work.push_back(work_record<T>(0, size, startpivot, 1));\n\n  bool reset = true;\n\n  while(!work.empty() \n) {\n    size_t blocksize = 0;\n\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      blocksize += std::max((it->end - it->start)/MAXSEQ, (size_t)1);\n    }\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      uint start = it->start;\n      uint end   = it->end;\n      uint pivot = it->pivot;\n      uint direction = it->direction;\n      uint blockcount = (end - start + blocksize - 1)/blocksize;\n      parent_record prnt(start, end, start, end, blockcount-1);\n      parent_records.push_back(prnt);\n\n      for(uint i = 0; i < blockcount - 1; i++) {\n        uint bstart = start + blocksize*i;\n        block_record<T> br(bstart, bstart+blocksize, pivot, direction, parent_records.size()-1);\n        blocks.push_back(br);\n      }\n      block_record<T> br(start + blocksize*(blockcount - 1), end, pivot, direction, parent_records.size()-1);\n      blocks.push_back(br);\n    }\n    \n\n\n    gqsort<T>(db, dnb, blocks, parent_records, news, reset);\n\n    reset = false;\n    work.clear();\n    parent_records.clear();\n    blocks.clear();\n    for(auto it = news.begin(); it != news.end(); ++it) {\n      if (it->direction != EMPTY_RECORD) {\n        if (it->end - it->start <= QUICKSORT_BLOCK_SIZE \n) {\n          if (it->end - it->start > 0)\n            done.push_back(*it);\n        } else {\n          work.push_back(*it);\n        }\n      }\n    }\n    news.clear();\n  }\n  for(auto it = work.begin(); it != work.end(); ++it) {\n    if (it->end - it->start > 0)\n      done.push_back(*it);\n  }\n\n  lqsort<T>(db, dnb, done);\n\n  hipMemcpy(d, db, ((sizeof(T)*size)/64 + 1)*64, hipMemcpyDeviceToHost);\n  hipFree(db);\n  hipFree(dnb);\n}\n\ntemplate <class T>\nint test(uint arraySize, unsigned int  NUM_ITERATIONS,\n\t const std::string& type_name)\n{\n  double totalTime, quickSortTime, stdSortTime;\n  double beginClock, endClock;\n\n  printf(\"\\n\\n\\n--------------------------------------------------------------------\\n\");\n  printf(\"Allocating array size of %d (data type: %s)\\n\", arraySize, type_name.c_str());\n  T* pArray = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  T* pArrayCopy = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  std::generate(pArray, pArray + arraySize, [](){static T i = 0; return ++i; });\n  std::shuffle(pArray, pArray + arraySize, std::mt19937(19937));\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Sorting the regular way...\" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  std::sort(pArrayCopy, pArrayCopy + arraySize);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  stdSortTime = totalTime;\n\n  std::cout << \"quicksort on the cpu: \" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  quicksort(pArrayCopy, 0, arraySize-1);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  quickSortTime = totalTime;\n#ifdef TRUST_BUT_VERIFY\n  {\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArrayCopy);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArrayCopy[i]) {\n          \n\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      char y;\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      std::cin >> y;\n    }\n  }\n#endif\n#endif \n\n\n  std::cout << \"Sorting with GPU quicksort: \" << std::endl;\n  std::vector<uint> original(arraySize);\n  std::copy(pArray, pArray + arraySize, original.begin());\n\n  std::vector<double> times;\n  times.resize(NUM_ITERATIONS);\n  double AverageTime = 0.0;\n  uint num_failures = 0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++) {\n    std::copy(original.begin(), original.end(), pArray);\n    std::vector<uint> seqs;\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    beginClock = seconds();\n    GPUQSort(arraySize, pArray, pArrayCopy);\n    endClock = seconds();\n    totalTime = endClock - beginClock;\n    std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n    times[k] = totalTime;\n    AverageTime += totalTime;\n#ifdef TRUST_BUT_VERIFY\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArray);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArray[i]) {\n          std:: cout << \"discrepancy at \" << i << \" \" << pArray[i] << \" expected \" << verify[i] << std::endl;\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      num_failures ++;\n    }\n#endif\n  }\n  std::cout << \" Number of failures: \" << num_failures << \" out of \" << NUM_ITERATIONS << std::endl;\n  AverageTime = AverageTime/NUM_ITERATIONS;\n  std::cout << \"Average Time: \" << AverageTime * 1000 << \" ms\" << std::endl;\n  double stdDev = 0.0, minTime = 1000000.0, maxTime = 0.0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++)\n  {\n    stdDev += (AverageTime - times[k])*(AverageTime - times[k]);\n    minTime = std::min(minTime, times[k]);\n    maxTime = std::max(maxTime, times[k]);\n  }\n\n  if (NUM_ITERATIONS > 1) {\n    stdDev = sqrt(stdDev/(NUM_ITERATIONS - 1));\n    std::cout << \"Standard Deviation: \" << stdDev * 1000 << std::endl;\n    std::cout << \"%error (3*stdDev)/Average: \" << 3*stdDev / AverageTime * 100 << \"%\" << std::endl;\n    std::cout << \"min time: \" << minTime * 1000 << \" ms\" << std::endl;\n    std::cout << \"max time: \" << maxTime * 1000 << \" ms\" << std::endl;\n  }\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Average speedup over CPU quicksort: \" << quickSortTime/AverageTime << std::endl;\n  std::cout << \"Average speedup over CPU std::sort: \" << stdSortTime/AverageTime << std::endl;\n#endif \n\n\n  printf(\"-------done--------------------------------------------------------\\n\");\n  free(pArray);\n  free(pArrayCopy);\n\n  return 0;\n}\n\n\nint main(int argc, char** argv)\n{\n  unsigned int  NUM_ITERATIONS;\n  uint      heightReSz, widthReSz;\n\n\n  bool success = parseArgs (argc, argv, &NUM_ITERATIONS, &widthReSz, &heightReSz);\n  if (!success) return -1;\n  uint arraySize = widthReSz*heightReSz;\n  test<uint>(arraySize, NUM_ITERATIONS, \"uint\");\n  test<float>(arraySize, NUM_ITERATIONS, \"float\");\n  test<double>(arraySize, NUM_ITERATIONS, \"double\");\n  return 0;\n}\n\n\n\n"}}
{"kernel_name": "quicksort", "kernel_api": "omp", "code": {"main.cpp": "\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\n#include <limits.h>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n#include <vector>\n#include <map>\n\n\n\n\n\n\n\n#include \"QuicksortKernels.h\"\n\n\n\ntypedef unsigned int uint;\n#ifdef min\n#undef min\n#endif\n#ifdef max\n#undef max\n#endif\n\n\n\n\n\ndouble seconds() {\n  struct timespec now;\n  clock_gettime(CLOCK_MONOTONIC, &now);\n  return now.tv_sec + now.tv_nsec / 1000000000.0;\n}\n\n\nbool parseArgs(int argc, char** argv, unsigned int* test_iterations, unsigned int* widthReSz, unsigned int* heightReSz)\n{\n  const char sUsageString[512] = \"Usage: Quicksort [num test iterations] [SurfWidth(^2 only)] [SurfHeight(^2 only)]\";\n\n  if (argc != 4)\n  {\n    printf(sUsageString);\n    return false;\n  }\n  else\n  {\n    *test_iterations  = atoi (argv[1]);\n    *widthReSz  = atoi (argv[2]);\n    *heightReSz  = atoi (argv[3]);\n    return true;\n  }\n}\n\n\n#include \"Quicksort.h\"\n#include \"QuicksortKernels.h\"\n\n\ntemplate <class T>\nT* partition(T* left, T* right, T pivot) {\n  \n\n  T temp = *right;\n  *right = pivot;\n  *left = temp;\n\n  T* store = left;\n\n  for(T* p = left; p != right; p++) {\n    if (*p < pivot) {\n      temp = *store;\n      *store = *p;\n      *p = temp;\n      store++;\n    }\n  }\n\n  temp = *store;\n  *store = pivot;\n  *right = temp;\n\n  return store;\n}\n\n  template <class T>\nvoid quicksort(T* data, int left, int right)\n{\n  T* store = partition(data + left, data + right, data[left]);\n  int nright = store-data;\n  int nleft = nright+1;\n\n  if (left < nright) {\n    if (nright - left > 32) {\n      quicksort(data, left, nright);\n    } else\n      std::sort(data + left, data + nright + 1);\n  }\n\n  if (nleft < right) {\n    if (right - nleft > 32)  {\n      quicksort(data, nleft, right);\n    } else {\n      std::sort(data + nleft, data + right + 1);\n    }\n  }\n}\n\nsize_t optp(size_t s, double k, size_t m) {\n  return (size_t)pow(2, floor(log(s*k + m)/log(2.0) + 0.5));\n}\n\ntemplate <class T>\nvoid GPUQSort(size_t size, T* d, T* dn)  {\n\n  \n\n#pragma omp target data map (tofrom: d[0:(size/64+1)*64]) map(to: dn[0:(size/64+1)*64])\n  {\n    const size_t MAXSEQ = optp(size, 0.00009516, 203);\n    const size_t MAX_SIZE = 12*std::max(MAXSEQ, (size_t)QUICKSORT_BLOCK_SIZE);\n    \n\n    uint startpivot = median_host(d[0], d[size/2], d[size-1]);\n    std::vector<work_record<T>> work, done, news;\n    work.reserve(MAX_SIZE);\n    done.reserve(MAX_SIZE);\n    news.reserve(MAX_SIZE);\n    std::vector<parent_record> parent_records;\n    parent_records.reserve(MAX_SIZE);\n    std::vector<block_record<T>> blocks;\n    blocks.reserve(MAX_SIZE);\n\n    work.push_back(work_record<T>(0, size, startpivot, 1));\n\n    bool reset = true;\n\n    while(!work.empty() \n) {\n      size_t blocksize = 0;\n\n      for(auto it = work.begin(); it != work.end(); ++it) {\n        blocksize += std::max((it->end - it->start)/MAXSEQ, (size_t)1);\n      }\n      for(auto it = work.begin(); it != work.end(); ++it) {\n        uint start = it->start;\n        uint end   = it->end;\n        uint pivot = it->pivot;\n        uint direction = it->direction;\n        uint blockcount = (end - start + blocksize - 1)/blocksize;\n        parent_record prnt(start, end, start, end, blockcount-1);\n        parent_records.push_back(prnt);\n\n        for(uint i = 0; i < blockcount - 1; i++) {\n          uint bstart = start + blocksize*i;\n          block_record<T> br(bstart, bstart+blocksize, pivot, direction, parent_records.size()-1);\n          blocks.push_back(br);\n        }\n        block_record<T> br(start + blocksize*(blockcount - 1), end, pivot, direction, parent_records.size()-1);\n        blocks.push_back(br);\n      }\n\n      \n\n\n      news.resize(blocks.size()*2);\n\n#ifdef DEBUG\n      printf(\"blocks\\n\");\n      for (int i = 0; i < blocks.size(); i++) {\n        printf(\"%u %u %u %u %u\\n\", blocks[i].start, blocks[i].end, blocks[i].pivot, blocks[i].direction, blocks[i].parent);\n      }\n      printf(\"parents\\n\");\n      for (int i = 0; i < parent_records.size(); i++) {\n        printf(\"%u %u %u %u %u\\n\", parent_records[i].sstart, parent_records[i].send, parent_records[i].oldstart, parent_records[i].oldend, parent_records[i].blockcount);\n      }\n      printf(\"input news\\n\");\n      for (int i = 0; i < news.size(); i++) {\n        printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n      }\n#endif\n\n#ifdef GET_DETAILED_PERFORMANCE\n      static double absoluteTotal = 0.0;\n      static uint count = 0;\n\n      if (reset) {\n        absoluteTotal = 0.0;\n        count = 0;\n      }\n\n      double beginClock, endClock;\n      beginClock = seconds();\n#endif\n\n      block_record<T> *blocksb = blocks.data();\n      parent_record *parentsb = parent_records.data();\n      work_record<T> *result = news.data();\n\n      \n\n\n      int blocks_size = blocks.size();\n\n#pragma omp target data map(to: blocksb[0:blocks_size], \\\n    parentsb[0:parent_records.size()]) \\\n      map(tofrom: result[0:news.size()])\n      {\n#include \"gqsort_kernel.h\"\n      }\n\n\n#ifdef GET_DETAILED_PERFORMANCE\n      endClock = seconds();\n      double totalTime = endClock - beginClock;\n      absoluteTotal += totalTime;\n      std::cout << ++count << \": gqsort time \" << absoluteTotal * 1000 << \" ms\" << std::endl;\n#endif\n\n#ifdef DEBUG\n      printf(\"\\noutput news\\n\");\n      for (int i = 0; i < news.size(); i++) {\n        printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n      }\n#endif\n\n      reset = false;\n      work.clear();\n      parent_records.clear();\n      blocks.clear();\n      for(auto it = news.begin(); it != news.end(); ++it) {\n        if (it->direction != EMPTY_RECORD) {\n          if (it->end - it->start <= QUICKSORT_BLOCK_SIZE \n) {\n            if (it->end - it->start > 0)\n              done.push_back(*it);\n          } else {\n            work.push_back(*it);\n          }\n        }\n      }\n      news.clear();\n    } \n\n\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      if (it->end - it->start > 0)\n        done.push_back(*it);\n    }\n\n    work_record<T>* seqs = done.data();\n    uint done_size = done.size();\n\n#ifdef GET_DETAILED_PERFORMANCE\n    double beginClock, endClock;\n    beginClock = seconds();\n#endif\n    \n\n#pragma omp target data map(to: seqs[0:done_size])\n    {\n#include \"lqsort_kernel.h\"\n    }\n#ifdef GET_DETAILED_PERFORMANCE\n    endClock = seconds();\n    double totalTime = endClock - beginClock;\n    std::cout << \"lqsort time \" << totalTime * 1000 << \" ms\" << std::endl;\n#endif\n\n  } \n\n}\n\ntemplate <class T>\nint test(uint arraySize, unsigned int  NUM_ITERATIONS,\n         const std::string& type_name)\n{\n  double totalTime, quickSortTime, stdSortTime;\n  double beginClock, endClock;\n\n  printf(\"\\n\\n\\n--------------------------------------------------------------------\\n\");\n  printf(\"Allocating array size of %d (data type: %s)\\n\", arraySize, type_name.c_str());\n  T* pArray = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  T* pArrayCopy = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n\n  \n\n  std::generate(pArray, pArray + arraySize, [](){static uint i = 0; return ++i; });\n  std::shuffle(pArray, pArray + arraySize, std::mt19937(19937));\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Sorting the regular way...\" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  std::sort(pArrayCopy, pArrayCopy + arraySize);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  stdSortTime = totalTime;\n\n  std::cout << \"Sorting with parallel quicksort on the cpu: \" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  quicksort(pArrayCopy, 0, arraySize-1);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  quickSortTime = totalTime;\n#ifdef TRUST_BUT_VERIFY\n  {\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArrayCopy);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArrayCopy[i]) {\n          \n\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      char y;\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      std::cin >> y;\n    }\n  }\n#endif\n#endif \n\n\n  std::cout << \"Sorting with GPU quicksort: \" << std::endl;\n  std::vector<T> original(arraySize);\n  std::copy(pArray, pArray + arraySize, original.begin());\n\n  std::vector<double> times;\n  times.resize(NUM_ITERATIONS);\n  double AverageTime = 0.0;\n  uint num_failures = 0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++) {\n    std::copy(original.begin(), original.end(), pArray);\n    std::vector<T> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    beginClock = seconds();\n    GPUQSort(arraySize, pArray, pArrayCopy);\n    endClock = seconds();\n    totalTime = endClock - beginClock;\n    std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n    times[k] = totalTime;\n    AverageTime += totalTime;\n#ifdef TRUST_BUT_VERIFY\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArray);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArray[i]) {\n          std:: cout << \"discrepancy at \" << i << \" \" << pArray[i] << \" expected \" << verify[i] << std::endl;\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      num_failures ++;\n    }\n#endif\n  }\n  std::cout << \" Number of failures: \" << num_failures << \" out of \" << NUM_ITERATIONS << std::endl;\n  AverageTime = AverageTime/NUM_ITERATIONS;\n  std::cout << \"Average Time: \" << AverageTime * 1000 << \" ms\" << std::endl;\n  double stdDev = 0.0, minTime = 1000000.0, maxTime = 0.0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++)\n  {\n    stdDev += (AverageTime - times[k])*(AverageTime - times[k]);\n    minTime = std::min(minTime, times[k]);\n    maxTime = std::max(maxTime, times[k]);\n  }\n\n  if (NUM_ITERATIONS > 1) {\n    stdDev = sqrt(stdDev/(NUM_ITERATIONS - 1));\n    std::cout << \"Standard Deviation: \" << stdDev * 1000 << std::endl;\n    std::cout << \"%error (3*stdDev)/Average: \" << 3*stdDev / AverageTime * 100 << \"%\" << std::endl;\n    std::cout << \"min time: \" << minTime * 1000 << \" ms\" << std::endl;\n    std::cout << \"max time: \" << maxTime * 1000 << \" ms\" << std::endl;\n  }\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Average speedup over CPU quicksort: \" << quickSortTime/AverageTime << std::endl;\n  std::cout << \"Average speedup over CPU std::sort: \" << stdSortTime/AverageTime << std::endl;\n#endif \n\n\n  printf(\"-------done--------------------------------------------------------\\n\");\n  free(pArray);\n  free(pArrayCopy);\n  return 0;\n}\n\n\nint main(int argc, char** argv)\n{\n  unsigned int  NUM_ITERATIONS;\n  uint      heightReSz, widthReSz;\n\n  bool success = parseArgs (argc, argv, &NUM_ITERATIONS, &widthReSz, &heightReSz);\n  if (!success) return -1;\n  uint arraySize = widthReSz*heightReSz;\n  test<uint>(arraySize, NUM_ITERATIONS, \"uint\");\n  test<float>(arraySize, NUM_ITERATIONS, \"float\");\n  test<double>(arraySize, NUM_ITERATIONS, \"double\");\n\n  return 0;\n}\n"}}
{"kernel_name": "quicksort", "kernel_api": "serial", "code": {"main.cpp": "\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n#include <vector>\n#include <map>\n\n\n\n\n\n\n\n#include \"QuicksortKernels.h\"\n\n\n\ntypedef unsigned int uint;\n#ifdef min\n#endif\n#ifdef max\n#endif\n\n\n\n\n\ndouble seconds() {\n  struct timespec now;\n  clock_gettime(CLOCK_MONOTONIC, &now);\n  return now.tv_sec + now.tv_nsec / 1000000000.0;\n}\n\n\nbool parseArgs(int argc, char** argv, unsigned int* test_iterations, unsigned int* widthReSz, unsigned int* heightReSz)\n{\n  const char sUsageString[512] = \"Usage: Quicksort [num test iterations] [SurfWidth(^2 only)] [SurfHeight(^2 only)]\";\n\n  if (argc != 4)\n  {\n    printf(sUsageString);\n    return false;\n  }\n  else\n  {\n    *test_iterations  = atoi (argv[1]);\n    *widthReSz  = atoi (argv[2]);\n    *heightReSz  = atoi (argv[3]);\n    return true;\n  }\n}\n\n\n#include \"Quicksort.h\"\n#include \"QuicksortKernels.h\"\n\n\ntemplate <class T>\nT* partition(T* left, T* right, T pivot) {\n  \n\n  T temp = *right;\n  *right = pivot;\n  *left = temp;\n\n  T* store = left;\n\n  for(T* p = left; p != right; p++) {\n    if (*p < pivot) {\n      temp = *store;\n      *store = *p;\n      *p = temp;\n      store++;\n    }\n  }\n\n  temp = *store;\n  *store = pivot;\n  *right = temp;\n\n  return store;\n}\n\n  template <class T>\nvoid quicksort(T* data, int left, int right)\n{\n  T* store = partition(data + left, data + right, data[left]);\n  int nright = store-data;\n  int nleft = nright+1;\n\n  if (left < nright) {\n    if (nright - left > 32) {\n      quicksort(data, left, nright);\n    } else\n      std::sort(data + left, data + nright + 1);\n  }\n\n  if (nleft < right) {\n    if (right - nleft > 32)  {\n      quicksort(data, nleft, right);\n    } else {\n      std::sort(data + nleft, data + right + 1);\n    }\n  }\n}\n\nsize_t optp(size_t s, double k, size_t m) {\n  return (size_t)pow(2, floor(log(s*k + m)/log(2.0) + 0.5));\n}\n\ntemplate <class T>\nvoid GPUQSort(size_t size, T* d, T* dn)  {\n\n  \n\n  {\n    const size_t MAXSEQ = optp(size, 0.00009516, 203);\n    const size_t MAX_SIZE = 12*std::max(MAXSEQ, (size_t)QUICKSORT_BLOCK_SIZE);\n    \n\n    uint startpivot = median_host(d[0], d[size/2], d[size-1]);\n    std::vector<work_record<T>> work, done, news;\n    work.reserve(MAX_SIZE);\n    done.reserve(MAX_SIZE);\n    news.reserve(MAX_SIZE);\n    std::vector<parent_record> parent_records;\n    parent_records.reserve(MAX_SIZE);\n    std::vector<block_record<T>> blocks;\n    blocks.reserve(MAX_SIZE);\n\n    work.push_back(work_record<T>(0, size, startpivot, 1));\n\n    bool reset = true;\n\n    while(!work.empty() \n) {\n      size_t blocksize = 0;\n\n      for(auto it = work.begin(); it != work.end(); ++it) {\n        blocksize += std::max((it->end - it->start)/MAXSEQ, (size_t)1);\n      }\n      for(auto it = work.begin(); it != work.end(); ++it) {\n        uint start = it->start;\n        uint end   = it->end;\n        uint pivot = it->pivot;\n        uint direction = it->direction;\n        uint blockcount = (end - start + blocksize - 1)/blocksize;\n        parent_record prnt(start, end, start, end, blockcount-1);\n        parent_records.push_back(prnt);\n\n        for(uint i = 0; i < blockcount - 1; i++) {\n          uint bstart = start + blocksize*i;\n          block_record<T> br(bstart, bstart+blocksize, pivot, direction, parent_records.size()-1);\n          blocks.push_back(br);\n        }\n        block_record<T> br(start + blocksize*(blockcount - 1), end, pivot, direction, parent_records.size()-1);\n        blocks.push_back(br);\n      }\n\n      \n\n\n      news.resize(blocks.size()*2);\n\n#ifdef DEBUG\n      printf(\"blocks\\n\");\n      for (int i = 0; i < blocks.size(); i++) {\n        printf(\"%u %u %u %u %u\\n\", blocks[i].start, blocks[i].end, blocks[i].pivot, blocks[i].direction, blocks[i].parent);\n      }\n      printf(\"parents\\n\");\n      for (int i = 0; i < parent_records.size(); i++) {\n        printf(\"%u %u %u %u %u\\n\", parent_records[i].sstart, parent_records[i].send, parent_records[i].oldstart, parent_records[i].oldend, parent_records[i].blockcount);\n      }\n      printf(\"input news\\n\");\n      for (int i = 0; i < news.size(); i++) {\n        printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n      }\n#endif\n\n#ifdef GET_DETAILED_PERFORMANCE\n      static double absoluteTotal = 0.0;\n      static uint count = 0;\n\n      if (reset) {\n        absoluteTotal = 0.0;\n        count = 0;\n      }\n\n      double beginClock, endClock;\n      beginClock = seconds();\n#endif\n\n      block_record<T> *blocksb = blocks.data();\n      parent_record *parentsb = parent_records.data();\n      work_record<T> *result = news.data();\n\n      \n\n\n      int blocks_size = blocks.size();\n\n      {\n#include \"gqsort_kernel.h\"\n      }\n\n\n#ifdef GET_DETAILED_PERFORMANCE\n      endClock = seconds();\n      double totalTime = endClock - beginClock;\n      absoluteTotal += totalTime;\n      std::cout << ++count << \": gqsort time \" << absoluteTotal * 1000 << \" ms\" << std::endl;\n#endif\n\n#ifdef DEBUG\n      printf(\"\\noutput news\\n\");\n      for (int i = 0; i < news.size(); i++) {\n        printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n      }\n#endif\n\n      reset = false;\n      work.clear();\n      parent_records.clear();\n      blocks.clear();\n      for(auto it = news.begin(); it != news.end(); ++it) {\n        if (it->direction != EMPTY_RECORD) {\n          if (it->end - it->start <= QUICKSORT_BLOCK_SIZE \n) {\n            if (it->end - it->start > 0)\n              done.push_back(*it);\n          } else {\n            work.push_back(*it);\n          }\n        }\n      }\n      news.clear();\n    } \n\n\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      if (it->end - it->start > 0)\n        done.push_back(*it);\n    }\n\n    work_record<T>* seqs = done.data();\n    uint done_size = done.size();\n\n#ifdef GET_DETAILED_PERFORMANCE\n    double beginClock, endClock;\n    beginClock = seconds();\n#endif\n    \n\n    {\n#include \"lqsort_kernel.h\"\n    }\n#ifdef GET_DETAILED_PERFORMANCE\n    endClock = seconds();\n    double totalTime = endClock - beginClock;\n    std::cout << \"lqsort time \" << totalTime * 1000 << \" ms\" << std::endl;\n#endif\n\n  } \n\n}\n\ntemplate <class T>\nint test(uint arraySize, unsigned int  NUM_ITERATIONS,\n         const std::string& type_name)\n{\n  double totalTime, quickSortTime, stdSortTime;\n  double beginClock, endClock;\n\n  printf(\"\\n\\n\\n--------------------------------------------------------------------\\n\");\n  printf(\"Allocating array size of %d (data type: %s)\\n\", arraySize, type_name.c_str());\n  T* pArray = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  T* pArrayCopy = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n\n  \n\n  std::generate(pArray, pArray + arraySize, [](){static uint i = 0; return ++i; });\n  std::shuffle(pArray, pArray + arraySize, std::mt19937(19937));\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Sorting the regular way...\" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  std::sort(pArrayCopy, pArrayCopy + arraySize);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  stdSortTime = totalTime;\n\n  std::cout << \"Sorting with parallel quicksort on the cpu: \" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  quicksort(pArrayCopy, 0, arraySize-1);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  quickSortTime = totalTime;\n#ifdef TRUST_BUT_VERIFY\n  {\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArrayCopy);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArrayCopy[i]) {\n          \n\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      char y;\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      std::cin >> y;\n    }\n  }\n#endif\n#endif \n\n\n  std::cout << \"Sorting with GPU quicksort: \" << std::endl;\n  std::vector<T> original(arraySize);\n  std::copy(pArray, pArray + arraySize, original.begin());\n\n  std::vector<double> times;\n  times.resize(NUM_ITERATIONS);\n  double AverageTime = 0.0;\n  uint num_failures = 0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++) {\n    std::copy(original.begin(), original.end(), pArray);\n    std::vector<T> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    beginClock = seconds();\n    GPUQSort(arraySize, pArray, pArrayCopy);\n    endClock = seconds();\n    totalTime = endClock - beginClock;\n    std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n    times[k] = totalTime;\n    AverageTime += totalTime;\n#ifdef TRUST_BUT_VERIFY\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArray);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArray[i]) {\n          std:: cout << \"discrepancy at \" << i << \" \" << pArray[i] << \" expected \" << verify[i] << std::endl;\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      num_failures ++;\n    }\n#endif\n  }\n  std::cout << \" Number of failures: \" << num_failures << \" out of \" << NUM_ITERATIONS << std::endl;\n  AverageTime = AverageTime/NUM_ITERATIONS;\n  std::cout << \"Average Time: \" << AverageTime * 1000 << \" ms\" << std::endl;\n  double stdDev = 0.0, minTime = 1000000.0, maxTime = 0.0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++)\n  {\n    stdDev += (AverageTime - times[k])*(AverageTime - times[k]);\n    minTime = std::min(minTime, times[k]);\n    maxTime = std::max(maxTime, times[k]);\n  }\n\n  if (NUM_ITERATIONS > 1) {\n    stdDev = sqrt(stdDev/(NUM_ITERATIONS - 1));\n    std::cout << \"Standard Deviation: \" << stdDev * 1000 << std::endl;\n    std::cout << \"%error (3*stdDev)/Average: \" << 3*stdDev / AverageTime * 100 << \"%\" << std::endl;\n    std::cout << \"min time: \" << minTime * 1000 << \" ms\" << std::endl;\n    std::cout << \"max time: \" << maxTime * 1000 << \" ms\" << std::endl;\n  }\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Average speedup over CPU quicksort: \" << quickSortTime/AverageTime << std::endl;\n  std::cout << \"Average speedup over CPU std::sort: \" << stdSortTime/AverageTime << std::endl;\n#endif \n\n\n  printf(\"-------done--------------------------------------------------------\\n\");\n  free(pArray);\n  free(pArrayCopy);\n  return 0;\n}\n\n\nint main(int argc, char** argv)\n{\n  unsigned int  NUM_ITERATIONS;\n  uint      heightReSz, widthReSz;\n\n  bool success = parseArgs (argc, argv, &NUM_ITERATIONS, &widthReSz, &heightReSz);\n  if (!success) return -1;\n  uint arraySize = widthReSz*heightReSz;\n  test<uint>(arraySize, NUM_ITERATIONS, \"uint\");\n  test<float>(arraySize, NUM_ITERATIONS, \"float\");\n  test<double>(arraySize, NUM_ITERATIONS, \"double\");\n\n  return 0;\n}"}}
{"kernel_name": "quicksort", "kernel_api": "sycl", "code": {"main.cpp": "\n\n\n\n\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <iostream>\n#include <algorithm>\n#include <iterator>\n#include <random>\n#include <vector>\n#include <map>\n#include <sycl/sycl.hpp>\n\n#define RUN_CPU_SORTS\n\n\n\n\n\ntypedef unsigned int uint;\n#ifdef min\n#undef min\n#endif\n#ifdef max\n#undef max\n#endif\n\n\n\n\n\ndouble seconds() {\n  struct timespec now;\n  clock_gettime(CLOCK_MONOTONIC, &now);\n  return now.tv_sec + now.tv_nsec / 1000000000.0;\n}\n\n\nbool parseArgs(int argc, char** argv, unsigned int* test_iterations, unsigned int* widthReSz, unsigned int* heightReSz)\n{\n  const char sUsageString[512] = \"Usage: Quicksort [num test iterations] [SurfWidth(^2 only)] [SurfHeight(^2 only)]\";\n\n  if (argc != 4)\n  {\n    printf(sUsageString);\n    return false;\n  }\n  else\n  {\n    *test_iterations  = atoi (argv[1]);\n    *widthReSz  = atoi (argv[2]);\n    *heightReSz  = atoi (argv[3]);\n    return true;\n  }\n}\n\n\n#include \"Quicksort.h\"\n#include \"QuicksortKernels.h\"\n\ntemplate <class T>\nT* partition(T* left, T* right, T pivot) {\n  \n\n  T temp = *right;\n  *right = pivot;\n  *left = temp;\n\n  T* store = left;\n\n  for(T* p = left; p != right; p++) {\n    if (*p < pivot) {\n      temp = *store;\n      *store = *p;\n      *p = temp;\n      store++;\n    }\n  }\n\n  temp = *store;\n  *store = pivot;\n  *right = temp;\n\n  return store;\n}\n\n  template <class T>\nvoid quicksort(T* data, int left, int right)\n{\n  T* store = partition(data + left, data + right, data[left]);\n  int nright = store-data;\n  int nleft = nright+1;\n\n  if (left < nright) {\n    if (nright - left > 32) {\n      quicksort(data, left, nright);\n    } else\n      std::sort(data + left, data + nright + 1);\n  }\n\n  if (nleft < right) {\n    if (right - nleft > 32)  {\n      quicksort(data, nleft, right);\n    } else {\n      std::sort(data + nleft, data + right + 1);\n    }\n  }\n}\n\ntemplate <class T>\nvoid gqsort(sycl::queue &q, T *db, T *dnb, std::vector<block_record<T>> &blocks,\n            std::vector<parent_record> &parents,\n            std::vector<work_record<T>> &news, bool reset) {\n\n  news.resize(blocks.size()*2);\n\n#ifdef GET_DETAILED_PERFORMANCE\n  static double absoluteTotal = 0.0;\n  static uint count = 0;\n\n  if (reset) {\n    absoluteTotal = 0.0;\n    count = 0;\n  }\n\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n\n  block_record<T> *blocksb;\n  parent_record *parentsb;\n  work_record<T> *newsb;\n  blocksb = (block_record<T> *)sycl::malloc_device(\n            sizeof(block_record<T>) * blocks.size(), q);\n  q.memcpy(blocksb, blocks.data(), sizeof(block_record<T>) * blocks.size());\n\n  parentsb = sycl::malloc_device<parent_record>(parents.size(), q);\n  q.memcpy(parentsb, parents.data(), sizeof(parent_record) * parents.size());\n\n  newsb = (work_record<T> *)sycl::malloc_device(sizeof(work_record<T>) * news.size(), q);\n  q.memcpy(newsb, news.data(), sizeof(work_record<T>) * news.size());\n\n  q.submit([&](sycl::handler &cgh) {\n    sycl::local_accessor<uint, 1> lt_acc(\n        sycl::range<1>(GQSORT_LOCAL_WORKGROUP_SIZE+1), cgh);\n    sycl::local_accessor<uint, 1> gt_acc(\n        sycl::range<1>(GQSORT_LOCAL_WORKGROUP_SIZE+1), cgh);\n    sycl::local_accessor<uint, 0> ltsum_acc(cgh);\n    sycl::local_accessor<uint, 0> gtsum_acc(cgh);\n    sycl::local_accessor<uint, 0> lbeg_acc(cgh);\n    sycl::local_accessor<uint, 0> gbeg_acc(cgh);\n\n    cgh.parallel_for(\n      sycl::nd_range<1>(GQSORT_LOCAL_WORKGROUP_SIZE * blocks.size(),\n        GQSORT_LOCAL_WORKGROUP_SIZE), [=] (sycl::nd_item<1> item) {\n          gqsort_kernel(db, dnb, blocksb, parentsb, newsb, item,\n                        lt_acc.get_pointer(), gt_acc.get_pointer(),\n                        ltsum_acc, gtsum_acc, lbeg_acc,\n                        gbeg_acc);\n        });\n  });\n\n  q.memcpy(news.data(), newsb, sizeof(work_record<T>) * news.size()).wait();\n\n  sycl::free(blocksb, q);\n  sycl::free(parentsb, q);\n  sycl::free(newsb, q);\n\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  absoluteTotal += totalTime;\n  std::cout << ++count << \": gqsort time \" << absoluteTotal * 1000 << \" ms\" << std::endl;\n#endif\n\n#ifdef DEBUG\n  printf(\"\\noutput news\\n\");\n  for (int i = 0; i < news.size(); i++) {\n    printf(\"%u %u %u %u\\n\", news[i].start, news[i].end, news[i].pivot, news[i].direction);\n  }\n#endif\n}\n\ntemplate <class T>\nvoid lqsort(sycl::queue &q, T *db, T *dnb, std::vector<work_record<T>> &done) {\n\n#ifdef GET_DETAILED_PERFORMANCE\n  double beginClock, endClock;\n  beginClock = seconds();\n#endif\n  work_record<T>* doneb;\n  \n\n\n  doneb = (work_record<T> *)sycl::malloc_device(\n          sizeof(work_record<T>) * done.size(), q);\n  q.memcpy(doneb, done.data(), sizeof(work_record<T>) * done.size());\n\n  q.submit([&](sycl::handler &cgh) {\n    sycl::local_accessor<workstack_record, 1> workstack_acc(\n        sycl::range<1>(QUICKSORT_BLOCK_SIZE/SORT_THRESHOLD), cgh);\n    sycl::local_accessor<int, 0> workstack_pointer_acc(cgh);\n    sycl::local_accessor<T, 1> mys_acc(\n        sycl::range<1>(QUICKSORT_BLOCK_SIZE), cgh);\n    sycl::local_accessor<T, 1> mysn_acc(\n        sycl::range<1>(QUICKSORT_BLOCK_SIZE), cgh);\n    sycl::local_accessor<T, 1> temp_acc(\n        sycl::range<1>(SORT_THRESHOLD), cgh);\n    sycl::local_accessor<uint, 0> ltsum_acc(cgh);\n    sycl::local_accessor<uint, 0> gtsum_acc(cgh);\n    sycl::local_accessor<uint, 1> lt_acc(\n        sycl::range<1>(LQSORT_LOCAL_WORKGROUP_SIZE+1), cgh);\n    sycl::local_accessor<uint, 1> gt_acc(\n        sycl::range<1>(LQSORT_LOCAL_WORKGROUP_SIZE+1), cgh);\n\n    cgh.parallel_for(\n      sycl::nd_range<1>(LQSORT_LOCAL_WORKGROUP_SIZE * done.size(),\n        LQSORT_LOCAL_WORKGROUP_SIZE), [=] (sycl::nd_item<1> item) {\n          lqsort_kernel(\n              db, dnb, doneb, item, workstack_acc.get_pointer(),\n              workstack_pointer_acc, mys_acc.get_pointer(),\n              mysn_acc.get_pointer(), temp_acc.get_pointer(),\n              ltsum_acc, gtsum_acc,\n              lt_acc.get_pointer(), gt_acc.get_pointer());\n        });\n  }).wait();\n\n  \n\n  sycl::free(doneb, q);\n\n#ifdef GET_DETAILED_PERFORMANCE\n  endClock = seconds();\n  double totalTime = endClock - beginClock;\n  std::cout << \"lqsort time \" << totalTime * 1000 << \" ms\" << std::endl;\n#endif\n}\n\nsize_t optp(size_t s, double k, size_t m) {\n  return (size_t)pow(2, floor(log(s * k + m) / log(2.0) + 0.5));\n}\n\ntemplate <class T> void GPUQSort(sycl::queue &q, size_t size, T *d, T *dn) {\n\n  const size_t buffer_size = (sizeof(T)*size/64 + 1) * 64;\n\n  \n\n  T *db, *dnb;\n  db = (T *)sycl::malloc_device(buffer_size, q);\n  q.memcpy(db, d, buffer_size);\n\n  dnb = (T *)sycl::malloc_device(buffer_size, q);\n  q.memcpy(dnb, dn, buffer_size);\n\n  const size_t MAXSEQ = optp(size, 0.00009516, 203);\n  const size_t MAX_SIZE = 12*std::max(MAXSEQ, (size_t)QUICKSORT_BLOCK_SIZE);\n  \n\n  uint startpivot = median_host(d[0], d[size/2], d[size-1]);\n  std::vector<work_record<T>> work, done, news;\n  work.reserve(MAX_SIZE);\n  done.reserve(MAX_SIZE);\n  news.reserve(MAX_SIZE);\n  std::vector<parent_record> parent_records;\n  parent_records.reserve(MAX_SIZE);\n  std::vector<block_record<T>> blocks;\n  blocks.reserve(MAX_SIZE);\n\n  work.push_back(work_record<T>(0, size, startpivot, 1));\n\n  bool reset = true;\n\n  while(!work.empty() \n) {\n    size_t blocksize = 0;\n\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      blocksize += std::max((it->end - it->start)/MAXSEQ, (size_t)1);\n    }\n    for(auto it = work.begin(); it != work.end(); ++it) {\n      uint start = it->start;\n      uint end   = it->end;\n      uint pivot = it->pivot;\n      uint direction = it->direction;\n      uint blockcount = (end - start + blocksize - 1)/blocksize;\n      parent_record prnt(start, end, start, end, blockcount-1);\n      parent_records.push_back(prnt);\n\n      for(uint i = 0; i < blockcount - 1; i++) {\n        uint bstart = start + blocksize*i;\n        block_record<T> br(bstart, bstart+blocksize, pivot, direction, parent_records.size()-1);\n        blocks.push_back(br);\n      }\n      block_record<T> br(start + blocksize*(blockcount - 1), end, pivot, direction, parent_records.size()-1);\n      blocks.push_back(br);\n    }\n    \n\n\n    gqsort<T>(q, db, dnb, blocks, parent_records, news, reset);\n\n    reset = false;\n    work.clear();\n    parent_records.clear();\n    blocks.clear();\n    for(auto it = news.begin(); it != news.end(); ++it) {\n      if (it->direction != EMPTY_RECORD) {\n        if (it->end - it->start <= QUICKSORT_BLOCK_SIZE \n) {\n          if (it->end - it->start > 0)\n            done.push_back(*it);\n        } else {\n          work.push_back(*it);\n        }\n      }\n    }\n    news.clear();\n  }\n  for(auto it = work.begin(); it != work.end(); ++it) {\n    if (it->end - it->start > 0)\n      done.push_back(*it);\n  }\n\n  if (done.size() > 0)\n    lqsort<T>(q, db, dnb, done);\n\n  q.memcpy(d, db, buffer_size).wait();\n  sycl::free(db, q);\n  sycl::free(dnb, q);\n}\n\ntemplate <class T>\nint test(uint arraySize, unsigned int  NUM_ITERATIONS,\n         const std::string& type_name)\n{\n  double totalTime, quickSortTime, stdSortTime;\n  double beginClock, endClock;\n\n  printf(\"\\n\\n\\n--------------------------------------------------------------------\\n\");\n  printf(\"Allocating array size of %d (data type: %s)\\n\", arraySize, type_name.c_str());\n  T* pArray = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  T* pArrayCopy = (T*)aligned_alloc (4096, ((arraySize*sizeof(T))/64 + 1)*64);\n  std::generate(pArray, pArray + arraySize, [](){static T i = 0; return ++i; });\n  std::shuffle(pArray, pArray + arraySize, std::mt19937(19937));\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Sorting the regular way...\" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  std::sort(pArrayCopy, pArrayCopy + arraySize);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  stdSortTime = totalTime;\n\n  std::cout << \"quicksort on the cpu: \" << std::endl;\n  std::copy(pArray, pArray + arraySize, pArrayCopy);\n\n  beginClock = seconds();\n  quicksort(pArrayCopy, 0, arraySize-1);\n  endClock = seconds();\n  totalTime = endClock - beginClock;\n  std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n  quickSortTime = totalTime;\n#ifdef TRUST_BUT_VERIFY\n  {\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArrayCopy);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArrayCopy[i]) {\n          \n\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      char y;\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      std::cin >> y;\n    }\n  }\n#endif\n#endif \n\n\n  std::cout << \"Sorting with GPU quicksort: \" << std::endl;\n  std::vector<uint> original(arraySize);\n  std::copy(pArray, pArray + arraySize, original.begin());\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  std::vector<double> times;\n  times.resize(NUM_ITERATIONS);\n  double AverageTime = 0.0;\n  uint num_failures = 0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++) {\n    std::copy(original.begin(), original.end(), pArray);\n    std::vector<uint> seqs;\n    std::vector<uint> verify(arraySize);\n    std::copy(pArray, pArray + arraySize, verify.begin());\n\n    beginClock = seconds();\n    GPUQSort(q, arraySize, pArray, pArrayCopy);\n    endClock = seconds();\n    totalTime = endClock - beginClock;\n    std::cout << \"Time to sort: \" << totalTime * 1000 << \" ms\" << std::endl;\n    times[k] = totalTime;\n    AverageTime += totalTime;\n#ifdef TRUST_BUT_VERIFY\n    std::cout << \"verifying: \";\n    std::sort(verify.begin(), verify.end());\n    bool correct = std::equal(verify.begin(), verify.end(), pArray);\n    unsigned int num_discrepancies = 0;\n    if (!correct) {\n      for(size_t i = 0; i < arraySize; i++) {\n        if (verify[i] != pArray[i]) {\n          std:: cout << \"discrepancy at \" << i << \" \" << pArray[i] << \" expected \" << verify[i] << std::endl;\n          num_discrepancies++;\n        }\n      }\n    }\n    std::cout << std::boolalpha << correct << std::endl;\n    if (!correct) {\n      std::cout << \"num_discrepancies: \" << num_discrepancies << std::endl;\n      num_failures ++;\n    }\n#endif\n  }\n  std::cout << \" Number of failures: \" << num_failures << \" out of \" << NUM_ITERATIONS << std::endl;\n  AverageTime = AverageTime/NUM_ITERATIONS;\n  std::cout << \"Average Time: \" << AverageTime * 1000 << \" ms\" << std::endl;\n  double stdDev = 0.0, minTime = 1000000.0, maxTime = 0.0;\n  for(uint k = 0; k < NUM_ITERATIONS; k++)\n  {\n    stdDev += (AverageTime - times[k])*(AverageTime - times[k]);\n    minTime = std::min(minTime, times[k]);\n    maxTime = std::max(maxTime, times[k]);\n  }\n\n  if (NUM_ITERATIONS > 1) {\n    stdDev = sqrt(stdDev/(NUM_ITERATIONS - 1));\n    std::cout << \"Standard Deviation: \" << stdDev * 1000 << std::endl;\n    std::cout << \"%error (3*stdDev)/Average: \" << 3*stdDev / AverageTime * 100 << \"%\" << std::endl;\n    std::cout << \"min time: \" << minTime * 1000 << \" ms\" << std::endl;\n    std::cout << \"max time: \" << maxTime * 1000 << \" ms\" << std::endl;\n  }\n\n#ifdef RUN_CPU_SORTS\n  std::cout << \"Average speedup over CPU quicksort: \" << quickSortTime/AverageTime << std::endl;\n  std::cout << \"Average speedup over CPU std::sort: \" << stdSortTime/AverageTime << std::endl;\n#endif \n\n\n  printf(\"-------done--------------------------------------------------------\\n\");\n  free(pArray);\n  free(pArrayCopy);\n\n  return 0;\n}\n\n\nint main(int argc, char** argv)\n{\n  unsigned int  NUM_ITERATIONS;\n  uint      heightReSz, widthReSz;\n\n  bool success = parseArgs (argc, argv, &NUM_ITERATIONS, &widthReSz, &heightReSz);\n  if (!success) return -1;\n  uint arraySize = widthReSz*heightReSz;\n  test<uint>(arraySize, NUM_ITERATIONS, \"uint\");\n  test<float>(arraySize, NUM_ITERATIONS, \"float\");\n  test<double>(arraySize, NUM_ITERATIONS, \"double\");\n  return 0;\n}\n"}}
{"kernel_name": "sort", "kernel_api": "cuda", "code": {"main.cu": "#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <chrono>\n#include <cuda.h>\n#include <thrust/sort.h>\n#include <thrust/functional.h>\n#include <thrust/device_vector.h>\n\ntypedef unsigned int T;\ntypedef uint4 VECTYPE;\n\n\n\n#include \"sort_reduce.h\"\n#include \"sort_top_scan.h\"\n#include \"sort_bottom_scan.h\"\n\nvoid verifySort(const T *keys, const size_t size)\n{\n  bool passed = true;\n  for (size_t i = 0; i < size - 1; i++)\n  {\n    if (keys[i] > keys[i + 1])\n    {\n      passed = false;\n#ifdef VERBOSE_OUTPUT\n      std::cout << \"Idx: \" << i;\n      std::cout << \" Key: \" << keys[i] << \"\\n\";\n#endif\n      break;\n    }\n  }\n  if (passed)\n    std::cout << \"PASS\" << std::endl;\n  else\n    std::cout << \"FAIL\" << std::endl;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) \n  {\n    printf(\"Usage: %s <problem size> <number of passes>\\n.\", argv[0]);\n    return -1;\n  }\n\n  int select = atoi(argv[1]);\n  int passes = atoi(argv[2]);\n\n  \n\n  int probSizes[4] = { 1, 8, 32, 64 };\n  size_t size = probSizes[select];\n\n  \n\n  size = (size * 1024 * 1024) / sizeof(T);\n\n  \n\n  unsigned int bytes = size * sizeof(T);\n\n  T* h_idata = (T*) malloc (bytes); \n  T* h_odata = (T*) malloc (bytes); \n\n  \n\n  std::cout << \"Initializing host memory.\" << std::endl;\n  for (unsigned int i = 0; i < size; i++)\n  {\n    h_idata[i] = i % 16; \n\n    h_odata[i] = size - i;\n  }\n\n  std::cout << \"Running benchmark with input array length \" << size << std::endl;\n\n  \n\n  const size_t local_wsize  = 256;\n  \n\n  const size_t global_wsize = 16384; \n  \n\n  const size_t num_work_groups = global_wsize / local_wsize;\n\n  \n\n  const int radix_width = 4; \n\n  \n\n  const int num_digits = 16;\n\n  T* d_idata;\n  T* d_odata;\n  T* d_isums;\n\n  cudaMalloc((void**)&d_idata, size * sizeof(T));\n  cudaMemcpyAsync(d_idata, h_idata, size * sizeof(T), cudaMemcpyHostToDevice, 0);\n  cudaMalloc((void**)&d_odata, size * sizeof(T));\n  cudaMalloc((void**)&d_isums, num_work_groups * num_digits * sizeof(T));\n\n  T *d_in, *d_out;\n  double time = 0.0;\n\n  for (int k = 0; k < passes; k++)\n  {\n    cudaDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    \n\n    \n\n    for (unsigned int shift = 0; shift < sizeof(T)*8; shift += radix_width)\n    {\n      \n\n      \n\n      \n\n      \n\n      \n\n      \n\n      bool even = ((shift / radix_width) % 2 == 0) ? true : false;\n      d_in = even ? d_idata : d_odata;\n      d_out = even ? d_odata : d_idata;\n\n      reduce<<<num_work_groups, local_wsize>>> (d_in, d_isums, size, shift);\n      top_scan<<<1, local_wsize>>>(d_isums, num_work_groups);\n      bottom_scan<<<num_work_groups, local_wsize>>>(d_out, d_in, d_isums, size, shift);\n    }\n\n    cudaDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  }  \n\n\n  printf(\"Average elapsed time of sort: %lf (s)\\n\", time * 1e-9 / passes);\n\n  cudaMemcpy(h_odata, d_out, size * sizeof(T), cudaMemcpyDeviceToHost);\n  verifySort(h_odata, size);\n\n  \n\n  time = 0.0;\n  for (int k = 0; k < passes; k++) {\n    cudaMemcpy(d_odata, h_idata, size * sizeof(T), cudaMemcpyHostToDevice);\n    cudaDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n    thrust::device_ptr<T> d_out_ptr (d_odata);\n    thrust::sort(d_out_ptr, d_out_ptr + size, thrust::less<T>());\n    cudaDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  }\n  printf(\"Average elapsed time of Thrust::sort: %lf (s)\\n\", time * 1e-9 / passes);\n\n  cudaMemcpy(h_odata, d_odata, size * sizeof(T), cudaMemcpyDeviceToHost);\n  verifySort(h_odata, size);\n\n  cudaFree(d_idata);\n  cudaFree(d_odata);\n  cudaFree(d_isums);\n\n  free(h_idata);\n  free(h_odata);\n  return 0;\n}\n"}}
{"kernel_name": "sort", "kernel_api": "hip", "code": {"main.cu": "#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <chrono>\n#include <hip/hip_runtime.h>\n#include <thrust/sort.h>\n#include <thrust/functional.h>\n#include <thrust/device_vector.h>\n\ntypedef unsigned int T;\ntypedef uint4 VECTYPE;\n\n\n\n#include \"sort_reduce.h\"\n#include \"sort_top_scan.h\"\n#include \"sort_bottom_scan.h\"\n\nvoid verifySort(const T *keys, const size_t size)\n{\n  bool passed = true;\n  for (size_t i = 0; i < size - 1; i++)\n  {\n    if (keys[i] > keys[i + 1])\n    {\n      passed = false;\n#ifdef VERBOSE_OUTPUT\n      std::cout << \"Idx: \" << i;\n      std::cout << \" Key: \" << keys[i] << \"\\n\";\n#endif\n      break;\n    }\n  }\n  if (passed)\n    std::cout << \"PASS\" << std::endl;\n  else\n    std::cout << \"FAIL\" << std::endl;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) \n  {\n    printf(\"Usage: %s <problem size> <number of passes>\\n.\", argv[0]);\n    return -1;\n  }\n\n  int select = atoi(argv[1]);\n  int passes = atoi(argv[2]);\n\n  \n\n  int probSizes[4] = { 1, 8, 32, 64 };\n  size_t size = probSizes[select];\n\n  \n\n  size = (size * 1024 * 1024) / sizeof(T);\n\n  \n\n  unsigned int bytes = size * sizeof(T);\n\n  T* h_idata = (T*) malloc (bytes); \n  T* h_odata = (T*) malloc (bytes); \n\n  \n\n  std::cout << \"Initializing host memory.\" << std::endl;\n  for (unsigned int i = 0; i < size; i++)\n  {\n    h_idata[i] = i % 16; \n\n    h_odata[i] = size - i;\n  }\n\n  std::cout << \"Running benchmark with input array length \" << size << std::endl;\n\n  \n\n  const size_t local_wsize  = 256;\n  \n\n  const size_t global_wsize = 16384; \n  \n\n  const size_t num_work_groups = global_wsize / local_wsize;\n\n  \n\n  const int radix_width = 4; \n\n  \n\n  const int num_digits = 16;\n\n  T* d_idata;\n  T* d_odata;\n  T* d_isums;\n\n  hipMalloc((void**)&d_idata, size * sizeof(T));\n  hipMemcpyAsync(d_idata, h_idata, size * sizeof(T), hipMemcpyHostToDevice, 0);\n  hipMalloc((void**)&d_odata, size * sizeof(T));\n  hipMalloc((void**)&d_isums, num_work_groups * num_digits * sizeof(T));\n\n  T *d_in, *d_out;\n  double time = 0.0;\n\n  for (int k = 0; k < passes; k++)\n  {\n    hipDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    \n\n    \n\n    for (unsigned int shift = 0; shift < sizeof(T)*8; shift += radix_width)\n    {\n      \n\n      \n\n      \n\n      \n\n      \n\n      \n\n      bool even = ((shift / radix_width) % 2 == 0) ? true : false;\n      d_in = even ? d_idata : d_odata;\n      d_out = even ? d_odata : d_idata;\n\n      reduce<<<num_work_groups, local_wsize>>> (d_in, d_isums, size, shift);\n      top_scan<<<1, local_wsize>>>(d_isums, num_work_groups);\n      bottom_scan<<<num_work_groups, local_wsize>>>(d_out, d_in, d_isums, size, shift);\n    }\n\n    hipDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  }  \n\n\n  printf(\"Average elapsed time of sort: %lf (s)\\n\", time * 1e-9 / passes);\n\n  hipMemcpy(h_odata, d_out, size * sizeof(T), hipMemcpyDeviceToHost);\n  verifySort(h_odata, size);\n\n  \n\n  time = 0.0;\n  for (int k = 0; k < passes; k++) {\n    hipMemcpy(d_odata, h_idata, size * sizeof(T), hipMemcpyHostToDevice);\n    hipDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n    thrust::device_ptr<T> d_out_ptr (d_odata);\n    thrust::sort(d_out_ptr, d_out_ptr + size, thrust::less<T>());\n    hipDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  }\n  printf(\"Average elapsed time of Thrust::sort: %lf (s)\\n\", time * 1e-9 / passes);\n\n  hipMemcpy(h_odata, d_odata, size * sizeof(T), hipMemcpyDeviceToHost);\n  verifySort(h_odata, size);\n\n  hipFree(d_idata);\n  hipFree(d_odata);\n  hipFree(d_isums);\n\n  free(h_idata);\n  free(h_odata);\n  return 0;\n}\n"}}
{"kernel_name": "sort", "kernel_api": "omp", "code": {"main.cpp": "#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <chrono>\n#include <omp.h>\n\ntypedef unsigned int T;\n\ntemplate<typename T>\nstruct vec4 {\n  T x;\n  T y;\n  T z;\n  T w;\n};\n\nvoid verifySort(const T *keys, const size_t size)\n{\n  bool passed = true;\n  for (size_t i = 0; i < size - 1; i++)\n  {\n    if (keys[i] > keys[i + 1])\n    {\n      passed = false;\n#ifdef VERBOSE_OUTPUT\n      std::cout << \"Idx: \" << i;\n      std::cout << \" Key: \" << keys[i] << \"\\n\";\n#endif\n      break;\n    }\n  }\n  if (passed)\n    std::cout << \"PASS\" << std::endl;\n  else\n    std::cout << \"FAIL\" << std::endl;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) \n  {\n    printf(\"Usage: %s <problem size> <number of passes>\\n.\", argv[0]);\n    return -1;\n  }\n\n  int select = atoi(argv[1]);\n  int passes = atoi(argv[2]);\n\n  \n\n  int probSizes[4] = { 1, 8, 32, 64 };\n  size_t size = probSizes[select];\n\n  \n\n  size = (size * 1024 * 1024) / sizeof(T);\n\n  \n\n  unsigned int bytes = size * sizeof(T);\n\n  T* idata = (T*) malloc (bytes); \n  T* odata = (T*) malloc (bytes); \n\n  \n\n  std::cout << \"Initializing host memory.\" << std::endl;\n  for (int i = 0; i < size; i++)\n  {\n    idata[i] = i % 16; \n\n    odata[i] = size - i;\n  }\n\n  std::cout << \"Running benchmark with input array length \" << size << std::endl;\n\n  \n\n  const size_t local_wsize  = 256;\n  \n\n  const size_t global_wsize = 16384; \n  \n\n  const size_t num_work_groups = global_wsize / local_wsize;\n\n  \n\n  const int radix_width = 4; \n\n  \n\n  const int num_digits = 16;\n\n  T* isums = (T*) malloc (sizeof(T) * num_work_groups * num_digits);\n\n  #pragma omp target data map(to: idata[0:size]) \\\n                          map(from: odata[0:size]) \\\n                          map(alloc: isums[0:num_work_groups * num_digits])\n  {\n    double time = 0.0;\n\n    for (int k = 0; k < passes; k++)\n    {\n      auto start = std::chrono::steady_clock::now();\n\n      \n\n      for (unsigned int shift = 0; shift < sizeof(T)*8; shift += radix_width)\n      {\n        \n\n\n        \n\n        \n\n        \n\n\n        \n\n        \n\n        bool even = ((shift / radix_width) % 2 == 0) ? true : false;\n\n        T *in = even ? idata : odata;\n        T *out = even ? odata : idata;\n\n        #pragma omp target teams num_teams(num_work_groups) thread_limit(local_wsize)\n        {\n          T lmem[local_wsize];\n          #pragma omp parallel\n          {\n            #include \"sort_reduce.h\"\n          }\n        }\n\n#ifdef DEBUG\n#pragma omp target update from (isums[0:num_work_groups * num_digits])\n        for (int i = 0; i < num_work_groups * num_digits; i++)\n          printf(\"reduce: %d: %d\\n\", shift, isums[i]);\n#endif\n\n        #pragma omp target teams num_teams(num_work_groups) thread_limit(local_wsize)\n        {\n          T lmem[local_wsize*2];\n          T s_seed;\n          #pragma omp parallel\n          {\n            #include \"sort_top_scan.h\"\n          }\n        }\n\n#ifdef DEBUG\n#pragma omp target update from (isums[0:num_work_groups * num_digits])\n        for (int i = 0; i < num_work_groups * num_digits; i++)\n          printf(\"top-scan: %d: %d\\n\", shift, isums[i]);\n#endif\n\n        #pragma omp target teams num_teams(num_work_groups) thread_limit(local_wsize)\n        {\n          T lmem[local_wsize*2];\n          T l_scanned_seeds[16];\n          T l_block_counts[16];\n          #pragma omp parallel\n          {\n            #include \"sort_bottom_scan.h\"\n          }\n        }\n      }\n\n      auto end = std::chrono::steady_clock::now();\n      time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    }  \n\n\n    printf(\"Average elapsed time per pass %lf (s)\\n\", time * 1e-9 / passes);\n  }\n\n  verifySort(odata, size);\n\n  free(idata);\n  free(isums);\n  free(odata);\n  return 0;\n}\n"}}
{"kernel_name": "sort", "kernel_api": "serial", "code": {"main.cpp": "#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <chrono>\n\ntypedef unsigned int T;\n\ntemplate<typename T>\nstruct vec4 {\n  T x;\n  T y;\n  T z;\n  T w;\n};\n\nvoid verifySort(const T *keys, const size_t size)\n{\n  bool passed = true;\n  for (size_t i = 0; i < size - 1; i++)\n  {\n    if (keys[i] > keys[i + 1])\n    {\n      passed = false;\n#ifdef VERBOSE_OUTPUT\n      std::cout << \"Idx: \" << i;\n      std::cout << \" Key: \" << keys[i] << \"\\n\";\n#endif\n      break;\n    }\n  }\n  if (passed)\n    std::cout << \"PASS\" << std::endl;\n  else\n    std::cout << \"FAIL\" << std::endl;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) \n  {\n    printf(\"Usage: %s <problem size> <number of passes>\\n.\", argv[0]);\n    return -1;\n  }\n\n  int select = atoi(argv[1]);\n  int passes = atoi(argv[2]);\n\n  \n\n  int probSizes[4] = { 1, 8, 32, 64 };\n  size_t size = probSizes[select];\n\n  \n\n  size = (size * 1024 * 1024) / sizeof(T);\n\n  \n\n  unsigned int bytes = size * sizeof(T);\n\n  T* idata = (T*) malloc (bytes); \n  T* odata = (T*) malloc (bytes); \n\n  \n\n  std::cout << \"Initializing host memory.\" << std::endl;\n  for (int i = 0; i < size; i++)\n  {\n    idata[i] = i % 16; \n\n    odata[i] = size - i;\n  }\n\n  std::cout << \"Running benchmark with input array length \" << size << std::endl;\n\n  \n\n  const size_t local_wsize  = 256;\n  \n\n  const size_t global_wsize = 16384; \n  \n\n  const size_t num_work_groups = global_wsize / local_wsize;\n\n  \n\n  const int radix_width = 4; \n\n  \n\n  const int num_digits = 16;\n\n  T* isums = (T*) malloc (sizeof(T) * num_work_groups * num_digits);\n\n    {\n    double time = 0.0;\n\n    for (int k = 0; k < passes; k++)\n    {\n      auto start = std::chrono::steady_clock::now();\n\n      \n\n      for (unsigned int shift = 0; shift < sizeof(T)*8; shift += radix_width)\n      {\n        \n\n\n        \n\n        \n\n        \n\n\n        \n\n        \n\n        bool even = ((shift / radix_width) % 2 == 0) ? true : false;\n\n        T *in = even ? idata : odata;\n        T *out = even ? odata : idata;\n\n                {\n          T lmem[local_wsize];\n                    {\n            #include \"sort_reduce.h\"\n          }\n        }\n\n#ifdef DEBUG\n        for (int i = 0; i < num_work_groups * num_digits; i++)\n          printf(\"reduce: %d: %d\\n\", shift, isums[i]);\n#endif\n\n                {\n          T lmem[local_wsize*2];\n          T s_seed;\n                    {\n            #include \"sort_top_scan.h\"\n          }\n        }\n\n#ifdef DEBUG\n        for (int i = 0; i < num_work_groups * num_digits; i++)\n          printf(\"top-scan: %d: %d\\n\", shift, isums[i]);\n#endif\n\n                {\n          T lmem[local_wsize*2];\n          T l_scanned_seeds[16];\n          T l_block_counts[16];\n                    {\n            #include \"sort_bottom_scan.h\"\n          }\n        }\n      }\n\n      auto end = std::chrono::steady_clock::now();\n      time += std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    }  \n\n\n    printf(\"Average elapsed time per pass %lf (s)\\n\", time * 1e-9 / passes);\n  }\n\n  verifySort(odata, size);\n\n  free(idata);\n  free(isums);\n  free(odata);\n  return 0;\n}"}}
