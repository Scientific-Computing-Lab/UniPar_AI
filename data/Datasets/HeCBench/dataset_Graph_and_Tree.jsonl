{"kernel_name": "floydwarshall", "kernel_api": "cuda", "code": {"main.cu": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <chrono>\n#include <cuda.h>\n\n#define MAXDISTANCE    (200)\n\n\n\nunsigned int minimum(unsigned int a, unsigned int b) \n{\n  return (b < a) ? b : a;\n}\n\n\n\nvoid floydWarshallCPUReference(unsigned int * pathDistanceMatrix,\n    unsigned int * pathMatrix, unsigned int numNodes)\n{\n  unsigned int distanceYtoX, distanceYtoK, distanceKtoX, indirectDistance;\n\n  \n\n  unsigned int width = numNodes;\n  unsigned int yXwidth;\n\n  \n\n  for(unsigned int k = 0; k < numNodes; ++k)\n  {\n    for(unsigned int y = 0; y < numNodes; ++y)\n    {\n      yXwidth =  y*numNodes;\n      for(unsigned int x = 0; x < numNodes; ++x)\n      {\n        distanceYtoX = pathDistanceMatrix[yXwidth + x];\n        distanceYtoK = pathDistanceMatrix[yXwidth + k];\n        distanceKtoX = pathDistanceMatrix[k * width + x];\n\n        indirectDistance = distanceYtoK + distanceKtoX;\n\n        if(indirectDistance < distanceYtoX)\n        {\n          pathDistanceMatrix[yXwidth + x] = indirectDistance;\n          pathMatrix[yXwidth + x]         = k;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n__global__ void floydWarshallPass(\n    unsigned int *__restrict__ pathDistanceBuffer,\n    unsigned int *__restrict__ pathBuffer,\n    const unsigned int numNodes,\n    const unsigned int pass)\n{\n  int xValue = threadIdx.x + blockIdx.x * blockDim.x;\n  int yValue = threadIdx.y + blockIdx.y * blockDim.y;\n\n  int k = pass;\n  int oldWeight = pathDistanceBuffer[yValue * numNodes + xValue];\n  int tempWeight = pathDistanceBuffer[yValue * numNodes + k] + \n                   pathDistanceBuffer[k * numNodes + xValue];\n\n  if (tempWeight < oldWeight)\n  {\n    pathDistanceBuffer[yValue * numNodes + xValue] = tempWeight;\n    pathBuffer[yValue * numNodes + xValue] = k;\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 4) {\n    printf(\"Usage: %s <number of nodes> <iterations> <block size>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  unsigned int numNodes = atoi(argv[1]);\n  unsigned int numIterations = atoi(argv[2]);\n  unsigned int blockSize = atoi(argv[3]);\n\n  \n\n  if(numNodes % blockSize != 0) {\n    numNodes = (numNodes / blockSize + 1) * blockSize;\n  }\n\n  \n\n  unsigned int* pathMatrix = NULL;\n  unsigned int* pathDistanceMatrix = NULL;\n  unsigned int* verificationPathDistanceMatrix = NULL;\n  unsigned int* verificationPathMatrix = NULL;\n  unsigned int matrixSizeBytes;\n\n  matrixSizeBytes = numNodes * numNodes * sizeof(unsigned int);\n  pathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathDistanceMatrix != NULL);\n\n  pathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathMatrix != NULL) ;\n\n  \n\n  srand(2);\n  for(unsigned int i = 0; i < numNodes; i++)\n    for(unsigned int j = 0; j < numNodes; j++)\n    {\n      int index = i*numNodes + j;\n      pathDistanceMatrix[index] = rand() % (MAXDISTANCE + 1);\n    }\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    unsigned int iXWidth = i * numNodes;\n    pathDistanceMatrix[iXWidth + i] = 0;\n  }\n\n  \n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    for(unsigned int j = 0; j < i; ++j)\n    {\n      pathMatrix[i * numNodes + j] = i;\n      pathMatrix[j * numNodes + i] = j;\n    }\n    pathMatrix[i * numNodes + i] = i;\n  }\n\n  verificationPathDistanceMatrix = (unsigned int *) malloc(numNodes * numNodes * sizeof(int));\n  assert (verificationPathDistanceMatrix != NULL);\n\n  verificationPathMatrix = (unsigned int *) malloc(numNodes * numNodes * sizeof(int));\n  assert(verificationPathMatrix != NULL);\n\n  memcpy(verificationPathDistanceMatrix, pathDistanceMatrix,\n      numNodes * numNodes * sizeof(int));\n  memcpy(verificationPathMatrix, pathMatrix, numNodes*numNodes*sizeof(int));\n\n  unsigned int numPasses = numNodes;\n\n  unsigned int globalThreads[2] = {numNodes, numNodes};\n  unsigned int localThreads[2] = {blockSize, blockSize};\n\n  if((unsigned int)(localThreads[0] * localThreads[0]) >256)\n  {\n    blockSize = 16;\n    localThreads[0] = blockSize;\n    localThreads[1] = blockSize;\n  }\n\n  dim3 grids( globalThreads[0]/localThreads[0], globalThreads[1]/localThreads[1]);\n  dim3 threads (localThreads[0],localThreads[1]);\n\n  unsigned int *pathDistanceBuffer, *pathBuffer;\n  cudaMalloc((void**)&pathDistanceBuffer, matrixSizeBytes);\n  cudaMalloc((void**)&pathBuffer, matrixSizeBytes);\n\n  float total_time = 0.f;\n\n  \n\n  \n\n  for (unsigned int n = 0; n < numIterations; n++) {\n    \n\n\n    cudaMemcpy(pathDistanceBuffer, pathDistanceMatrix, matrixSizeBytes, cudaMemcpyHostToDevice);\n\n    cudaDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    for(unsigned int i = 0; i < numPasses; i++)\n    {\n      floydWarshallPass <<< grids, threads >>> (pathDistanceBuffer,pathBuffer,numNodes,i);\n    }\n\n    cudaDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n  }\n\n  printf(\"Average kernel execution time %f (s)\\n\", (total_time * 1e-9f) / numIterations);\n\n  cudaMemcpy(pathDistanceMatrix, pathDistanceBuffer, matrixSizeBytes, cudaMemcpyDeviceToHost);\n  cudaFree(pathDistanceBuffer);\n  cudaFree(pathBuffer);\n\n  \n\n  floydWarshallCPUReference(verificationPathDistanceMatrix, verificationPathMatrix, numNodes);\n  if(memcmp(pathDistanceMatrix, verificationPathDistanceMatrix, matrixSizeBytes) == 0)\n  {\n    printf(\"PASS\\n\");\n  }\n  else\n  {\n    printf(\"FAIL\\n\");\n    if (numNodes <= 8) \n    {\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"host: %u \", verificationPathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"device: %u \", pathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n    }\n  }\n\n  free(pathDistanceMatrix);\n  free(pathMatrix);\n  free(verificationPathDistanceMatrix);\n  free(verificationPathMatrix);\n  return 0;\n}\n"}}
{"kernel_name": "floydwarshall", "kernel_api": "hip", "code": {"main.cu": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <chrono>\n#include <hip/hip_runtime.h>\n\n#define MAXDISTANCE    (200)\n\n\n\nunsigned int minimum(unsigned int a, unsigned int b) \n{\n  return (b < a) ? b : a;\n}\n\n\n\nvoid floydWarshallCPUReference(unsigned int * pathDistanceMatrix,\n    unsigned int * pathMatrix, unsigned int numNodes)\n{\n  unsigned int distanceYtoX, distanceYtoK, distanceKtoX, indirectDistance;\n\n  \n\n  unsigned int width = numNodes;\n  unsigned int yXwidth;\n\n  \n\n  for(unsigned int k = 0; k < numNodes; ++k)\n  {\n    for(unsigned int y = 0; y < numNodes; ++y)\n    {\n      yXwidth =  y*numNodes;\n      for(unsigned int x = 0; x < numNodes; ++x)\n      {\n        distanceYtoX = pathDistanceMatrix[yXwidth + x];\n        distanceYtoK = pathDistanceMatrix[yXwidth + k];\n        distanceKtoX = pathDistanceMatrix[k * width + x];\n\n        indirectDistance = distanceYtoK + distanceKtoX;\n\n        if(indirectDistance < distanceYtoX)\n        {\n          pathDistanceMatrix[yXwidth + x] = indirectDistance;\n          pathMatrix[yXwidth + x]         = k;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n__global__ void floydWarshallPass(\n    unsigned int *__restrict__ pathDistanceBuffer,\n    unsigned int *__restrict__ pathBuffer,\n    const unsigned int numNodes,\n    const unsigned int pass)\n{\n  int xValue = threadIdx.x + blockIdx.x * blockDim.x;\n  int yValue = threadIdx.y + blockIdx.y * blockDim.y;\n\n  int k = pass;\n  int oldWeight = pathDistanceBuffer[yValue * numNodes + xValue];\n  int tempWeight = pathDistanceBuffer[yValue * numNodes + k] + \n                   pathDistanceBuffer[k * numNodes + xValue];\n\n  if (tempWeight < oldWeight)\n  {\n    pathDistanceBuffer[yValue * numNodes + xValue] = tempWeight;\n    pathBuffer[yValue * numNodes + xValue] = k;\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 4) {\n    printf(\"Usage: %s <number of nodes> <iterations> <block size>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  unsigned int numNodes = atoi(argv[1]);\n  unsigned int numIterations = atoi(argv[2]);\n  unsigned int blockSize = atoi(argv[3]);\n\n  \n\n  if(numNodes % blockSize != 0) {\n    numNodes = (numNodes / blockSize + 1) * blockSize;\n  }\n\n  \n\n  unsigned int* pathMatrix = NULL;\n  unsigned int* pathDistanceMatrix = NULL;\n  unsigned int* verificationPathDistanceMatrix = NULL;\n  unsigned int* verificationPathMatrix = NULL;\n  unsigned int matrixSizeBytes;\n\n  matrixSizeBytes = numNodes * numNodes * sizeof(unsigned int);\n  pathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathDistanceMatrix != NULL);\n\n  pathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathMatrix != NULL) ;\n\n  \n\n  srand(2);\n  for(unsigned int i = 0; i < numNodes; i++)\n    for(unsigned int j = 0; j < numNodes; j++)\n    {\n      int index = i*numNodes + j;\n      pathDistanceMatrix[index] = rand() % (MAXDISTANCE + 1);\n    }\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    unsigned int iXWidth = i * numNodes;\n    pathDistanceMatrix[iXWidth + i] = 0;\n  }\n\n  \n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    for(unsigned int j = 0; j < i; ++j)\n    {\n      pathMatrix[i * numNodes + j] = i;\n      pathMatrix[j * numNodes + i] = j;\n    }\n    pathMatrix[i * numNodes + i] = i;\n  }\n\n  verificationPathDistanceMatrix = (unsigned int *) malloc(numNodes * numNodes * sizeof(int));\n  assert (verificationPathDistanceMatrix != NULL);\n\n  verificationPathMatrix = (unsigned int *) malloc(numNodes * numNodes * sizeof(int));\n  assert(verificationPathMatrix != NULL);\n\n  memcpy(verificationPathDistanceMatrix, pathDistanceMatrix,\n      numNodes * numNodes * sizeof(int));\n  memcpy(verificationPathMatrix, pathMatrix, numNodes*numNodes*sizeof(int));\n\n  unsigned int numPasses = numNodes;\n\n  unsigned int globalThreads[2] = {numNodes, numNodes};\n  unsigned int localThreads[2] = {blockSize, blockSize};\n\n  if((unsigned int)(localThreads[0] * localThreads[0]) >256)\n  {\n    blockSize = 16;\n    localThreads[0] = blockSize;\n    localThreads[1] = blockSize;\n  }\n\n  dim3 grids( globalThreads[0]/localThreads[0], globalThreads[1]/localThreads[1]);\n  dim3 threads (localThreads[0],localThreads[1]);\n\n  unsigned int *pathDistanceBuffer, *pathBuffer;\n  hipMalloc((void**)&pathDistanceBuffer, matrixSizeBytes);\n  hipMalloc((void**)&pathBuffer, matrixSizeBytes);\n\n  float total_time = 0.f;\n\n  \n\n  \n\n  for (unsigned int n = 0; n < numIterations; n++) {\n    \n\n\n    hipMemcpy(pathDistanceBuffer, pathDistanceMatrix, matrixSizeBytes, hipMemcpyHostToDevice);\n\n    hipDeviceSynchronize();\n    auto start = std::chrono::steady_clock::now();\n\n    for(unsigned int i = 0; i < numPasses; i++)\n    {\n      hipLaunchKernelGGL(floydWarshallPass, grids, threads , 0, 0, pathDistanceBuffer,pathBuffer,numNodes,i);\n    }\n\n    hipDeviceSynchronize();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n  }\n\n  printf(\"Average kernel execution time %f (s)\\n\", (total_time * 1e-9f) / numIterations);\n\n  hipMemcpy(pathDistanceMatrix, pathDistanceBuffer, matrixSizeBytes, hipMemcpyDeviceToHost);\n  hipFree(pathDistanceBuffer);\n  hipFree(pathBuffer);\n\n  \n\n  floydWarshallCPUReference(verificationPathDistanceMatrix, verificationPathMatrix, numNodes);\n  if(memcmp(pathDistanceMatrix, verificationPathDistanceMatrix, matrixSizeBytes) == 0)\n  {\n    printf(\"PASS\\n\");\n  }\n  else\n  {\n    printf(\"FAIL\\n\");\n    if (numNodes <= 8) \n    {\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"host: %u \", verificationPathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"device: %u \", pathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n    }\n  }\n\n  free(pathDistanceMatrix);\n  free(pathMatrix);\n  free(verificationPathDistanceMatrix);\n  free(verificationPathMatrix);\n  return 0;\n}\n"}}
{"kernel_name": "floydwarshall", "kernel_api": "omp", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <chrono>\n#include <omp.h>\n\n#define MAXDISTANCE    (200)\n\n\n\nunsigned int minimum(unsigned int a, unsigned int b) \n{\n  return (b < a) ? b : a;\n}\n\n\n\nvoid floydWarshallCPUReference(unsigned int * pathDistanceMatrix,\n    unsigned int * pathMatrix, unsigned int numNodes)\n{\n  unsigned int distanceYtoX, distanceYtoK, distanceKtoX, indirectDistance;\n\n  \n\n  unsigned int width = numNodes;\n  unsigned int yXwidth;\n\n  \n\n\n  for(unsigned int k = 0; k < numNodes; ++k)\n  {\n    for(unsigned int y = 0; y < numNodes; ++y)\n    {\n      yXwidth =  y*numNodes;\n      for(unsigned int x = 0; x < numNodes; ++x)\n      {\n        distanceYtoX = pathDistanceMatrix[yXwidth + x];\n        distanceYtoK = pathDistanceMatrix[yXwidth + k];\n        distanceKtoX = pathDistanceMatrix[k * width + x];\n\n        indirectDistance = distanceYtoK + distanceKtoX;\n\n        if(indirectDistance < distanceYtoX)\n        {\n          pathDistanceMatrix[yXwidth + x] = indirectDistance;\n          pathMatrix[yXwidth + x]         = k;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nint main(int argc, char** argv) {\n  if (argc != 4) {\n    printf(\"Usage: %s <number of nodes> <iterations> <block size>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  unsigned int numNodes = atoi(argv[1]);\n  unsigned int numIterations = atoi(argv[2]);\n  unsigned int blockSize = atoi(argv[3]);\n\n  \n\n  if(numNodes % blockSize != 0) {\n    numNodes = (numNodes / blockSize + 1) * blockSize;\n  }\n\n  \n\n  unsigned int* pathMatrix = NULL;\n  unsigned int* pathDistanceMatrix = NULL;\n  unsigned int* verificationPathDistanceMatrix = NULL;\n  unsigned int* verificationPathMatrix = NULL;\n  unsigned int matrixSize;\n  unsigned int matrixSizeBytes;\n\n  matrixSize = numNodes * numNodes;\n  matrixSizeBytes = numNodes * numNodes * sizeof(unsigned int);\n  pathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathDistanceMatrix != NULL) ;\n\n  pathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathMatrix != NULL) ;\n\n  \n\n  srand(2);\n  for(unsigned int i = 0; i < numNodes; i++)\n    for(unsigned int j = 0; j < numNodes; j++)\n    {\n      int index = i*numNodes + j;\n      pathDistanceMatrix[index] = rand() % (MAXDISTANCE + 1);\n    }\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    unsigned int iXWidth = i * numNodes;\n    pathDistanceMatrix[iXWidth + i] = 0;\n  }\n\n  \n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    for(unsigned int j = 0; j < i; ++j)\n    {\n      pathMatrix[i * numNodes + j] = i;\n      pathMatrix[j * numNodes + i] = j;\n    }\n    pathMatrix[i * numNodes + i] = i;\n  }\n\n  verificationPathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (verificationPathDistanceMatrix != NULL);\n\n  verificationPathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert(verificationPathMatrix != NULL);\n\n  memcpy(verificationPathDistanceMatrix, pathDistanceMatrix, matrixSizeBytes);\n  memcpy(verificationPathMatrix, pathMatrix, matrixSizeBytes);\n\n  unsigned int numPasses = numNodes;\n\n  #pragma omp target data map(alloc: pathDistanceMatrix[0:matrixSize], \\\n                                     pathMatrix[0:matrixSize])\n  {\n    float total_time = 0.f;\n\n    for (unsigned int n = 0; n < numIterations; n++) {\n      \n\n\n      #pragma omp target update to (pathDistanceMatrix[0:matrixSize]) \n\n      auto start = std::chrono::steady_clock::now();\n\n      for(unsigned int k = 0; k < numPasses; k++)\n      {\n        #pragma omp target teams distribute parallel for collapse(2) \\\n        thread_limit (blockSize*blockSize) nowait\n        for(unsigned int y = 0; y < numNodes; ++y)\n        {\n          for(unsigned int x = 0; x < numNodes; ++x)\n          {\n            unsigned int distanceYtoX = pathDistanceMatrix[y*numNodes + x];\n            unsigned int distanceYtoK = pathDistanceMatrix[y*numNodes + k];\n            unsigned int distanceKtoX = pathDistanceMatrix[k*numNodes + x];\n            unsigned int indirectDistance = distanceYtoK + distanceKtoX;\n\n            if(indirectDistance < distanceYtoX)\n            {\n              pathDistanceMatrix[y*numNodes + x] = indirectDistance;\n              pathMatrix[y*numNodes + x]         = k;\n            }\n          }\n        }\n      }\n      #pragma omp taskwait\n\n      auto end = std::chrono::steady_clock::now();\n      auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n      total_time += time;\n    }\n\n    printf(\"Average kernel execution time %f (s)\\n\", (total_time * 1e-9f) / numIterations);\n\n    #pragma omp target update from (pathDistanceMatrix[0:matrixSize]) \n  }\n\n  \n\n  floydWarshallCPUReference(verificationPathDistanceMatrix,\n      verificationPathMatrix, numNodes);\n  if(memcmp(pathDistanceMatrix, verificationPathDistanceMatrix,\n        numNodes*numNodes*sizeof(unsigned int)) == 0)\n  {\n    printf(\"PASS\\n\");\n  }\n  else\n  {\n    printf(\"FAIL\\n\");\n    if (numNodes <= 8) \n    {\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"host: %u \", verificationPathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"device: %u \", pathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n    }\n  }\n\n  free(pathDistanceMatrix);\n  free(pathMatrix);\n  free(verificationPathDistanceMatrix);\n  free(verificationPathMatrix);\n  return 0;\n}\n"}}
{"kernel_name": "floydwarshall", "kernel_api": "serial", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <chrono>\n\n#define MAXDISTANCE    (200)\n\n\n\nunsigned int minimum(unsigned int a, unsigned int b) \n{\n  return (b < a) ? b : a;\n}\n\n\n\nvoid floydWarshallCPUReference(unsigned int * pathDistanceMatrix,\n    unsigned int * pathMatrix, unsigned int numNodes)\n{\n  unsigned int distanceYtoX, distanceYtoK, distanceKtoX, indirectDistance;\n\n  \n\n  unsigned int width = numNodes;\n  unsigned int yXwidth;\n\n  \n\n\n  for(unsigned int k = 0; k < numNodes; ++k)\n  {\n    for(unsigned int y = 0; y < numNodes; ++y)\n    {\n      yXwidth =  y*numNodes;\n      for(unsigned int x = 0; x < numNodes; ++x)\n      {\n        distanceYtoX = pathDistanceMatrix[yXwidth + x];\n        distanceYtoK = pathDistanceMatrix[yXwidth + k];\n        distanceKtoX = pathDistanceMatrix[k * width + x];\n\n        indirectDistance = distanceYtoK + distanceKtoX;\n\n        if(indirectDistance < distanceYtoX)\n        {\n          pathDistanceMatrix[yXwidth + x] = indirectDistance;\n          pathMatrix[yXwidth + x]         = k;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nint main(int argc, char** argv) {\n  if (argc != 4) {\n    printf(\"Usage: %s <number of nodes> <iterations> <block size>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  unsigned int numNodes = atoi(argv[1]);\n  unsigned int numIterations = atoi(argv[2]);\n  unsigned int blockSize = atoi(argv[3]);\n\n  \n\n  if(numNodes % blockSize != 0) {\n    numNodes = (numNodes / blockSize + 1) * blockSize;\n  }\n\n  \n\n  unsigned int* pathMatrix = NULL;\n  unsigned int* pathDistanceMatrix = NULL;\n  unsigned int* verificationPathDistanceMatrix = NULL;\n  unsigned int* verificationPathMatrix = NULL;\n  unsigned int matrixSize;\n  unsigned int matrixSizeBytes;\n\n  matrixSize = numNodes * numNodes;\n  matrixSizeBytes = numNodes * numNodes * sizeof(unsigned int);\n  pathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathDistanceMatrix != NULL) ;\n\n  pathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathMatrix != NULL) ;\n\n  \n\n  srand(2);\n  for(unsigned int i = 0; i < numNodes; i++)\n    for(unsigned int j = 0; j < numNodes; j++)\n    {\n      int index = i*numNodes + j;\n      pathDistanceMatrix[index] = rand() % (MAXDISTANCE + 1);\n    }\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    unsigned int iXWidth = i * numNodes;\n    pathDistanceMatrix[iXWidth + i] = 0;\n  }\n\n  \n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    for(unsigned int j = 0; j < i; ++j)\n    {\n      pathMatrix[i * numNodes + j] = i;\n      pathMatrix[j * numNodes + i] = j;\n    }\n    pathMatrix[i * numNodes + i] = i;\n  }\n\n  verificationPathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (verificationPathDistanceMatrix != NULL);\n\n  verificationPathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert(verificationPathMatrix != NULL);\n\n  memcpy(verificationPathDistanceMatrix, pathDistanceMatrix, matrixSizeBytes);\n  memcpy(verificationPathMatrix, pathMatrix, matrixSizeBytes);\n\n  unsigned int numPasses = numNodes;\n\n    {\n    float total_time = 0.f;\n\n    for (unsigned int n = 0; n < numIterations; n++) {\n      \n\n\n      \n      auto start = std::chrono::steady_clock::now();\n\n      for(unsigned int k = 0; k < numPasses; k++)\n      {\n                for(unsigned int y = 0; y < numNodes; ++y)\n        {\n          for(unsigned int x = 0; x < numNodes; ++x)\n          {\n            unsigned int distanceYtoX = pathDistanceMatrix[y*numNodes + x];\n            unsigned int distanceYtoK = pathDistanceMatrix[y*numNodes + k];\n            unsigned int distanceKtoX = pathDistanceMatrix[k*numNodes + x];\n            unsigned int indirectDistance = distanceYtoK + distanceKtoX;\n\n            if(indirectDistance < distanceYtoX)\n            {\n              pathDistanceMatrix[y*numNodes + x] = indirectDistance;\n              pathMatrix[y*numNodes + x]         = k;\n            }\n          }\n        }\n      }\n      \n      auto end = std::chrono::steady_clock::now();\n      auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n      total_time += time;\n    }\n\n    printf(\"Average kernel execution time %f (s)\\n\", (total_time * 1e-9f) / numIterations);\n\n      }\n\n  \n\n  floydWarshallCPUReference(verificationPathDistanceMatrix,\n      verificationPathMatrix, numNodes);\n  if(memcmp(pathDistanceMatrix, verificationPathDistanceMatrix,\n        numNodes*numNodes*sizeof(unsigned int)) == 0)\n  {\n    printf(\"PASS\\n\");\n  }\n  else\n  {\n    printf(\"FAIL\\n\");\n    if (numNodes <= 8) \n    {\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"host: %u \", verificationPathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"device: %u \", pathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n    }\n  }\n\n  free(pathDistanceMatrix);\n  free(pathMatrix);\n  free(verificationPathDistanceMatrix);\n  free(verificationPathMatrix);\n  return 0;\n}"}}
{"kernel_name": "floydwarshall", "kernel_api": "sycl", "code": {"main.cpp": "\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <chrono>\n#include <sycl/sycl.hpp>\n\n#define MAXDISTANCE    (200)\n\n\n\nunsigned int minimum(unsigned int a, unsigned int b) \n{\n  return (b < a) ? b : a;\n}\n\n\n\nvoid floydWarshallCPUReference(unsigned int * pathDistanceMatrix,\n    unsigned int * pathMatrix, unsigned int numNodes)\n{\n  unsigned int distanceYtoX, distanceYtoK, distanceKtoX, indirectDistance;\n\n  \n\n  unsigned int width = numNodes;\n  unsigned int yXwidth;\n\n  \n\n  for(unsigned int k = 0; k < numNodes; ++k)\n  {\n    for(unsigned int y = 0; y < numNodes; ++y)\n    {\n      yXwidth =  y*numNodes;\n      for(unsigned int x = 0; x < numNodes; ++x)\n      {\n        distanceYtoX = pathDistanceMatrix[yXwidth + x];\n        distanceYtoK = pathDistanceMatrix[yXwidth + k];\n        distanceKtoX = pathDistanceMatrix[k * width + x];\n\n        indirectDistance = distanceYtoK + distanceKtoX;\n\n        if(indirectDistance < distanceYtoX)\n        {\n          pathDistanceMatrix[yXwidth + x] = indirectDistance;\n          pathMatrix[yXwidth + x]         = k;\n        }\n      }\n    }\n  }\n}\n\n\n\n\n\n\nint main(int argc, char** argv) {\n  if (argc != 4) {\n    printf(\"Usage: %s <number of nodes> <iterations> <block size>\\n\", argv[0]);\n    return 1;\n  }\n  \n\n  unsigned int numNodes = atoi(argv[1]);\n  unsigned int numIterations = atoi(argv[2]);\n  unsigned int blockSize = atoi(argv[3]);\n\n  \n\n  if(numNodes % blockSize != 0) {\n    numNodes = (numNodes / blockSize + 1) * blockSize;\n  }\n\n  \n\n  unsigned int* pathMatrix = NULL;\n  unsigned int* pathDistanceMatrix = NULL;\n  unsigned int* verificationPathDistanceMatrix = NULL;\n  unsigned int* verificationPathMatrix = NULL;\n  unsigned int matrixSize;\n  unsigned int matrixSizeBytes;\n\n  matrixSize = numNodes * numNodes;\n  matrixSizeBytes = numNodes * numNodes * sizeof(unsigned int);\n  pathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathDistanceMatrix != NULL) ;\n\n  pathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (pathMatrix != NULL) ;\n\n  \n\n  srand(2);\n  for(unsigned int i = 0; i < numNodes; i++)\n    for(unsigned int j = 0; j < numNodes; j++)\n    {\n      int index = i*numNodes + j;\n      pathDistanceMatrix[index] = rand() % (MAXDISTANCE + 1);\n    }\n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    unsigned int iXWidth = i * numNodes;\n    pathDistanceMatrix[iXWidth + i] = 0;\n  }\n\n  \n\n  for(unsigned int i = 0; i < numNodes; ++i)\n  {\n    for(unsigned int j = 0; j < i; ++j)\n    {\n      pathMatrix[i * numNodes + j] = i;\n      pathMatrix[j * numNodes + i] = j;\n    }\n    pathMatrix[i * numNodes + i] = i;\n  }\n\n  verificationPathDistanceMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert (verificationPathDistanceMatrix != NULL);\n\n  verificationPathMatrix = (unsigned int *) malloc(matrixSizeBytes);\n  assert(verificationPathMatrix != NULL);\n\n  memcpy(verificationPathDistanceMatrix, pathDistanceMatrix, matrixSizeBytes);\n  memcpy(verificationPathMatrix, pathMatrix, matrixSizeBytes);\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  unsigned int numPasses = numNodes;\n\n  unsigned int globalThreads[2] = {numNodes, numNodes};\n  unsigned int localThreads[2] = {blockSize, blockSize};\n\n  if((unsigned int)(localThreads[0] * localThreads[0]) >256)\n  {\n    blockSize = 16;\n    localThreads[0] = blockSize;\n    localThreads[1] = blockSize;\n  }\n\n  sycl::range<2> gws (globalThreads[0], globalThreads[1]);\n  sycl::range<2> lws (localThreads[0], localThreads[1]);\n\n  unsigned int *pathDistanceBuffer = sycl::malloc_device<unsigned int>(matrixSize, q);\n  unsigned int *pathBuffer = sycl::malloc_device<unsigned int>(matrixSize, q);\n\n  float total_time = 0.f;\n\n  for (unsigned int n = 0; n < numIterations; n++) {\n    \n\n\n    q.memcpy(pathDistanceBuffer, pathDistanceMatrix, matrixSizeBytes);\n\n    q.wait();\n    auto start = std::chrono::steady_clock::now();\n\n    for(unsigned int k = 0; k < numPasses; k++)\n    {\n      q.submit([&] (sycl::handler &cgh) {\n        cgh.parallel_for<class path_distance>(\n          sycl::nd_range<2>(gws, lws), [=] (sycl::nd_item<2> item) {\n          int xValue = item.get_global_id(1);\n          int yValue = item.get_global_id(0); \n\n          int oldWeight = pathDistanceBuffer[yValue * numNodes + xValue];\n          int tempWeight = pathDistanceBuffer[yValue * numNodes + k] + \n                           pathDistanceBuffer[k * numNodes + xValue];\n\n          if (tempWeight < oldWeight)\n          {\n              pathDistanceBuffer[yValue * numNodes + xValue] = tempWeight;\n              pathBuffer[yValue * numNodes + xValue] = k;\n          }\n        });\n      });\n    }\n\n    q.wait();\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    total_time += time;\n  }\n\n  printf(\"Average kernel execution time %f (s)\\n\", (total_time * 1e-9f) / numIterations);\n\n  q.memcpy(pathDistanceMatrix, pathDistanceBuffer, matrixSizeBytes).wait();\n  sycl::free(pathDistanceBuffer, q);\n  sycl::free(pathBuffer, q);\n\n  \n\n  floydWarshallCPUReference(verificationPathDistanceMatrix,\n      verificationPathMatrix, numNodes);\n  if(memcmp(pathDistanceMatrix, verificationPathDistanceMatrix,\n        numNodes*numNodes*sizeof(unsigned int)) == 0)\n  {\n    printf(\"PASS\\n\");\n  }\n  else\n  {\n    printf(\"FAIL\\n\");\n    if (numNodes <= 8) \n    {\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"host: %u \", verificationPathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n      for (unsigned int i = 0; i < numNodes; i++) {\n        for (unsigned int j = 0; j < numNodes; j++)\n          printf(\"device: %u \", pathDistanceMatrix[i*numNodes+j]);\n        printf(\"\\n\");\n      }\n    }\n  }\n\n  free(pathDistanceMatrix);\n  free(pathMatrix);\n  free(verificationPathDistanceMatrix);\n  free(verificationPathMatrix);\n  return 0;\n}\n"}}
{"kernel_name": "gc", "kernel_api": "cuda", "code": {"main.cu": "\n\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <chrono>\n#include <cuda.h>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 512;\nstatic const unsigned int Warp = 0xffffffff;\nstatic const int WS = 32;  \n\nstatic const int MSB = 1 << (WS - 1);\nstatic const int Mask = (1 << (WS / 2)) - 1;\n\n\n\n\nstatic __device__ unsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n__global__\nvoid init(const int nodes,\n    const int edges, \n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    int* const __restrict__ nlist2,\n    int* const __restrict__ posscol,\n    int* const __restrict__ posscol2,\n    int* const __restrict__ color,\n    int* const __restrict__ wl,\n    int* __restrict__ wlsize)\n{\n  const int lane = threadIdx.x % WS;\n  const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int threads = gridDim.x * ThreadsPerBlock;\n\n  int maxrange = -1;\n  for (int v = thread; __any_sync(Warp, v < nodes); v += threads) {\n    bool cond = false;\n    int beg, end, pos, degv, active;\n    if (v < nodes) {\n      beg = nidx[v];\n      end = nidx[v + 1];\n      degv = end - beg;\n      cond = (degv >= WS);\n      if (cond) {\n        wl[atomicAdd(wlsize, 1)] = v;\n      } else {\n        active = 0;\n        pos = beg;\n        for (int i = beg; i < end; i++) {\n          const int nei = nlist[i];\n          const int degn = nidx[nei + 1] - nidx[nei];\n          if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n            active |= (unsigned int)MSB >> (i - beg);\n            pos++;\n          }\n        }\n      }\n    }\n\n    int bal = __ballot_sync(Warp, cond);\n    while (bal != 0) {\n      const int who = __ffs(bal) - 1;\n      bal &= bal - 1;\n      const int wv = __shfl_sync(Warp, v, who);\n      const int wbeg = __shfl_sync(Warp, beg, who);\n      const int wend = __shfl_sync(Warp, end, who);\n      const int wdegv = wend - wbeg;\n      int wpos = wbeg;\n      for (int i = wbeg + lane; __any_sync(Warp, i < wend); i += WS) {\n        int wnei;\n        bool prio = false;\n        if (i < wend) {\n          wnei = nlist[i];\n          const int wdegn = nidx[wnei + 1] - nidx[wnei];\n          prio = ((wdegv < wdegn) || ((wdegv == wdegn) && (hash(wv) < hash(wnei))) || ((wdegv == wdegn) && (hash(wv) == hash(wnei)) && (wv < wnei)));\n        }\n        const int b = __ballot_sync(Warp, prio);\n        const int offs = __popc(b & ((1 << lane) - 1));\n        if (prio) nlist2[wpos + offs] = wnei;\n        wpos += __popc(b);\n      }\n      if (who == lane) pos = wpos;\n    }\n\n    if (v < nodes) {\n      const int range = pos - beg;\n      maxrange = max(maxrange, range);\n      color[v] = (cond || (range == 0)) ? (range << (WS / 2)) : active;\n      posscol[v] = (range >= WS) ? -1 : (MSB >> range);\n    }\n  }\n  \n\n\n  for (int i = thread; i < edges / WS + 1; i += threads) posscol2[i] = -1;\n}\n\n\n__global__\nvoid runLarge(const int nodes, \n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    int* const __restrict__ posscol,\n    int* const __restrict__ posscol2,\n    volatile int* const __restrict__ color,\n    const int* const __restrict__ wl,\n    const int* __restrict__ wlsize)\n{\n  const int stop = *wlsize;\n  if (stop != 0) {\n    const int lane = threadIdx.x % WS;\n    const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n    const int threads = gridDim.x * ThreadsPerBlock;\n    bool again;\n    do {\n      again = false;\n      for (int w = thread; __any_sync(Warp, w < stop); w += threads) {\n        bool shortcut, done, cond = false;\n        int v, data, range, beg, pcol;\n        if (w < stop) {\n          v = wl[w];\n          data = color[v];\n          range = data >> (WS / 2);\n          if (range > 0) {\n            beg = nidx[v];\n            pcol = posscol[v];\n            cond = true;\n          }\n        }\n\n        int bal = __ballot_sync(Warp, cond);\n        while (bal != 0) {\n          const int who = __ffs(bal) - 1;\n          bal &= bal - 1;\n          const int wdata = __shfl_sync(Warp, data, who);\n          const int wrange = wdata >> (WS / 2);\n          const int wbeg = __shfl_sync(Warp, beg, who);\n          const int wmincol = wdata & Mask;\n          const int wmaxcol = wmincol + wrange;\n          const int wend = wbeg + wmaxcol;\n          const int woffs = wbeg / WS;\n          int wpcol = __shfl_sync(Warp, pcol, who);\n\n          bool wshortcut = true;\n          bool wdone = true;\n          for (int i = wbeg + lane; __any_sync(Warp, i < wend); i += WS) {\n            int nei, neidata, neirange;\n            if (i < wend) {\n              nei = nlist[i];\n              neidata = color[nei];\n              neirange = neidata >> (WS / 2);\n              const bool neidone = (neirange == 0);\n              wdone &= neidone; \n\n              if (neidone) {\n                const int neicol = neidata;\n                if (neicol < WS) {\n                  wpcol &= ~((unsigned int)MSB >> neicol); \n\n                } else {\n                  if ((wmincol <= neicol) && (neicol < wmaxcol) && ((posscol2[woffs + neicol / WS] << (neicol % WS)) < 0)) {\n                    atomicAnd((int*)&posscol2[woffs + neicol / WS], ~((unsigned int)MSB >> (neicol % WS)));\n                  }\n                }\n              } else {\n                const int neimincol = neidata & Mask;\n                const int neimaxcol = neimincol + neirange;\n                if ((neimincol <= wmincol) && (neimaxcol >= wmincol)) wshortcut = false; \n\n              }\n            }\n          }\n          wshortcut = __all_sync(Warp, wshortcut);\n          wdone = __all_sync(Warp, wdone);\n          wpcol &= __shfl_xor_sync(Warp, wpcol, 1);\n          wpcol &= __shfl_xor_sync(Warp, wpcol, 2);\n          wpcol &= __shfl_xor_sync(Warp, wpcol, 4);\n          wpcol &= __shfl_xor_sync(Warp, wpcol, 8);\n          wpcol &= __shfl_xor_sync(Warp, wpcol, 16);\n          if (who == lane) pcol = wpcol;\n          if (who == lane) done = wdone;\n          if (who == lane) shortcut = wshortcut;\n        }\n\n        if (w < stop) {\n          if (range > 0) {\n            const int mincol = data & Mask;\n            int val = pcol, mc = 0;\n            if (pcol == 0) {\n              const int offs = beg / WS;\n              mc = max(1, mincol / WS);\n              while ((val = posscol2[offs + mc]) == 0) mc++;\n            }\n            int newmincol = mc * WS + __clz(val);\n            if (mincol != newmincol) shortcut = false;\n            if (shortcut || done) {\n              pcol = (newmincol < WS) ? ((unsigned int)MSB >> newmincol) : 0;\n            } else {\n              const int maxcol = mincol + range;\n              const int range = maxcol - newmincol;\n              newmincol = (range << (WS / 2)) | newmincol;\n              again = true;\n            }\n            posscol[v] = pcol;\n            color[v] = newmincol;\n          }\n        }\n      }\n    } while (__any_sync(Warp, again));\n  }\n}\n\n\n__global__ \nvoid runSmall(const int nodes,\n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    volatile int* const __restrict__ posscol,\n    int* const __restrict__ color)\n    \n\n{\n  const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int threads = gridDim.x * ThreadsPerBlock;\n\n  bool again;\n  do {\n    again = false;\n    for (int v = thread; v < nodes; v += threads) {\n      int pcol = posscol[v];\n      if (__popc(pcol) > 1) {\n        const int beg = nidx[v];\n        int active = color[v];\n        int allnei = 0;\n        int keep = active;\n        do {\n          const int old = active;\n          active &= active - 1;\n          const int curr = old ^ active;\n          const int i = beg + __clz(curr);\n          const int nei = nlist[i];\n          const int neipcol = posscol[nei];\n          allnei |= neipcol;\n          if ((pcol & neipcol) == 0) {\n            pcol &= pcol - 1;\n            keep ^= curr;\n          } else if (__popc(neipcol) == 1) {\n            pcol ^= neipcol;\n            keep ^= curr;\n          }\n        } while (active != 0);\n        if (keep != 0) {\n          const int best = (unsigned int)MSB >> __clz(pcol);\n          if ((best & ~allnei) != 0) {\n            pcol = best;\n            keep = 0;\n          }\n        }\n        again |= keep;\n        if (keep == 0) keep = __clz(pcol);\n        color[v] = keep;\n        posscol[v] = pcol;\n      }\n    }\n  } while (again);\n}\n\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-GC v1.2 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2020 Texas State University\\n\\n\");\n\n  if (argc != 3) {printf(\"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);  exit(-1);}\n  if (WS != 32) {printf(\"ERROR: warp size must be 32\\n\\n\");  exit(-1);}\n  if (WS != sizeof(int) * 8) {printf(\"ERROR: bits per word must match warp size\\n\\n\");  exit(-1);}\n  if ((ThreadsPerBlock < WS) || ((ThreadsPerBlock % WS) != 0)) {\n    printf(\"ERROR: threads per block must be a multiple of the warp size\\n\\n\");\n    exit(-1);\n  }\n  if ((ThreadsPerBlock & (ThreadsPerBlock - 1)) != 0) {\n    printf(\"ERROR: threads per block must be a power of two\\n\\n\");\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"input: %s\\n\", argv[1]);\n  printf(\"nodes: %d\\n\", g.nodes);\n  printf(\"edges: %d\\n\", g.edges);\n  printf(\"avg degree: %.2f\\n\", 1.0 * g.edges / g.nodes);\n\n  const int repeat = atoi(argv[2]);\n\n  int* const color = new int [g.nodes];\n\n  int *nidx_d, *nlist_d, *nlist2_d, *posscol_d, *posscol2_d, *color_d, *wl_d, *wlsize_d;\n  if (cudaSuccess != cudaMalloc((void **)&nidx_d, (g.nodes + 1) * sizeof(int))) \n    printf(\"ERROR: could not allocate nidx_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&nlist_d, g.edges * sizeof(int)))\n    printf(\"ERROR: could not allocate nlist_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&nlist2_d, g.edges * sizeof(int)))\n    printf(\"ERROR: could not allocate nlist2_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&posscol_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate posscol_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&posscol2_d, (g.edges / WS + 1) * sizeof(int))) \n    printf(\"ERROR: could not allocate posscol2_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&color_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate color_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&wl_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate wl_d\\n\\n\");\n  if (cudaSuccess != cudaMalloc((void **)&wlsize_d, sizeof(int))) \n    printf(\"ERROR: could not allocate wlsize\\n\\n\");\n\n  if (cudaSuccess != cudaMemcpy(nidx_d, g.nindex, (g.nodes + 1) * sizeof(int), cudaMemcpyHostToDevice)) \n    printf(\"ERROR: copying nidx to device failed\\n\\n\");\n  if (cudaSuccess != cudaMemcpy(nlist_d, g.nlist, g.edges * sizeof(int), cudaMemcpyHostToDevice)) \n    printf(\"ERROR: copying nlist to device failed\\n\\n\");\n\n  cudaDeviceProp deviceProp;\n  cudaGetDeviceProperties(&deviceProp, 0);\n  const int SMs = deviceProp.multiProcessorCount;\n  const int mTpSM = deviceProp.maxThreadsPerMultiProcessor;\n  const int blocks = SMs * mTpSM / ThreadsPerBlock;\n  printf(\"Total number of compute units: %d\\n\", SMs);\n  printf(\"Maximum resident threads per compute unit: %d\\n\", mTpSM);\n  printf(\"Work-group size: %d\\n\", ThreadsPerBlock);\n  printf(\"Total number of work-groups: %d\\n\", blocks);\n\n  cudaFuncSetCacheConfig(init, cudaFuncCachePreferL1);\n  cudaFuncSetCacheConfig(runLarge, cudaFuncCachePreferL1);\n  cudaFuncSetCacheConfig(runSmall, cudaFuncCachePreferL1);\n\n  cudaDeviceSynchronize();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    cudaMemset(wlsize_d, 0, sizeof(int));\n    init<<<blocks, ThreadsPerBlock>>>(g.nodes, g.edges, nidx_d, nlist_d, nlist2_d, posscol_d, posscol2_d, color_d, wl_d, wlsize_d);\n    runLarge<<<blocks, ThreadsPerBlock>>>(g.nodes, nidx_d, nlist2_d, posscol_d, posscol2_d, color_d, wl_d, wlsize_d);\n    runSmall<<<blocks, ThreadsPerBlock>>>(g.nodes, nidx_d, nlist_d, posscol_d, color_d);\n  }\n\n  cudaDeviceSynchronize();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = elapsed_seconds.count() / repeat;\n\n  printf(\"average runtime (%d runs):    %.6f s\\n\", repeat, runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", g.nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", g.edges * 0.000001 / runtime);\n\n  if (cudaSuccess != cudaMemcpy(color, color_d, g.nodes * sizeof(int), cudaMemcpyDeviceToHost)) \n    printf(\"ERROR: copying color from device failed\\n\\n\");\n\n  cudaFree(wlsize_d);\n  cudaFree(wl_d);\n  cudaFree(color_d);\n  cudaFree(posscol2_d);\n  cudaFree(posscol_d);\n  cudaFree(nlist2_d);\n  cudaFree(nlist_d);\n  cudaFree(nidx_d);\n\n  bool ok = true;\n  for (int v = 0; v < g.nodes; v++) {\n    if (color[v] < 0) {\n      printf(\"ERROR: found unprocessed node in graph (node %d with deg %d)\\n\\n\",\n             v, g.nindex[v + 1] - g.nindex[v]);\n      ok = false;\n      break;\n    }\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      if (color[g.nlist[i]] == color[v]) {\n        printf(\"ERROR: found adjacent nodes with same color %d (%d %d)\\n\\n\",\n               color[v], v, g.nlist[i]);\n        ok = false;\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  if (ok) {\n    const int vals = 16;\n    int c[vals];\n    for (int i = 0; i < vals; i++) c[i] = 0;\n    int cols = -1;\n    for (int v = 0; v < g.nodes; v++) {\n      cols = std::max(cols, color[v]);\n      if (color[v] < vals) c[color[v]]++;\n    }\n    cols++;\n    printf(\"Number of distinct colors used: %d\\n\", cols);\n\n    int sum = 0;\n    for (int i = 0; i < std::min(vals, cols); i++) {\n      sum += c[i];\n      printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], 100.0 * sum / g.nodes);\n    }\n  }\n\n  delete [] color;\n  freeECLgraph(g);\n  return 0;\n}\n"}}
{"kernel_name": "gc", "kernel_api": "hip", "code": {"main.cu": "\n\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <chrono>\n#include <hip/hip_runtime.h>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 512;\nstatic const int WS = 32;  \n\nstatic const int MSB = 1 << (WS - 1);\nstatic const int Mask = (1 << (WS / 2)) - 1;\n\n\n\n\nstatic __device__ unsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n__global__\nvoid init(const int nodes,\n    const int edges, \n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    int* const __restrict__ nlist2,\n    int* const __restrict__ posscol,\n    int* const __restrict__ posscol2,\n    int* const __restrict__ color,\n    int* const __restrict__ wl,\n    int* __restrict__ wlsize)\n{\n  const int lane = threadIdx.x % WS;\n  const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int threads = gridDim.x * ThreadsPerBlock;\n\n  int maxrange = -1;\n  for (int v = thread; __any(v < nodes); v += threads) {\n    bool cond = false;\n    int beg, end, pos, degv, active;\n    if (v < nodes) {\n      beg = nidx[v];\n      end = nidx[v + 1];\n      degv = end - beg;\n      cond = (degv >= WS);\n      if (cond) {\n        wl[atomicAdd(wlsize, 1)] = v;\n      } else {\n        active = 0;\n        pos = beg;\n        for (int i = beg; i < end; i++) {\n          const int nei = nlist[i];\n          const int degn = nidx[nei + 1] - nidx[nei];\n          if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n            active |= (unsigned int)MSB >> (i - beg);\n            pos++;\n          }\n        }\n      }\n    }\n\n    int bal = __ballot(cond);\n    while (bal != 0) {\n      const int who = __ffs(bal) - 1;\n      bal &= bal - 1;\n      const int wv = __shfl(v, who);\n      const int wbeg = __shfl(beg, who);\n      const int wend = __shfl(end, who);\n      const int wdegv = wend - wbeg;\n      int wpos = wbeg;\n      for (int i = wbeg + lane; __any(i < wend); i += WS) {\n        int wnei;\n        bool prio = false;\n        if (i < wend) {\n          wnei = nlist[i];\n          const int wdegn = nidx[wnei + 1] - nidx[wnei];\n          prio = ((wdegv < wdegn) || ((wdegv == wdegn) && (hash(wv) < hash(wnei))) || ((wdegv == wdegn) && (hash(wv) == hash(wnei)) && (wv < wnei)));\n        }\n        const int b = __ballot(prio);\n        const int offs = __popc(b & ((1 << lane) - 1));\n        if (prio) nlist2[wpos + offs] = wnei;\n        wpos += __popc(b);\n      }\n      if (who == lane) pos = wpos;\n    }\n\n    if (v < nodes) {\n      const int range = pos - beg;\n      maxrange = max(maxrange, range);\n      color[v] = (cond || (range == 0)) ? (range << (WS / 2)) : active;\n      posscol[v] = (range >= WS) ? -1 : (MSB >> range);\n    }\n  }\n  \n\n\n  for (int i = thread; i < edges / WS + 1; i += threads) posscol2[i] = -1;\n}\n\n\n__global__\nvoid runLarge(const int nodes, \n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    int* const __restrict__ posscol,\n    int* const __restrict__ posscol2,\n    volatile int* const __restrict__ color,\n    const int* const __restrict__ wl,\n    const int* __restrict__ wlsize)\n{\n  const int stop = *wlsize;\n  if (stop != 0) {\n    const int lane = threadIdx.x % WS;\n    const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n    const int threads = gridDim.x * ThreadsPerBlock;\n    bool again;\n    do {\n      again = false;\n      for (int w = thread; __any(w < stop); w += threads) {\n        bool shortcut, done, cond = false;\n        int v, data, range, beg, pcol;\n        if (w < stop) {\n          v = wl[w];\n          data = color[v];\n          range = data >> (WS / 2);\n          if (range > 0) {\n            beg = nidx[v];\n            pcol = posscol[v];\n            cond = true;\n          }\n        }\n\n        int bal = __ballot(cond);\n        while (bal != 0) {\n          const int who = __ffs(bal) - 1;\n          bal &= bal - 1;\n          const int wdata = __shfl(data, who);\n          const int wrange = wdata >> (WS / 2);\n          const int wbeg = __shfl(beg, who);\n          const int wmincol = wdata & Mask;\n          const int wmaxcol = wmincol + wrange;\n          const int wend = wbeg + wmaxcol;\n          const int woffs = wbeg / WS;\n          int wpcol = __shfl(pcol, who);\n\n          bool wshortcut = true;\n          bool wdone = true;\n          for (int i = wbeg + lane; __any(i < wend); i += WS) {\n            int nei, neidata, neirange;\n            if (i < wend) {\n              nei = nlist[i];\n              neidata = color[nei];\n              neirange = neidata >> (WS / 2);\n              const bool neidone = (neirange == 0);\n              wdone &= neidone; \n\n              if (neidone) {\n                const int neicol = neidata;\n                if (neicol < WS) {\n                  wpcol &= ~((unsigned int)MSB >> neicol); \n\n                } else {\n                  if ((wmincol <= neicol) && (neicol < wmaxcol) && ((posscol2[woffs + neicol / WS] << (neicol % WS)) < 0)) {\n                    atomicAnd((int*)&posscol2[woffs + neicol / WS], ~((unsigned int)MSB >> (neicol % WS)));\n                  }\n                }\n              } else {\n                const int neimincol = neidata & Mask;\n                const int neimaxcol = neimincol + neirange;\n                if ((neimincol <= wmincol) && (neimaxcol >= wmincol)) wshortcut = false; \n\n              }\n            }\n          }\n          wshortcut = __all(wshortcut);\n          wdone = __all(wdone);\n          wpcol &= __shfl_xor(wpcol, 1);\n          wpcol &= __shfl_xor(wpcol, 2);\n          wpcol &= __shfl_xor(wpcol, 4);\n          wpcol &= __shfl_xor(wpcol, 8);\n          wpcol &= __shfl_xor(wpcol, 16);\n          if (who == lane) pcol = wpcol;\n          if (who == lane) done = wdone;\n          if (who == lane) shortcut = wshortcut;\n        }\n\n        if (w < stop) {\n          if (range > 0) {\n            const int mincol = data & Mask;\n            int val = pcol, mc = 0;\n            if (pcol == 0) {\n              const int offs = beg / WS;\n              mc = max(1, mincol / WS);\n              while ((val = posscol2[offs + mc]) == 0) mc++;\n            }\n            int newmincol = mc * WS + __clz(val);\n            if (mincol != newmincol) shortcut = false;\n            if (shortcut || done) {\n              pcol = (newmincol < WS) ? ((unsigned int)MSB >> newmincol) : 0;\n            } else {\n              const int maxcol = mincol + range;\n              const int range = maxcol - newmincol;\n              newmincol = (range << (WS / 2)) | newmincol;\n              again = true;\n            }\n            posscol[v] = pcol;\n            color[v] = newmincol;\n          }\n        }\n      }\n    } while (__any(again));\n  }\n}\n\n\n__global__ \nvoid runSmall(const int nodes,\n    const int* const __restrict__ nidx,\n    const int* const __restrict__ nlist,\n    volatile int* const __restrict__ posscol,\n    int* const __restrict__ color)\n    \n\n{\n  const int thread = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int threads = gridDim.x * ThreadsPerBlock;\n\n  bool again;\n  do {\n    again = false;\n    for (int v = thread; v < nodes; v += threads) {\n      int pcol = posscol[v];\n      if (__popc(pcol) > 1) {\n        const int beg = nidx[v];\n        int active = color[v];\n        int allnei = 0;\n        int keep = active;\n        do {\n          const int old = active;\n          active &= active - 1;\n          const int curr = old ^ active;\n          const int i = beg + __clz(curr);\n          const int nei = nlist[i];\n          const int neipcol = posscol[nei];\n          allnei |= neipcol;\n          if ((pcol & neipcol) == 0) {\n            pcol &= pcol - 1;\n            keep ^= curr;\n          } else if (__popc(neipcol) == 1) {\n            pcol ^= neipcol;\n            keep ^= curr;\n          }\n        } while (active != 0);\n        if (keep != 0) {\n          const int best = (unsigned int)MSB >> __clz(pcol);\n          if ((best & ~allnei) != 0) {\n            pcol = best;\n            keep = 0;\n          }\n        }\n        again |= keep;\n        if (keep == 0) keep = __clz(pcol);\n        color[v] = keep;\n        posscol[v] = pcol;\n      }\n    }\n  } while (again);\n}\n\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-GC v1.2 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2020 Texas State University\\n\\n\");\n\n  if (argc != 3) {printf(\"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);  exit(-1);}\n  if (WS != 32) {printf(\"ERROR: warp size must be 32\\n\\n\");  exit(-1);}\n  if (WS != sizeof(int) * 8) {printf(\"ERROR: bits per word must match warp size\\n\\n\");  exit(-1);}\n  if ((ThreadsPerBlock < WS) || ((ThreadsPerBlock % WS) != 0)) {\n    printf(\"ERROR: threads per block must be a multiple of the warp size\\n\\n\");\n    exit(-1);\n  }\n  if ((ThreadsPerBlock & (ThreadsPerBlock - 1)) != 0) {\n    printf(\"ERROR: threads per block must be a power of two\\n\\n\");\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"input: %s\\n\", argv[1]);\n  printf(\"nodes: %d\\n\", g.nodes);\n  printf(\"edges: %d\\n\", g.edges);\n  printf(\"avg degree: %.2f\\n\", 1.0 * g.edges / g.nodes);\n\n  const int repeat = atoi(argv[2]);\n\n  int* const color = new int [g.nodes];\n\n  int *nidx_d, *nlist_d, *nlist2_d, *posscol_d, *posscol2_d, *color_d, *wl_d, *wlsize_d;\n  if (hipSuccess != hipMalloc((void **)&nidx_d, (g.nodes + 1) * sizeof(int))) \n    printf(\"ERROR: could not allocate nidx_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&nlist_d, g.edges * sizeof(int)))\n    printf(\"ERROR: could not allocate nlist_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&nlist2_d, g.edges * sizeof(int)))\n    printf(\"ERROR: could not allocate nlist2_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&posscol_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate posscol_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&posscol2_d, (g.edges / WS + 1) * sizeof(int))) \n    printf(\"ERROR: could not allocate posscol2_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&color_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate color_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&wl_d, g.nodes * sizeof(int))) \n    printf(\"ERROR: could not allocate wl_d\\n\\n\");\n  if (hipSuccess != hipMalloc((void **)&wlsize_d, sizeof(int))) \n    printf(\"ERROR: could not allocate wlsize\\n\\n\");\n\n  if (hipSuccess != hipMemcpy(nidx_d, g.nindex, (g.nodes + 1) * sizeof(int), hipMemcpyHostToDevice)) \n    printf(\"ERROR: copying nidx to device failed\\n\\n\");\n  if (hipSuccess != hipMemcpy(nlist_d, g.nlist, g.edges * sizeof(int), hipMemcpyHostToDevice)) \n    printf(\"ERROR: copying nlist to device failed\\n\\n\");\n\n  hipDeviceProp_t deviceProp;\n  hipGetDeviceProperties(&deviceProp, 0);\n  const int SMs = deviceProp.multiProcessorCount;\n  const int mTpSM = deviceProp.maxThreadsPerMultiProcessor;\n  const int blocks = SMs * mTpSM / ThreadsPerBlock;\n  printf(\"Total number of compute units: %d\\n\", SMs);\n  printf(\"Maximum resident threads per compute unit: %d\\n\", mTpSM);\n  printf(\"Work-group size: %d\\n\", ThreadsPerBlock);\n  printf(\"Total number of work-groups: %d\\n\", blocks);\n\n  hipDeviceSynchronize();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    hipMemset(wlsize_d, 0, sizeof(int));\n    init<<<blocks, ThreadsPerBlock>>>(g.nodes, g.edges, nidx_d, nlist_d, nlist2_d, posscol_d, posscol2_d, color_d, wl_d, wlsize_d);\n    runLarge<<<blocks, ThreadsPerBlock>>>(g.nodes, nidx_d, nlist2_d, posscol_d, posscol2_d, color_d, wl_d, wlsize_d);\n    runSmall<<<blocks, ThreadsPerBlock>>>(g.nodes, nidx_d, nlist_d, posscol_d, color_d);\n  }\n\n  hipDeviceSynchronize();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = elapsed_seconds.count() / repeat;\n\n  printf(\"average runtime (%d runs):    %.6f s\\n\", repeat, runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", g.nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", g.edges * 0.000001 / runtime);\n\n  if (hipSuccess != hipMemcpy(color, color_d, g.nodes * sizeof(int), hipMemcpyDeviceToHost)) \n    printf(\"ERROR: copying color from device failed\\n\\n\");\n\n  hipFree(wlsize_d);\n  hipFree(wl_d);\n  hipFree(color_d);\n  hipFree(posscol2_d);\n  hipFree(posscol_d);\n  hipFree(nlist2_d);\n  hipFree(nlist_d);\n  hipFree(nidx_d);\n\n  bool ok = true;\n  for (int v = 0; v < g.nodes; v++) {\n    if (color[v] < 0) {\n      printf(\"ERROR: found unprocessed node in graph (node %d with deg %d)\\n\\n\",\n             v, g.nindex[v + 1] - g.nindex[v]);\n      ok = false;\n      break;\n    }\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      if (color[g.nlist[i]] == color[v]) {\n        printf(\"ERROR: found adjacent nodes with same color %d (%d %d)\\n\\n\",\n               color[v], v, g.nlist[i]);\n        ok = false;\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  if (ok) {\n    const int vals = 16;\n    int c[vals];\n    for (int i = 0; i < vals; i++) c[i] = 0;\n    int cols = -1;\n    for (int v = 0; v < g.nodes; v++) {\n      cols = std::max(cols, color[v]);\n      if (color[v] < vals) c[color[v]]++;\n    }\n    cols++;\n    printf(\"Number of distinct colors used: %d\\n\", cols);\n\n    int sum = 0;\n    for (int i = 0; i < std::min(vals, cols); i++) {\n      sum += c[i];\n      printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], 100.0 * sum / g.nodes);\n    }\n  }\n\n  delete [] color;\n  freeECLgraph(g);\n  return 0;\n}\n"}}
{"kernel_name": "gc", "kernel_api": "omp", "code": {"main.cpp": "\n\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <chrono>\n#include \"graph.h\"\n\nstatic const int BPI = 32;  \n\nstatic const int MSB = 1 << (BPI - 1);\nstatic const int Mask = (1 << (BPI / 2)) - 1;\n\n#ifdef OMP_TARGET\n#pragma omp declare target\n#endif\n\n\n\n#define popcount(x)  __builtin_popcount(x)\n#define clz(x)  __builtin_clz(x)\n\n\n\nstatic unsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n#ifdef OMP_TARGET\n#pragma omp end declare target\n#endif\n\nstatic int init(\n  const int nodes,\n  const int edges,\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  int* const __restrict nlist2,\n  int* const __restrict posscol,\n  int* const __restrict posscol2,\n  int* const __restrict color,\n  int* const __restrict wl,\n       const int threads)\n{\n  int wlsize = 0;\n  int maxrange = -1;\n#ifdef OMP_TARGET\n  #pragma omp target teams distribute parallel for thread_limit(threads) default(none) \\\n  reduction(max: maxrange) shared(nodes, wlsize, wl, nidx, nlist, nlist2, color, posscol)\n#else\n  #pragma omp parallel for num_threads(threads) default(none) \\\n  reduction(max: maxrange) shared(nodes, wlsize, wl, nidx, nlist, nlist2, color, posscol)\n#endif\n  for (int v = 0; v < nodes; v++) {\n    int active;\n    const int beg = nidx[v];\n    const int end = nidx[v + 1];\n    const int degv = end - beg;\n    const bool cond = (degv >= BPI);\n    int pos = beg;\n    if (cond) {\n      int tmp;\n      #pragma omp atomic capture\n      tmp = wlsize++;\n      wl[tmp] = v;\n      for (int i = beg; i < end; i++) {\n        const int nei = nlist[i];\n        const int degn = nidx[nei + 1] - nidx[nei];\n        if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n          nlist2[pos] = nei;\n          pos++;\n        }\n      }\n    } else {\n      active = 0;\n      for (int i = beg; i < end; i++) {\n        const int nei = nlist[i];\n        const int degn = nidx[nei + 1] - nidx[nei];\n        if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n          active |= (unsigned int)MSB >> (i - beg);\n          pos++;\n        }\n      }\n    }\n    const int range = pos - beg;\n    maxrange = std::max(maxrange, range);  \n\n    color[v] = (cond || (range == 0)) ? (range << (BPI / 2)) : active;\n    posscol[v] = (range >= BPI) ? -1 : (MSB >> range);\n  }\n  if (maxrange >= Mask) {printf(\"too many active neighbors\\n\"); exit(-1);}\n\n#ifdef OMP_TARGET\n  #pragma omp target teams distribute parallel for thread_limit(threads) default(none) shared(edges, posscol2)\n#else\n  #pragma omp parallel for num_threads(threads) default(none) shared(edges, posscol2)\n#endif\n  for (int i = 0; i < edges / BPI + 1; i++) posscol2[i] = -1;\n  return wlsize;\n}\n\n\nvoid runLarge(\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  int* const __restrict posscol,\n  volatile int* const __restrict posscol2,\n  volatile int* const __restrict color,\n  const int* const __restrict wl,\n  const int wlsize,\n  const int threads)\n{\n  if (wlsize != 0) {\n    bool again;\n#ifdef OMP_TARGET\n    #pragma omp target parallel num_threads(threads) \\\n    default(none) shared(wlsize, wl, nidx, nlist, color, posscol, posscol2) private(again)\n#else\n    #pragma omp parallel num_threads(threads) \\\n    default(none) shared(wlsize, wl, nidx, nlist, color, posscol, posscol2) private(again)\n#endif\n    do {\n      again = false;\n      #pragma omp for nowait\n      for (int w = 0; w < wlsize; w++) {\n        bool shortcut = true;\n        bool done = true;\n        const int v = wl[w];\n        int data;  \n\n        #pragma omp atomic read\n        data = color[v];\n        const int range = data >> (BPI / 2);\n        if (range > 0) {\n          const int beg = nidx[v];\n          int pcol = posscol[v];\n          const int mincol = data & Mask;\n          const int maxcol = mincol + range;\n          const int end = beg + maxcol;\n          const int offs = beg / BPI;\n          for (int i = beg; i < end; i++) {\n            const int nei = nlist[i];\n            int neidata;  \n\n            #pragma omp atomic read\n            neidata = color[nei];\n            const int neirange = neidata >> (BPI / 2);\n            if (neirange == 0) {\n              const int neicol = neidata;\n              if (neicol < BPI) {\n                pcol &= ~((unsigned int)MSB >> neicol);\n              } else {\n                if ((mincol <= neicol) && (neicol < maxcol)) {\n                  int pc;  \n\n                  #pragma omp atomic read\n                  pc = posscol2[offs + neicol / BPI];\n                  if ((pc << (neicol % BPI)) < 0) {\n                    #pragma omp atomic update\n                    posscol2[offs + neicol / BPI] &= ~((unsigned int)MSB >> (neicol % BPI));\n                  }\n                }\n              }\n            } else {\n              done = false;\n              const int neimincol = neidata & Mask;\n              const int neimaxcol = neimincol + neirange;\n              if ((neimincol <= mincol) && (neimaxcol >= mincol)) shortcut = false;\n            }\n          }\n          int val = pcol;\n          int mc = 0;\n          if (pcol == 0) {\n            const int offs = beg / BPI;\n            mc = std::max(1, mincol / BPI) - 1;\n            do {\n              mc++;\n              #pragma omp atomic read\n              val = posscol2[offs + mc];\n            } while (val == 0);\n          }\n          int newmincol = mc * BPI + clz(val);\n          if (mincol != newmincol) shortcut = false;\n          if (shortcut || done) {\n            pcol = (newmincol < BPI) ? ((unsigned int)MSB >> newmincol) : 0;\n          } else {\n            const int maxcol = mincol + range;\n            const int range = maxcol - newmincol;\n            newmincol = (range << (BPI / 2)) | newmincol;\n            again = true;\n          }\n          posscol[v] = pcol;\n          #pragma omp atomic write\n          color[v] = newmincol;\n        }\n      }\n    } while (again);\n  }\n}\n\n\nvoid runSmall(\n  const int nodes,\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  volatile int* const __restrict posscol,\n  int* const __restrict color,\n  const int threads)\n{\n  bool again;\n#ifdef OMP_TARGET\n  #pragma omp target parallel num_threads(threads) default(none) shared(nodes, nidx, nlist, color, posscol) private(again)\n#else\n  #pragma omp parallel num_threads(threads) default(none) shared(nodes, nidx, nlist, color, posscol) private(again)\n#endif\n  do {\n    again = false;\n    #pragma omp for nowait\n    for (int v = 0; v < nodes; v++) {\n      int pcol;\n      #pragma omp atomic read\n      pcol = posscol[v];\n      if (popcount(pcol) > 1) {\n        const int beg = nidx[v];\n        int active = color[v];\n        int allnei = 0;\n        int keep = active;\n        do {\n          const int old = active;\n          active &= active - 1;\n          const int curr = old ^ active;\n          const int i = beg + __builtin_clz(curr);\n          const int nei = nlist[i];\n          int neipcol;\n          #pragma omp atomic read\n          neipcol = posscol[nei];\n          allnei |= neipcol;\n          if ((pcol & neipcol) == 0) {\n            pcol &= pcol - 1;\n            keep ^= curr;\n          } else if (popcount(neipcol) == 1) {\n            pcol ^= neipcol;\n            keep ^= curr;\n          }\n        } while (active != 0);\n        if (keep != 0) {\n          const int best = (unsigned int)MSB >> __builtin_clz(pcol);\n          if ((best & ~allnei) != 0) {\n            pcol = best;\n            keep = 0;\n          }\n        }\n        again |= keep;\n        if (keep == 0) keep = __builtin_clz(pcol);\n        color[v] = keep;\n        #pragma omp atomic write\n        posscol[v] = pcol;\n      }\n    }\n  } while (again);\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-GC OpenMP v1.2 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2020 Texas State University\\n\\n\");\n\n  if (argc != 4) {printf(\"USAGE: %s <input_file_name> <thread_count> <repeat>\\n\\n\", argv[0]);  exit(-1);}\n  if (BPI != sizeof(int) * 8) {printf(\"ERROR: bits per int size must be %ld\\n\\n\", sizeof(int) * 8);  exit(-1);}\n  const int threads = atoi(argv[2]);\n  if (threads < 1) {fprintf(stderr, \"ERROR: thread_limit must be at least 1\\n\"); exit(-1);}\n\n  const int repeat = atoi(argv[3]);\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"input: %s\\n\", argv[1]);\n  printf(\"nodes: %d\\n\", g.nodes);\n  printf(\"edges: %d\\n\", g.edges);\n  printf(\"avg degree: %.2f\\n\", 1.0 * g.edges / g.nodes);\n\n  int* const color = new int [g.nodes];\n  int* const nlist2 = new int [g.edges];\n  int* const posscol = new int [g.nodes];\n  int* const posscol2 = new int [g.edges / BPI + 1];\n  int* const wl = new int [g.nodes];\n\n  double runtime;\n  const int* nindex = g.nindex;\n  const int* nlist = g.nlist;\n  \n#ifdef OMP_TARGET\n  #pragma omp target data map (from: color[0:g.nodes]) \\\n                          map (alloc: nlist2[0:g.edges],\\\n                                      posscol[0:g.nodes],\\\n                                      posscol2[0:g.edges/BPI+1],\\\n                                      wl[0:g.nodes]) \\\n                          map (to: nindex[0:g.nodes+1], \\\n                                   nlist[0:g.edges])\n  {\n#endif\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    for (int n = 0; n < repeat; n++) {\n      const int wlsize = init(g.nodes, g.edges, nindex, nlist, nlist2, posscol, posscol2, color, wl, threads);\n      runLarge(nindex, nlist2, posscol, posscol2, color, wl, wlsize, threads);\n      runSmall(g.nodes, nindex, nlist, posscol, color, threads);\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> elapsed_seconds = end - start;\n    runtime = elapsed_seconds.count() / repeat;\n\n#ifdef OMP_TARGET\n  }\n#endif\n\n  printf(\"average runtime (%d runs):    %.6f s\\n\", repeat, runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", g.nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", g.edges * 0.000001 / runtime);\n\n  bool ok = true;\n  for (int v = 0; v < g.nodes; v++) {\n    if (color[v] < 0) {\n       printf(\"ERROR: found unprocessed node in graph (node %d with deg %d)\\n\\n\",\n              v, g.nindex[v + 1] - g.nindex[v]);\n       ok = false;\n       break;\n    }\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      if (color[g.nlist[i]] == color[v]) {\n        printf(\"ERROR: found adjacent nodes with same color %d (%d %d)\\n\\n\",\n               color[v], v, g.nlist[i]);\n        ok = false;\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  const int vals = 16;\n  int c[vals];\n  for (int i = 0; i < vals; i++) c[i] = 0;\n  int cols = -1;\n  for (int v = 0; v < g.nodes; v++) {\n    cols = std::max(cols, color[v]);\n    if (color[v] < vals) c[color[v]]++;\n  }\n  cols++;\n  printf(\"Number of distinct colors used: %d\\n\", cols);\n\n  int sum = 0;\n  for (int i = 0; i < std::min(vals, cols); i++) {\n    sum += c[i];\n    printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], 100.0 * sum / g.nodes);\n  }\n\n  delete [] color;\n  delete [] nlist2;\n  delete [] posscol;\n  delete [] posscol2;\n  delete [] wl;\n  freeECLgraph(g);\n  return 0;\n}\n"}}
{"kernel_name": "gc", "kernel_api": "serial", "code": {"main.cpp": "\n\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <chrono>\n#include \"graph.h\"\n\nstatic const int BPI = 32;  \n\nstatic const int MSB = 1 << (BPI - 1);\nstatic const int Mask = (1 << (BPI / 2)) - 1;\n\n#ifdef OMP_TARGET\n#endif\n\n\n\n#define popcount(x)  __builtin_popcount(x)\n#define clz(x)  __builtin_clz(x)\n\n\n\nstatic unsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n#ifdef OMP_TARGET\n#endif\n\nstatic int init(\n  const int nodes,\n  const int edges,\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  int* const __restrict nlist2,\n  int* const __restrict posscol,\n  int* const __restrict posscol2,\n  int* const __restrict color,\n  int* const __restrict wl,\n       const int threads)\n{\n  int wlsize = 0;\n  int maxrange = -1;\n#ifdef OMP_TARGET\n  #else\n  #endif\n  for (int v = 0; v < nodes; v++) {\n    int active;\n    const int beg = nidx[v];\n    const int end = nidx[v + 1];\n    const int degv = end - beg;\n    const bool cond = (degv >= BPI);\n    int pos = beg;\n    if (cond) {\n      int tmp;\n            tmp = wlsize++;\n      wl[tmp] = v;\n      for (int i = beg; i < end; i++) {\n        const int nei = nlist[i];\n        const int degn = nidx[nei + 1] - nidx[nei];\n        if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n          nlist2[pos] = nei;\n          pos++;\n        }\n      }\n    } else {\n      active = 0;\n      for (int i = beg; i < end; i++) {\n        const int nei = nlist[i];\n        const int degn = nidx[nei + 1] - nidx[nei];\n        if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n          active |= (unsigned int)MSB >> (i - beg);\n          pos++;\n        }\n      }\n    }\n    const int range = pos - beg;\n    maxrange = std::max(maxrange, range);  \n\n    color[v] = (cond || (range == 0)) ? (range << (BPI / 2)) : active;\n    posscol[v] = (range >= BPI) ? -1 : (MSB >> range);\n  }\n  if (maxrange >= Mask) {printf(\"too many active neighbors\\n\"); exit(-1);}\n\n#ifdef OMP_TARGET\n  #else\n  #endif\n  for (int i = 0; i < edges / BPI + 1; i++) posscol2[i] = -1;\n  return wlsize;\n}\n\n\nvoid runLarge(\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  int* const __restrict posscol,\n  volatile int* const __restrict posscol2,\n  volatile int* const __restrict color,\n  const int* const __restrict wl,\n  const int wlsize,\n  const int threads)\n{\n  if (wlsize != 0) {\n    bool again;\n#ifdef OMP_TARGET\n    #else\n    #endif\n    do {\n      again = false;\n            for (int w = 0; w < wlsize; w++) {\n        bool shortcut = true;\n        bool done = true;\n        const int v = wl[w];\n        int data;  \n\n                data = color[v];\n        const int range = data >> (BPI / 2);\n        if (range > 0) {\n          const int beg = nidx[v];\n          int pcol = posscol[v];\n          const int mincol = data & Mask;\n          const int maxcol = mincol + range;\n          const int end = beg + maxcol;\n          const int offs = beg / BPI;\n          for (int i = beg; i < end; i++) {\n            const int nei = nlist[i];\n            int neidata;  \n\n                        neidata = color[nei];\n            const int neirange = neidata >> (BPI / 2);\n            if (neirange == 0) {\n              const int neicol = neidata;\n              if (neicol < BPI) {\n                pcol &= ~((unsigned int)MSB >> neicol);\n              } else {\n                if ((mincol <= neicol) && (neicol < maxcol)) {\n                  int pc;  \n\n                                    pc = posscol2[offs + neicol / BPI];\n                  if ((pc << (neicol % BPI)) < 0) {\n                                        posscol2[offs + neicol / BPI] &= ~((unsigned int)MSB >> (neicol % BPI));\n                  }\n                }\n              }\n            } else {\n              done = false;\n              const int neimincol = neidata & Mask;\n              const int neimaxcol = neimincol + neirange;\n              if ((neimincol <= mincol) && (neimaxcol >= mincol)) shortcut = false;\n            }\n          }\n          int val = pcol;\n          int mc = 0;\n          if (pcol == 0) {\n            const int offs = beg / BPI;\n            mc = std::max(1, mincol / BPI) - 1;\n            do {\n              mc++;\n                            val = posscol2[offs + mc];\n            } while (val == 0);\n          }\n          int newmincol = mc * BPI + clz(val);\n          if (mincol != newmincol) shortcut = false;\n          if (shortcut || done) {\n            pcol = (newmincol < BPI) ? ((unsigned int)MSB >> newmincol) : 0;\n          } else {\n            const int maxcol = mincol + range;\n            const int range = maxcol - newmincol;\n            newmincol = (range << (BPI / 2)) | newmincol;\n            again = true;\n          }\n          posscol[v] = pcol;\n                    color[v] = newmincol;\n        }\n      }\n    } while (again);\n  }\n}\n\n\nvoid runSmall(\n  const int nodes,\n  const int* const __restrict nidx,\n  const int* const __restrict nlist,\n  volatile int* const __restrict posscol,\n  int* const __restrict color,\n  const int threads)\n{\n  bool again;\n#ifdef OMP_TARGET\n  #else\n  #endif\n  do {\n    again = false;\n        for (int v = 0; v < nodes; v++) {\n      int pcol;\n            pcol = posscol[v];\n      if (popcount(pcol) > 1) {\n        const int beg = nidx[v];\n        int active = color[v];\n        int allnei = 0;\n        int keep = active;\n        do {\n          const int old = active;\n          active &= active - 1;\n          const int curr = old ^ active;\n          const int i = beg + __builtin_clz(curr);\n          const int nei = nlist[i];\n          int neipcol;\n                    neipcol = posscol[nei];\n          allnei |= neipcol;\n          if ((pcol & neipcol) == 0) {\n            pcol &= pcol - 1;\n            keep ^= curr;\n          } else if (popcount(neipcol) == 1) {\n            pcol ^= neipcol;\n            keep ^= curr;\n          }\n        } while (active != 0);\n        if (keep != 0) {\n          const int best = (unsigned int)MSB >> __builtin_clz(pcol);\n          if ((best & ~allnei) != 0) {\n            pcol = best;\n            keep = 0;\n          }\n        }\n        again |= keep;\n        if (keep == 0) keep = __builtin_clz(pcol);\n        color[v] = keep;\n                posscol[v] = pcol;\n      }\n    }\n  } while (again);\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-GC OpenMP v1.2 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2020 Texas State University\\n\\n\");\n\n  if (argc != 4) {printf(\"USAGE: %s <input_file_name> <thread_count> <repeat>\\n\\n\", argv[0]);  exit(-1);}\n  if (BPI != sizeof(int) * 8) {printf(\"ERROR: bits per int size must be %ld\\n\\n\", sizeof(int) * 8);  exit(-1);}\n  const int threads = atoi(argv[2]);\n  if (threads < 1) {fprintf(stderr, \"ERROR: thread_limit must be at least 1\\n\"); exit(-1);}\n\n  const int repeat = atoi(argv[3]);\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"input: %s\\n\", argv[1]);\n  printf(\"nodes: %d\\n\", g.nodes);\n  printf(\"edges: %d\\n\", g.edges);\n  printf(\"avg degree: %.2f\\n\", 1.0 * g.edges / g.nodes);\n\n  int* const color = new int [g.nodes];\n  int* const nlist2 = new int [g.edges];\n  int* const posscol = new int [g.nodes];\n  int* const posscol2 = new int [g.edges / BPI + 1];\n  int* const wl = new int [g.nodes];\n\n  double runtime;\n  const int* nindex = g.nindex;\n  const int* nlist = g.nlist;\n  \n#ifdef OMP_TARGET\n    {\n\n    auto start = std::chrono::high_resolution_clock::now();\n\n    for (int n = 0; n < repeat; n++) {\n      const int wlsize = init(g.nodes, g.edges, nindex, nlist, nlist2, posscol, posscol2, color, wl, threads);\n      runLarge(nindex, nlist2, posscol, posscol2, color, wl, wlsize, threads);\n      runSmall(g.nodes, nindex, nlist, posscol, color, threads);\n    }\n\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration<double> elapsed_seconds = end - start;\n    runtime = elapsed_seconds.count() / repeat;\n\n#ifdef OMP_TARGET\n  }\n#endif\n\n  printf(\"average runtime (%d runs):    %.6f s\\n\", repeat, runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", g.nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", g.edges * 0.000001 / runtime);\n\n  bool ok = true;\n  for (int v = 0; v < g.nodes; v++) {\n    if (color[v] < 0) {\n       printf(\"ERROR: found unprocessed node in graph (node %d with deg %d)\\n\\n\",\n              v, g.nindex[v + 1] - g.nindex[v]);\n       ok = false;\n       break;\n    }\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      if (color[g.nlist[i]] == color[v]) {\n        printf(\"ERROR: found adjacent nodes with same color %d (%d %d)\\n\\n\",\n               color[v], v, g.nlist[i]);\n        ok = false;\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  const int vals = 16;\n  int c[vals];\n  for (int i = 0; i < vals; i++) c[i] = 0;\n  int cols = -1;\n  for (int v = 0; v < g.nodes; v++) {\n    cols = std::max(cols, color[v]);\n    if (color[v] < vals) c[color[v]]++;\n  }\n  cols++;\n  printf(\"Number of distinct colors used: %d\\n\", cols);\n\n  int sum = 0;\n  for (int i = 0; i < std::min(vals, cols); i++) {\n    sum += c[i];\n    printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], 100.0 * sum / g.nodes);\n  }\n\n  delete [] color;\n  delete [] nlist2;\n  delete [] posscol;\n  delete [] posscol2;\n  delete [] wl;\n  freeECLgraph(g);\n  return 0;\n}"}}
{"kernel_name": "gc", "kernel_api": "sycl", "code": {"main.cpp": "\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <chrono>\n#include \"common.h\"\n#include \"graph.h\"\n\n\n\nstatic const int ThreadsPerBlock = 512;\nstatic const int WS = 32;  \n\nstatic const int MSB = 1 << (WS - 1);\nstatic const int Mask = (1 << (WS / 2)) - 1;\n\ninline int ffs(int x) {\n  return (x == 0) ? 0 : sycl::ctz(x) + 1;\n}\n\n\n\nstatic unsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n\nvoid init(const int nodes,\n    const int edges, \n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    int* const __restrict nlist2,\n    int* const __restrict posscol,\n    int* const __restrict posscol2,\n    int* const __restrict color,\n    int* const __restrict wl,\n    int* __restrict wlsize,\n    sycl::nd_item<1> &item\n#ifdef SYCL_STREAM\n    , const sycl::stream &out\n#endif\n    )\n{\n  const int lane = item.get_local_id(0) % WS;\n  const int thread = item.get_global_id(0);\n  const int threads = item.get_group_range(0) * ThreadsPerBlock;\n  auto sg = item.get_sub_group();\n\n  int maxrange = -1;\n  for (int v = thread; sycl::any_of_group(sg, v < nodes); v += threads) {\n    bool cond = false;\n    int beg, end, pos, degv, active;\n    if (v < nodes) {\n      beg = nidx[v];\n      end = nidx[v + 1];\n      degv = end - beg;\n      cond = (degv >= WS);\n      if (cond) {\n        wl[sycl::atomic<int>(sycl::global_ptr<int>(wlsize)).fetch_add(1)] = v;\n      } else {\n        active = 0;\n        pos = beg;\n        for (int i = beg; i < end; i++) {\n          const int nei = nlist[i];\n          const int degn = nidx[nei + 1] - nidx[nei];\n          if ((degv < degn) || ((degv == degn) && (hash(v) < hash(nei))) || \n             ((degv == degn) && (hash(v) == hash(nei)) && (v < nei))) {\n            active |= (unsigned int)MSB >> (i - beg);\n            pos++;\n          }\n        }\n      }\n    }\n\n    int bal = sycl::reduce_over_group(sg,\n        cond ? (0x1 << sg.get_local_linear_id()) : 0, sycl::plus<>());\n    while (bal != 0) {\n      const int who = ffs(bal) - 1;\n      bal &= bal - 1;\n      const int wv = sycl::select_from_group(sg, v, who);\n      const int wbeg = sycl::select_from_group(sg, beg, who);\n      const int wend = sycl::select_from_group(sg, end, who);\n      const int wdegv = wend - wbeg;\n      int wpos = wbeg;\n      for (int i = wbeg + lane; sycl::any_of_group(sg, i < wend); i += WS) {\n        int wnei;\n        bool prio = false;\n        if (i < wend) {\n          wnei = nlist[i];\n          const int wdegn = nidx[wnei + 1] - nidx[wnei];\n          prio = ((wdegv < wdegn) || ((wdegv == wdegn) && (hash(wv) < hash(wnei))) || \n                 ((wdegv == wdegn) && (hash(wv) == hash(wnei)) && (wv < wnei)));\n        }\n        const int b = sycl::reduce_over_group( sg, \n                  prio ? (0x1 << sg.get_local_linear_id()) : 0, sycl::plus<>());\n        const int offs = sycl::popcount(b & ((1 << lane) - 1));\n        if (prio) nlist2[wpos + offs] = wnei;\n        wpos += sycl::popcount(b);\n      }\n      if (who == lane) pos = wpos;\n    }\n\n    if (v < nodes) {\n      const int range = pos - beg;\n      maxrange = sycl::max(maxrange, range);\n      color[v] = (cond || (range == 0)) ? (range << (WS / 2)) : active;\n      posscol[v] = (range >= WS) ? -1 : (MSB >> range);\n    }\n  }\n#ifdef SYCL_STREAM\n  if (maxrange >= Mask) out << \"too many active neighbors\\n\";\n#endif\n\n  for (int i = thread; i < edges / WS + 1; i += threads) posscol2[i] = -1;\n}\n\nvoid runLarge(const int nodes, \n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    int* const __restrict posscol,\n    int* const __restrict posscol2,\n    volatile int* const __restrict color,\n    const int* const __restrict wl,\n    const int* __restrict wlsize,\n    sycl::nd_item<1> &item)\n{\n  const int stop = *wlsize;\n  if (stop != 0) {\n    const int lane = item.get_local_id(0) % WS;\n    const int thread = item.get_global_id(0);\n    const int threads = item.get_group_range(0) * ThreadsPerBlock;\n    auto sg = item.get_sub_group();\n    bool again;\n    do {\n      again = false;\n      for (int w = thread; sycl::any_of_group(sg, w < stop); w += threads) {\n        bool shortcut, done, cond = false;\n        int v, data, range, beg, pcol;\n        if (w < stop) {\n          v = wl[w];\n          data = color[v];\n          range = data >> (WS / 2);\n          if (range > 0) {\n            beg = nidx[v];\n            pcol = posscol[v];\n            cond = true;\n          }\n        }\n\n        int bal = sycl::reduce_over_group(sg,\n            cond ? (0x1 << sg.get_local_linear_id()) : 0, sycl::plus<>());\n        while (bal != 0) {\n          const int who = ffs(bal) - 1;\n          bal &= bal - 1;\n          const int wdata = sycl::select_from_group(sg, data, who);\n          const int wrange = wdata >> (WS / 2);\n          const int wbeg = sycl::select_from_group(sg, beg, who);\n          const int wmincol = wdata & Mask;\n          const int wmaxcol = wmincol + wrange;\n          const int wend = wbeg + wmaxcol;\n          const int woffs = wbeg / WS;\n          int wpcol = sycl::select_from_group(sg, pcol, who);\n\n          bool wshortcut = true;\n          bool wdone = true;\n          for (int i = wbeg + lane; sycl::any_of_group(sg, i < wend); i += WS) {\n            int nei, neidata, neirange;\n            if (i < wend) {\n              nei = nlist[i];\n              neidata = color[nei];\n              neirange = neidata >> (WS / 2);\n              const bool neidone = (neirange == 0);\n              wdone &= neidone; \n\n              if (neidone) {\n                const int neicol = neidata;\n                if (neicol < WS) {\n                  wpcol &= ~((unsigned int)MSB >> neicol); \n\n                } else {\n                  if ((wmincol <= neicol) && (neicol < wmaxcol) && ((posscol2[woffs + neicol / WS] << (neicol % WS)) < 0)) {\n                    sycl::atomic<int>(sycl::global_ptr<int>(\n                            (int *)&posscol2[woffs + neicol / WS]))\n                        .fetch_and(~((unsigned int)MSB >> (neicol % WS)));\n                  }\n                }\n              } else {\n                const int neimincol = neidata & Mask;\n                const int neimaxcol = neimincol + neirange;\n                if ((neimincol <= wmincol) && (neimaxcol >= wmincol)) wshortcut = false; \n\n              }\n            }\n          }\n          wshortcut = sycl::all_of_group(sg, wshortcut);\n          wdone = sycl::all_of_group(sg, wdone);\n          wpcol &= sycl::permute_group_by_xor(sg, wpcol, 1);\n          wpcol &= sycl::permute_group_by_xor(sg, wpcol, 2);\n          wpcol &= sycl::permute_group_by_xor(sg, wpcol, 4);\n          wpcol &= sycl::permute_group_by_xor(sg, wpcol, 8);\n          wpcol &= sycl::permute_group_by_xor(sg, wpcol, 16);\n          if (who == lane) pcol = wpcol;\n          if (who == lane) done = wdone;\n          if (who == lane) shortcut = wshortcut;\n        }\n\n        if (w < stop) {\n          if (range > 0) {\n            const int mincol = data & Mask;\n            int val = pcol, mc = 0;\n            if (pcol == 0) {\n              const int offs = beg / WS;\n              mc = sycl::max(1, (int)(mincol / WS));\n              while ((val = posscol2[offs + mc]) == 0) mc++;\n            }\n            int newmincol = mc * WS + sycl::clz(val);\n            if (mincol != newmincol) shortcut = false;\n            if (shortcut || done) {\n              pcol = (newmincol < WS) ? ((unsigned int)MSB >> newmincol) : 0;\n            } else {\n              const int maxcol = mincol + range;\n              const int range = maxcol - newmincol;\n              newmincol = (range << (WS / 2)) | newmincol;\n              again = true;\n            }\n            posscol[v] = pcol;\n            color[v] = newmincol;\n          }\n        }\n      }\n    } while (sycl::any_of_group(sg, again));\n  }\n}\n\n  \nvoid runSmall(const int nodes,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile int* const __restrict posscol,\n    int* const __restrict color,\n    sycl::nd_item<1> &item)\n{\n  const int thread = item.get_global_id(0);\n  const int threads = item.get_group_range(0) * ThreadsPerBlock;\n\n  bool again;\n  do {\n    again = false;\n    for (int v = thread; v < nodes; v += threads) {\n      int pcol = posscol[v];\n      if (sycl::popcount(pcol) > 1) {\n        const int beg = nidx[v];\n        int active = color[v];\n        int allnei = 0;\n        int keep = active;\n        do {\n          const int old = active;\n          active &= active - 1;\n          const int curr = old ^ active;\n          const int i = beg + sycl::clz((int)curr);\n          const int nei = nlist[i];\n          const int neipcol = posscol[nei];\n          allnei |= neipcol;\n          if ((pcol & neipcol) == 0) {\n            pcol &= pcol - 1;\n            keep ^= curr;\n          } else if (sycl::popcount(neipcol) == 1) {\n            pcol ^= neipcol;\n            keep ^= curr;\n          }\n        } while (active != 0);\n        if (keep != 0) {\n          const int best = (unsigned int)MSB >> sycl::clz(pcol);\n          if ((best & ~allnei) != 0) {\n            pcol = best;\n            keep = 0;\n          }\n        }\n        again |= keep;\n        if (keep == 0) keep = sycl::clz(pcol);\n        color[v] = keep;\n        posscol[v] = pcol;\n      }\n    }\n  } while (again);\n}\n\nint main(int argc, char *argv[]) {\n  printf(\"ECL-GC v1.2 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2020 Texas State University\\n\\n\");\n\n  if (argc != 3) {printf(\"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);  exit(-1);}\n  if (WS != 32) {printf(\"ERROR: warp size must be 32\\n\\n\");  exit(-1);}\n  if (WS != sizeof(int) * 8) {printf(\"ERROR: bits per word must match warp size\\n\\n\");  exit(-1);}\n  if ((ThreadsPerBlock < WS) || ((ThreadsPerBlock % WS) != 0)) {\n    printf(\"ERROR: threads per block must be a multiple of the warp size\\n\\n\");\n    exit(-1);\n  }\n  if ((ThreadsPerBlock & (ThreadsPerBlock - 1)) != 0) {\n    printf(\"ERROR: threads per block must be a power of two\\n\\n\");\n    exit(-1);\n  }\n\n  printf(\"input: %s\\n\", argv[1]);\n  ECLgraph g = readECLgraph(argv[1]);\n\n  const int nodes = g.nodes;\n  const int edges = g.edges;\n\n  printf(\"nodes: %d\\n\", nodes);\n  printf(\"edges: %d\\n\", edges);\n  printf(\"avg degree: %.2f\\n\", 1.0 * edges / nodes);\n\n  const int repeat = atoi(argv[2]);\n\n  int* const color = new int [nodes];\n\n#ifdef USE_GPU\n  gpu_selector dev_sel;\n#else\n  cpu_selector dev_sel;\n#endif\n  queue q(dev_sel);\n\n  buffer<int, 1> nidx_d (g.nindex, nodes + 1);\n  buffer<int, 1> nlist_d (g.nlist, edges);\n  buffer<int, 1> nlist2_d (edges);\n  buffer<int, 1> posscol_d (nodes);\n  buffer<int, 1> posscol2_d (g.edges / WS + 1);\n  buffer<int, 1> color_d (nodes);\n  buffer<int, 1> wl_d (nodes);\n  buffer<int, 1> wlsize_d (1);\n\n  const int SMs = q.get_device().get_info<info::device::max_compute_units>();\n  const int mTpSM = 2048;\n  const int blocks = SMs * mTpSM / ThreadsPerBlock;\n  printf(\"Total number of compute units: %d\\n\", SMs);\n  printf(\"Maximum resident threads per compute unit: %d\\n\", mTpSM);\n  printf(\"Work-group size: %d\\n\", ThreadsPerBlock);\n  printf(\"Total number of work-groups: %d\\n\", blocks);\n\n  q.wait();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  range<1> gws (blocks * ThreadsPerBlock);\n  range<1> lws (ThreadsPerBlock);\n\n  for (int n = 0; n < repeat; n++) {\n    q.submit([&] (handler &cgh) {\n      auto wlsize = wlsize_d.get_access<sycl_write>(cgh);\n      cgh.fill(wlsize, 0);\n    });\n\n    q.submit([&] (handler &cgh) {\n#ifdef SYCL_STREAM\n      stream out(64*1024, 256, cgh);\n#endif\n      auto nidx = nidx_d.get_access<sycl_read>(cgh);\n      auto nlist = nlist_d.get_access<sycl_read>(cgh);\n      auto nlist2 = nlist2_d.get_access<sycl_write>(cgh);\n      auto posscol = posscol_d.get_access<sycl_write>(cgh);\n      auto posscol2 = posscol2_d.get_access<sycl_write>(cgh);\n      auto color = color_d.get_access<sycl_write>(cgh);\n      auto wl = wl_d.get_access<sycl_write>(cgh);\n      auto wlsize = wlsize_d.get_access<sycl_read_write>(cgh);\n      cgh.parallel_for<class init_kernel>(nd_range<1>(gws, lws),\n        [=] (nd_item<1> item) [[intel::reqd_sub_group_size(32)]] {\n        init(nodes, edges, nidx.get_pointer(), nlist.get_pointer(), nlist2.get_pointer(),\n             posscol.get_pointer(), posscol2.get_pointer(), color.get_pointer(),\n             wl.get_pointer(), wlsize.get_pointer(), item\n#ifdef SYCL_STREAM\n             , out\n#endif\n             );\n      });\n    });\n\n    q.submit([&] (handler &cgh) {\n      auto nidx = nidx_d.get_access<sycl_read>(cgh);\n      auto nlist2 = nlist2_d.get_access<sycl_read>(cgh);\n      auto posscol = posscol_d.get_access<sycl_read_write>(cgh);\n      auto posscol2 = posscol2_d.get_access<sycl_read_write>(cgh);\n      auto color = color_d.get_access<sycl_read_write>(cgh);\n      auto wl = wl_d.get_access<sycl_read>(cgh);\n      auto wlsize = wlsize_d.get_access<sycl_read>(cgh);\n      cgh.parallel_for<class runLarge_kernel>(nd_range<1>(gws, lws),\n        [=] (nd_item<1> item) [[intel::reqd_sub_group_size(32)]] {\n        runLarge(nodes, nidx.get_pointer(), nlist2.get_pointer(),\n                 posscol.get_pointer(), posscol2.get_pointer(), color.get_pointer(),\n                 wl.get_pointer(), wlsize.get_pointer(), item);\n        });\n    });\n\n    q.submit([&] (handler &cgh) {\n      auto nidx = nidx_d.get_access<sycl_read>(cgh);\n      auto nlist = nlist_d.get_access<sycl_read>(cgh);\n      auto posscol = posscol_d.get_access<sycl_read_write>(cgh);\n      auto color = color_d.get_access<sycl_read_write>(cgh);\n      cgh.parallel_for<class runSmall_kernel>(nd_range<1>(gws, lws), \n        [=] (nd_item<1> item) [[intel::reqd_sub_group_size(32)]] {\n        runSmall(nodes, nidx.get_pointer(), nlist.get_pointer(), \n                 posscol.get_pointer(), color.get_pointer(), item);\n      });\n    });\n  }\n\n  q.wait();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  double runtime = elapsed_seconds.count() / repeat;\n\n  printf(\"average runtime: (%d runs):   %.6f s\\n\", repeat, runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", g.nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", g.edges * 0.000001 / runtime);\n\n  q.submit([&] (handler &cgh) {\n    auto acc = color_d.get_access<sycl_read>(cgh);\n    cgh.copy(acc, color);\n  }).wait();\n\n  bool ok = true;\n  for (int v = 0; v < g.nodes; v++) {\n    if (color[v] < 0) {\n      printf(\"ERROR: found unprocessed node in graph (node %d with deg %d)\\n\\n\",\n          v, g.nindex[v + 1] - g.nindex[v]);\n      ok = false;\n      break;\n    }\n    for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n      if (color[g.nlist[i]] == color[v]) {\n        printf(\"ERROR: found adjacent nodes with same color %d (%d %d)\\n\\n\",\n            color[v], v, g.nlist[i]);\n        ok = false;\n        break;\n      }\n    }\n  }\n  printf(\"%s\\n\", ok ? \"PASS\" : \"FAIL\");\n\n  if (ok) {\n    const int vals = 16;\n    int c[vals];\n    for (int i = 0; i < vals; i++) c[i] = 0;\n    int cols = -1;\n    for (int v = 0; v < g.nodes; v++) {\n      cols = std::max(cols, color[v]);\n      if (color[v] < vals) c[color[v]]++;\n    }\n    cols++;\n    printf(\"Number of distinct colors used: %d\\n\", cols);\n\n    int sum = 0;\n    for (int i = 0; i < std::min(vals, cols); i++) {\n      sum += c[i];\n      printf(\"color %2d: %10d (%5.1f%%)\\n\", i, c[i], 100.0 * sum / g.nodes);\n    }\n  }\n\n  delete [] color;\n  freeECLgraph(g);\n  return 0;\n}\n"}}
{"kernel_name": "mis", "kernel_api": "cuda", "code": {"main.cu": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <chrono>\n#include <cuda.h>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 256;\n\ntypedef unsigned char stattype;\nstatic const stattype in = 0xfe;\nstatic const stattype out = 0;\n\n\n\n\n__global__ \nvoid findmins(const int nodes, \n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile stattype* const __restrict nstat)\n{\n  const int from = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int incr = gridDim.x * ThreadsPerBlock;\n\n  int missing;\n  do {\n    missing = 0;\n    for (int v = from; v < nodes; v += incr) {\n      const stattype nv = nstat[v];\n      if (nv & 1) {\n        int i = nidx[v];\n        while ((i < nidx[v + 1]) && ((nv > nstat[nlist[i]]) || ((nv == nstat[nlist[i]]) && (v > nlist[i])))) {\n          i++;\n        }\n        if (i < nidx[v + 1]) {\n          missing = 1;\n        } else {\n          for (int i = nidx[v]; i < nidx[v + 1]; i++) {\n            nstat[nlist[i]] = out;\n          }\n          nstat[v] = in;\n        }\n      }\n    }\n  } while (missing != 0);\n}\n\n\n\n\n\n\n__device__ \nunsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n\n\n\n__global__\nvoid init(const int nodes, \n    const int edges, \n    const int* const __restrict nidx,\n    stattype* const __restrict nstat)\n{\n  const int from = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int incr = gridDim.x * ThreadsPerBlock;\n\n  const float avg = (float)edges / nodes;\n  const float scaledavg = ((in / 2) - 1) * avg;\n\n  for (int i = from; i < nodes; i += incr) {\n    stattype val = in;\n    const int degree = nidx[i + 1] - nidx[i];\n    if (degree > 0) {\n      float x = degree - (hash(i) * 0.00000000023283064365386962890625f);\n      int res = int(scaledavg / (avg + x));\n      val = (res + res) | 1;\n    }\n    nstat[i] = val;\n  }\n}\n\nvoid computeMIS(\n    const int repeat,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    stattype* const __restrict nstat)\n{\n  int* nidx_d;\n  int* nlist_d;\n  stattype* nstat_d;\n\n  if (cudaSuccess != cudaMalloc((void **)&nidx_d, (nodes + 1) * sizeof(int))) {\n    fprintf(stderr, \"ERROR: could not allocate nidx_d\\n\\n\");\n  }\n  if (cudaSuccess != cudaMalloc((void **)&nlist_d, edges * sizeof(int))) {\n    fprintf(stderr, \"ERROR: could not allocate nlist_d\\n\\n\");\n  }\n  if (cudaSuccess != cudaMalloc((void **)&nstat_d, nodes * sizeof(stattype))) {\n    fprintf(stderr, \"ERROR: could not allocate nstat_d\\n\\n\");\n  }\n  if (cudaSuccess != cudaMemcpy(nidx_d, nidx, (nodes + 1) * sizeof(int), cudaMemcpyHostToDevice)) {\n    fprintf(stderr, \"ERROR: copying to device failed\\n\\n\");\n  }\n  if (cudaSuccess != cudaMemcpy(nlist_d, nlist, edges * sizeof(int), cudaMemcpyHostToDevice)) {\n    fprintf(stderr, \"ERROR: copying to device failed\\n\\n\");\n  }\n\n  const int blocks = 24;\n\n  cudaDeviceSynchronize();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    init<<<blocks, ThreadsPerBlock>>>(nodes, edges, nidx_d, nstat_d);\n\n    findmins<<<blocks, ThreadsPerBlock>>>(nodes, nidx_d, nlist_d, nstat_d);\n  }\n\n  cudaDeviceSynchronize();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = (float)elapsed_seconds.count() / repeat;\n  printf(\"compute time: %.6f s\\n\", runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", edges * 0.000001 / runtime);\n\n  if (cudaSuccess != cudaMemcpy(nstat, nstat_d, nodes * sizeof(stattype), cudaMemcpyDeviceToHost)) {\n    fprintf(stderr, \"ERROR: copying from device failed\\n\\n\");\n  }\n\n  cudaFree(nstat_d);\n  cudaFree(nlist_d);\n  cudaFree(nidx_d);\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-MIS v1.3 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2017-2020 Texas State University\\n\");\n\n  if (argc != 3) {\n    fprintf(stderr, \"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"configuration: %d nodes and %d edges (%s)\\n\", g.nodes, g.edges, argv[1]);\n  printf(\"average degree: %.2f edges per node\\n\", 1.0 * g.edges / g.nodes);\n\n  stattype* nstatus = (stattype*)malloc(g.nodes * sizeof(nstatus[0]));\n\n  if (nstatus == NULL) {\n    fprintf(stderr, \"ERROR: could not allocate nstatus\\n\\n\");\n  }\n  else {\n    const int repeat = atoi(argv[2]);\n\n    computeMIS(repeat, g.nodes, g.edges, g.nindex, g.nlist, nstatus);\n\n    \n\n\n    for (int v = 0; v < g.nodes; v++) {\n      if ((nstatus[v] != in) && (nstatus[v] != out)) {\n        fprintf(stderr, \"ERROR: found unprocessed node in graph\\n\\n\");\n        break;\n      }\n      if (nstatus[v] == in) {\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            fprintf(stderr, \"ERROR: found adjacent nodes in MIS\\n\\n\");\n            break;\n          }\n        }\n      } else {\n        int flag = 0;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          fprintf(stderr, \"ERROR: set is not maximal\\n\\n\");\n          break;\n        }\n      }\n    }\n  }\n\n  freeECLgraph(g);\n  if (nstatus != NULL) free(nstatus);\n  return 0;\n}\n"}}
{"kernel_name": "mis", "kernel_api": "hip", "code": {"main.cu": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <chrono>\n#include <hip/hip_runtime.h>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 256;\n\ntypedef unsigned char stattype;\nstatic const stattype in = 0xfe;\nstatic const stattype out = 0;\n\n\n\n\n__global__ \nvoid findmins(const int nodes, \n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile stattype* const __restrict nstat)\n{\n  const int from = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int incr = gridDim.x * ThreadsPerBlock;\n\n  int missing;\n  do {\n    missing = 0;\n    for (int v = from; v < nodes; v += incr) {\n      const stattype nv = nstat[v];\n      if (nv & 1) {\n        int i = nidx[v];\n        while ((i < nidx[v + 1]) && ((nv > nstat[nlist[i]]) || ((nv == nstat[nlist[i]]) && (v > nlist[i])))) {\n          i++;\n        }\n        if (i < nidx[v + 1]) {\n          missing = 1;\n        } else {\n          for (int i = nidx[v]; i < nidx[v + 1]; i++) {\n            nstat[nlist[i]] = out;\n          }\n          nstat[v] = in;\n        }\n      }\n    }\n  } while (missing != 0);\n}\n\n\n\n\n\n\n__device__ \nunsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n\n\n\n__global__\nvoid init(const int nodes, \n    const int edges, \n    const int* const __restrict nidx,\n    stattype* const __restrict nstat)\n{\n  const int from = threadIdx.x + blockIdx.x * ThreadsPerBlock;\n  const int incr = gridDim.x * ThreadsPerBlock;\n\n  const float avg = (float)edges / nodes;\n  const float scaledavg = ((in / 2) - 1) * avg;\n\n  for (int i = from; i < nodes; i += incr) {\n    stattype val = in;\n    const int degree = nidx[i + 1] - nidx[i];\n    if (degree > 0) {\n      float x = degree - (hash(i) * 0.00000000023283064365386962890625f);\n      int res = int(scaledavg / (avg + x));\n      val = (res + res) | 1;\n    }\n    nstat[i] = val;\n  }\n}\n\nvoid computeMIS(\n    const int repeat,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    stattype* const __restrict nstat)\n{\n  int* nidx_d;\n  int* nlist_d;\n  stattype* nstat_d;\n\n  if (hipSuccess != hipMalloc((void **)&nidx_d, (nodes + 1) * sizeof(int))) {\n    fprintf(stderr, \"ERROR: could not allocate nidx_d\\n\\n\");\n  }\n  if (hipSuccess != hipMalloc((void **)&nlist_d, edges * sizeof(int))) {\n    fprintf(stderr, \"ERROR: could not allocate nlist_d\\n\\n\");\n  }\n  if (hipSuccess != hipMalloc((void **)&nstat_d, nodes * sizeof(stattype))) {\n    fprintf(stderr, \"ERROR: could not allocate nstat_d\\n\\n\");\n  }\n  if (hipSuccess != hipMemcpy(nidx_d, nidx, (nodes + 1) * sizeof(int), hipMemcpyHostToDevice)) {\n    fprintf(stderr, \"ERROR: copying to device failed\\n\\n\");\n  }\n  if (hipSuccess != hipMemcpy(nlist_d, nlist, edges * sizeof(int), hipMemcpyHostToDevice)) {\n    fprintf(stderr, \"ERROR: copying to device failed\\n\\n\");\n  }\n\n  const int blocks = 24;\n\n  hipDeviceSynchronize();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    init<<<blocks, ThreadsPerBlock>>>(nodes, edges, nidx_d, nstat_d);\n\n    findmins<<<blocks, ThreadsPerBlock>>>(nodes, nidx_d, nlist_d, nstat_d);\n  }\n\n  hipDeviceSynchronize();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = (float)elapsed_seconds.count() / repeat;\n  printf(\"compute time: %.6f s\\n\", runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", edges * 0.000001 / runtime);\n\n  if (hipSuccess != hipMemcpy(nstat, nstat_d, nodes * sizeof(stattype), hipMemcpyDeviceToHost)) {\n    fprintf(stderr, \"ERROR: copying from device failed\\n\\n\");\n  }\n\n  hipFree(nstat_d);\n  hipFree(nlist_d);\n  hipFree(nidx_d);\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-MIS v1.3 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2017-2020 Texas State University\\n\");\n\n  if (argc != 3) {\n    fprintf(stderr, \"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"configuration: %d nodes and %d edges (%s)\\n\", g.nodes, g.edges, argv[1]);\n  printf(\"average degree: %.2f edges per node\\n\", 1.0 * g.edges / g.nodes);\n\n  stattype* nstatus = (stattype*)malloc(g.nodes * sizeof(nstatus[0]));\n\n  if (nstatus == NULL) {\n    fprintf(stderr, \"ERROR: could not allocate nstatus\\n\\n\");\n  }\n  else {\n    const int repeat = atoi(argv[2]);\n\n    computeMIS(repeat, g.nodes, g.edges, g.nindex, g.nlist, nstatus);\n\n    \n\n\n    for (int v = 0; v < g.nodes; v++) {\n      if ((nstatus[v] != in) && (nstatus[v] != out)) {\n        fprintf(stderr, \"ERROR: found unprocessed node in graph\\n\\n\");\n        break;\n      }\n      if (nstatus[v] == in) {\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            fprintf(stderr, \"ERROR: found adjacent nodes in MIS\\n\\n\");\n            break;\n          }\n        }\n      } else {\n        int flag = 0;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          fprintf(stderr, \"ERROR: set is not maximal\\n\\n\");\n          break;\n        }\n      }\n    }\n  }\n\n  freeECLgraph(g);\n  if (nstatus != NULL) free(nstatus);\n  return 0;\n}\n"}}
{"kernel_name": "mis", "kernel_api": "omp", "code": {"main.cpp": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <chrono>\n#include <omp.h>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 256;\n\ntypedef unsigned char stattype;\nstatic const stattype in = 0xfe;\nstatic const stattype out = 0;\n\n\n\n\n\n\n#pragma omp declare target\nunsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n#pragma omp end declare target\n\nvoid computeMIS(\n    const int repeat,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile stattype* const __restrict nstat)\n{\n  #pragma omp target data map(to: nidx[0:nodes+1], nlist[0:edges]) \\\n                          map(from: nstat[0:nodes])\n  {\n  const int blocks = 24;\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  const float avg = (float)edges / nodes;\n  const float scaledavg = ((in / 2) - 1) * avg;\n\n  for (int n = 0; n < 100; n++) {\n    #pragma omp target teams distribute parallel for \\\n      num_teams(blocks) thread_limit(ThreadsPerBlock) shared(avg, scaledavg)\n    for (int i = 0; i < nodes; i++) {\n      stattype val = in;\n      const int degree = nidx[i + 1] - nidx[i];\n      if (degree > 0) {\n        float x = degree - (hash(i) * 0.00000000023283064365386962890625f);\n        int res = int(scaledavg / (avg + x));\n        val = (res + res) | 1;\n      }\n      nstat[i] = val;\n    }\n    \n    #pragma omp target teams num_teams(blocks) thread_limit(ThreadsPerBlock)\n    {\n      #pragma omp parallel \n      {\n        const int from = omp_get_thread_num() + omp_get_team_num() * ThreadsPerBlock;\n        const int incr = omp_get_num_teams() * ThreadsPerBlock;\n\n        int missing;\n        do {\n          missing = 0;\n          for (int v = from; v < nodes; v += incr) {\n            const stattype nv = nstat[v];\n            if (nv & 1) {\n              int i = nidx[v];\n              while ((i < nidx[v + 1]) && ((nv > nstat[nlist[i]]) || ((nv == nstat[nlist[i]]) && (v > nlist[i])))) {\n                i++;\n              }\n              if (i < nidx[v + 1]) {\n                missing = 1;\n              } else {\n                for (int i = nidx[v]; i < nidx[v + 1]; i++) {\n                  nstat[nlist[i]] = out;\n                }\n                nstat[v] = in;\n              }\n            }\n          }\n        } while (missing != 0);\n      }\n    }\n  }\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = (float)elapsed_seconds.count() / repeat;\n  printf(\"compute time: %.6f s\\n\", runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", edges * 0.000001 / runtime);\n\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-MIS v1.3 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2017-2020 Texas State University\\n\");\n\n  if (argc != 3) {\n    fprintf(stderr, \"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"configuration: %d nodes and %d edges (%s)\\n\", g.nodes, g.edges, argv[1]);\n  printf(\"average degree: %.2f edges per node\\n\", 1.0 * g.edges / g.nodes);\n\n  stattype* nstatus = (stattype*)malloc(g.nodes * sizeof(nstatus[0]));\n\n  if (nstatus == NULL) {\n    fprintf(stderr, \"ERROR: could not allocate nstatus\\n\\n\");\n  }\n  else {\n    const int repeat = atoi(argv[2]);\n\n    computeMIS(repeat, g.nodes, g.edges, g.nindex, g.nlist, nstatus);\n\n    \n\n\n    for (int v = 0; v < g.nodes; v++) {\n      if ((nstatus[v] != in) && (nstatus[v] != out)) {\n        fprintf(stderr, \"ERROR: found unprocessed node in graph\\n\\n\");\n        break;\n      }\n      if (nstatus[v] == in) {\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            fprintf(stderr, \"ERROR: found adjacent nodes in MIS\\n\\n\");\n            break;\n          }\n        }\n      } else {\n        int flag = 0;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          fprintf(stderr, \"ERROR: set is not maximal\\n\\n\");\n          break;\n        }\n      }\n    }\n  }\n\n  freeECLgraph(g);\n  if (nstatus != NULL) free(nstatus);\n  return 0;\n}\n"}}
{"kernel_name": "mis", "kernel_api": "serial", "code": {"main.cpp": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <chrono>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 256;\n\ntypedef unsigned char stattype;\nstatic const stattype in = 0xfe;\nstatic const stattype out = 0;\n\n\n\n\n\n\nunsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\nvoid computeMIS(\n    const int repeat,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile stattype* const __restrict nstat)\n{\n    {\n  const int blocks = 24;\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  const float avg = (float)edges / nodes;\n  const float scaledavg = ((in / 2) - 1) * avg;\n\n  for (int n = 0; n < 100; n++) {\n        for (int i = 0; i < nodes; i++) {\n      stattype val = in;\n      const int degree = nidx[i + 1] - nidx[i];\n      if (degree > 0) {\n        float x = degree - (hash(i) * 0.00000000023283064365386962890625f);\n        int res = int(scaledavg / (avg + x));\n        val = (res + res) | 1;\n      }\n      nstat[i] = val;\n    }\n    \n        {\n            {\n        const int from = omp_get_thread_num() + omp_get_team_num() * ThreadsPerBlock;\n        const int incr = omp_get_num_teams() * ThreadsPerBlock;\n\n        int missing;\n        do {\n          missing = 0;\n          for (int v = from; v < nodes; v += incr) {\n            const stattype nv = nstat[v];\n            if (nv & 1) {\n              int i = nidx[v];\n              while ((i < nidx[v + 1]) && ((nv > nstat[nlist[i]]) || ((nv == nstat[nlist[i]]) && (v > nlist[i])))) {\n                i++;\n              }\n              if (i < nidx[v + 1]) {\n                missing = 1;\n              } else {\n                for (int i = nidx[v]; i < nidx[v + 1]; i++) {\n                  nstat[nlist[i]] = out;\n                }\n                nstat[v] = in;\n              }\n            }\n          }\n        } while (missing != 0);\n      }\n    }\n  }\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = (float)elapsed_seconds.count() / repeat;\n  printf(\"compute time: %.6f s\\n\", runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", edges * 0.000001 / runtime);\n\n  }\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-MIS v1.3 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2017-2020 Texas State University\\n\");\n\n  if (argc != 3) {\n    fprintf(stderr, \"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"configuration: %d nodes and %d edges (%s)\\n\", g.nodes, g.edges, argv[1]);\n  printf(\"average degree: %.2f edges per node\\n\", 1.0 * g.edges / g.nodes);\n\n  stattype* nstatus = (stattype*)malloc(g.nodes * sizeof(nstatus[0]));\n\n  if (nstatus == NULL) {\n    fprintf(stderr, \"ERROR: could not allocate nstatus\\n\\n\");\n  }\n  else {\n    const int repeat = atoi(argv[2]);\n\n    computeMIS(repeat, g.nodes, g.edges, g.nindex, g.nlist, nstatus);\n\n    \n\n\n    for (int v = 0; v < g.nodes; v++) {\n      if ((nstatus[v] != in) && (nstatus[v] != out)) {\n        fprintf(stderr, \"ERROR: found unprocessed node in graph\\n\\n\");\n        break;\n      }\n      if (nstatus[v] == in) {\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            fprintf(stderr, \"ERROR: found adjacent nodes in MIS\\n\\n\");\n            break;\n          }\n        }\n      } else {\n        int flag = 0;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          fprintf(stderr, \"ERROR: set is not maximal\\n\\n\");\n          break;\n        }\n      }\n    }\n  }\n\n  freeECLgraph(g);\n  if (nstatus != NULL) free(nstatus);\n  return 0;\n}"}}
{"kernel_name": "mis", "kernel_api": "sycl", "code": {"main.cpp": "\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <chrono>\n#include <sycl/sycl.hpp>\n#include \"graph.h\"\n\nstatic const int ThreadsPerBlock = 256;\n\ntypedef unsigned char stattype;\nstatic const stattype in = 0xfe;\nstatic const stattype out = 0;\n\n\n\n\nvoid findmins(sycl::nd_item<1> &item,\n    const int nodes,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    volatile stattype* const __restrict nstat)\n{\n  const int from = item.get_global_id(0);\n  const int incr = item.get_group_range(0) * item.get_local_range(0);\n\n  int missing;\n  do {\n    missing = 0;\n    for (int v = from; v < nodes; v += incr) {\n      const stattype nv = nstat[v];\n      if (nv & 1) {\n        int i = nidx[v];\n        while ((i < nidx[v + 1]) && ((nv > nstat[nlist[i]]) || ((nv == nstat[nlist[i]]) && (v > nlist[i])))) {\n          i++;\n        }\n        if (i < nidx[v + 1]) {\n          missing = 1;\n        } else {\n          for (int i = nidx[v]; i < nidx[v + 1]; i++) {\n            nstat[nlist[i]] = out;\n          }\n          nstat[v] = in;\n        }\n      }\n    }\n  } while (missing != 0);\n}\n\n\n\n\n\n\nunsigned int hash(unsigned int val)\n{\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  val = ((val >> 16) ^ val) * 0x45d9f3b;\n  return (val >> 16) ^ val;\n}\n\n\n\n\nvoid init(sycl::nd_item<1> &item,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    stattype* const __restrict nstat)\n{\n  const int from = item.get_global_id(0);\n  const int incr = item.get_group_range(0) * item.get_local_range(0);\n\n  const float avg = (float)edges / nodes;\n  const float scaledavg = ((in / 2) - 1) * avg;\n\n  for (int i = from; i < nodes; i += incr) {\n    stattype val = in;\n    const int degree = nidx[i + 1] - nidx[i];\n    if (degree > 0) {\n      float x = degree - (hash(i) * 0.00000000023283064365386962890625f);\n      int res = int(scaledavg / (avg + x));\n      val = (res + res) | 1;\n    }\n    nstat[i] = val;\n  }\n}\n\nvoid computeMIS(\n    const int repeat,\n    const int nodes,\n    const int edges,\n    const int* const __restrict nidx,\n    const int* const __restrict nlist,\n    stattype* const __restrict nstat)\n{\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  int *nidx_d = sycl::malloc_device<int>(nodes+1, q);\n  q.memcpy(nidx_d, nidx, (nodes+1) * sizeof(int));\n\n  int *nlist_d = sycl::malloc_device<int>(edges, q);\n  q.memcpy(nlist_d, nlist, edges * sizeof(int));\n\n  stattype *nstat_d = sycl::malloc_device<stattype>(nodes+1, q);\n\n  const int blocks = 24;\n  sycl::range<1> gws (blocks * ThreadsPerBlock);\n  sycl::range<1> lws (ThreadsPerBlock);\n\n  q.wait();\n\n  auto start = std::chrono::high_resolution_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    q.submit([&] (sycl::handler &cgh) {\n      cgh.parallel_for<class k1>(\n        sycl::nd_range<1>(gws, lws), [=] (sycl::nd_item<1> item) {\n        init(item, nodes, edges, nidx_d, nstat_d);\n      });\n    });\n\n    q.submit([&] (sycl::handler &cgh) {\n      cgh.parallel_for<class k2>(\n        sycl::nd_range<1>(gws, lws), [=] (sycl::nd_item<1> item) {\n        findmins(item, nodes, nidx_d, nlist_d, nstat_d);\n      });\n    });\n  }\n\n  q.wait();\n\n  auto end = std::chrono::high_resolution_clock::now();\n  std::chrono::duration<double> elapsed_seconds = end - start;\n  float runtime = (float)elapsed_seconds.count() / repeat;\n  printf(\"compute time: %.6f s\\n\", runtime);\n  printf(\"throughput: %.6f Mnodes/s\\n\", nodes * 0.000001 / runtime);\n  printf(\"throughput: %.6f Medges/s\\n\", edges * 0.000001 / runtime);\n\n  q.memcpy(nstat, nstat_d, nodes * sizeof(stattype)).wait();\n  sycl::free(nstat_d, q);\n  sycl::free(nlist_d, q);\n  sycl::free(nidx_d, q);\n}\n\nint main(int argc, char* argv[])\n{\n  printf(\"ECL-MIS v1.3 (%s)\\n\", __FILE__);\n  printf(\"Copyright 2017-2020 Texas State University\\n\");\n\n  if (argc != 3) {\n    fprintf(stderr, \"USAGE: %s <input_file_name> <repeat>\\n\\n\", argv[0]);\n    exit(-1);\n  }\n\n  ECLgraph g = readECLgraph(argv[1]);\n  printf(\"configuration: %d nodes and %d edges (%s)\\n\", g.nodes, g.edges, argv[1]);\n  printf(\"average degree: %.2f edges per node\\n\", 1.0 * g.edges / g.nodes);\n\n  stattype* nstatus = (stattype*)malloc(g.nodes * sizeof(nstatus[0]));\n\n  if (nstatus == NULL) {\n    fprintf(stderr, \"ERROR: could not allocate nstatus\\n\\n\");\n  }\n  else {\n    const int repeat = atoi(argv[2]);\n\n    computeMIS(repeat, g.nodes, g.edges, g.nindex, g.nlist, nstatus);\n\n    \n\n\n    for (int v = 0; v < g.nodes; v++) {\n      if ((nstatus[v] != in) && (nstatus[v] != out)) {\n        fprintf(stderr, \"ERROR: found unprocessed node in graph\\n\\n\");\n        break;\n      }\n      if (nstatus[v] == in) {\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            fprintf(stderr, \"ERROR: found adjacent nodes in MIS\\n\\n\");\n            break;\n          }\n        }\n      } else {\n        int flag = 0;\n        for (int i = g.nindex[v]; i < g.nindex[v + 1]; i++) {\n          if (nstatus[g.nlist[i]] == in) {\n            flag = 1;\n          }\n        }\n        if (flag == 0) {\n          fprintf(stderr, \"ERROR: set is not maximal\\n\\n\");\n          break;\n        }\n      }\n    }\n  }\n\n  freeECLgraph(g);\n  if (nstatus != NULL) free(nstatus);\n  return 0;\n}\n"}}
