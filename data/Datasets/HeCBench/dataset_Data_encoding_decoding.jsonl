{"kernel_name": "jenkins-hash", "parallel_api": "cuda", "code": {"main.cu": "#include <stdio.h>      \n\n#include <stdlib.h>     \n\n#include <string.h>     \n\n#include <chrono>\n#include <cuda.h>\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n\n\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n\n\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\n__device__ __host__\nunsigned int mixRemainder(unsigned int a, \n    unsigned int b, \n    unsigned int c, \n    unsigned int k0,\n    unsigned int k1,\n    unsigned int k2,\n    unsigned int length ) \n{\n  switch(length)\n  {\n    case 12: c+=k2; b+=k1; a+=k0; break;\n    case 11: c+=k2&0xffffff; b+=k1; a+=k0; break;\n    case 10: c+=k2&0xffff; b+=k1; a+=k0; break;\n    case 9 : c+=k2&0xff; b+=k1; a+=k0; break;\n    case 8 : b+=k1; a+=k0; break;\n    case 7 : b+=k1&0xffffff; a+=k0; break;\n    case 6 : b+=k1&0xffff; a+=k0; break;\n    case 5 : b+=k1&0xff; a+=k0; break;\n    case 4 : a+=k0; break;\n    case 3 : a+=k0&0xffffff; break;\n    case 2 : a+=k0&0xffff; break;\n    case 1 : a+=k0&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\nunsigned int hashlittle( const void *key, size_t length, unsigned int initval)\n{\n  unsigned int a,b,c;                                          \n\n\n  \n\n  a = b = c = 0xdeadbeef + ((unsigned int)length) + initval;\n\n  const unsigned int *k = (const unsigned int *)key;         \n\n\n  \n\n  while (length > 12)\n  {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n\n  \n\n  \n\n\n  switch(length)\n  {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\n__global__ void kernel (\n    const unsigned int *__restrict__ lengths,\n    const unsigned int *__restrict__ initvals,\n    const unsigned int *__restrict__ keys,\n    unsigned int *__restrict__ out,\n    const int N ) \n{\n  int id = blockDim.x*blockIdx.x+threadIdx.x;\n  if (id >= N) return;\n  unsigned int length = lengths[id];\n  const unsigned int initval = initvals[id];\n  \n\n  const unsigned int *k = keys+id*16;  \n\n\n  \n\n  unsigned int a,b,c; \n  unsigned int r0,r1,r2;\n  a = b = c = 0xdeadbeef + length + initval;\n\n  \n\n  while (length > 12) {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n  r0 = k[0];\n  r1 = k[1];\n  r2 = k[2];\n\n  \n\n  \n\n  out[id] = mixRemainder(a, b, c, r0, r1, r2, length);\n}\n\nint main(int argc, char** argv) {\n\n  if (argc != 4) {\n    printf(\"Usage: %s <block size> <number of strings> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int block_size = atoi(argv[1]);  \n\n  unsigned long N = atol(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  \n\n  const char* str = \"Four score and seven years ago\";\n  unsigned int c = hashlittle(str, 30, 1);\n  printf(\"input string: %s hash is %.8x\\n\", str, c);   \n\n\n  unsigned int *keys = NULL;\n  unsigned int *lens = NULL;\n  unsigned int *initvals = NULL;\n  unsigned int *out = NULL;\n\n  \n\n  posix_memalign((void**)&keys, 1024, sizeof(unsigned int)*N*16);\n  posix_memalign((void**)&lens, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&initvals, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&out, 1024, sizeof(unsigned int)*N);\n\n  \n\n  srand(2);\n  char src[64];\n  memcpy(src, str, 64);\n  for (unsigned long i = 0; i < N; i++) {\n    memcpy((unsigned char*)keys+i*16*sizeof(unsigned int), src, 64);\n    lens[i] = rand()%61;\n    initvals[i] = i%2;\n  }\n\n  unsigned int* d_keys;\n  cudaMalloc((void**)&d_keys, sizeof(unsigned int)*N*16);\n  cudaMemcpyAsync(d_keys, keys, sizeof(unsigned int)*N*16, cudaMemcpyHostToDevice, 0);\n\n  unsigned int* d_lens;\n  cudaMalloc((void**)&d_lens, sizeof(unsigned int)*N);\n  cudaMemcpyAsync(d_lens, lens, sizeof(unsigned int)*N, cudaMemcpyHostToDevice, 0);\n\n  unsigned int* d_initvals;\n  cudaMalloc((void**)&d_initvals, sizeof(unsigned int)*N);\n  cudaMemcpyAsync(d_initvals, initvals, sizeof(unsigned int)*N, cudaMemcpyHostToDevice, 0);\n\n  unsigned int* d_out;\n  cudaMalloc((void**)&d_out, sizeof(unsigned int)*N);\n\n  dim3 grids ((N+block_size-1)/block_size);\n  dim3 threads (block_size);\n\n  cudaDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    kernel<<<grids,threads>>>(d_lens, d_initvals, d_keys, d_out, N);\n  }\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time : %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  cudaMemcpy(out, d_out, sizeof(unsigned int)*N, cudaMemcpyDeviceToHost);\n  cudaFree(d_keys);\n  cudaFree(d_lens);\n  cudaFree(d_initvals);\n  cudaFree(d_out);\n\n  printf(\"Verify the results computed on the device..\\n\");\n  bool error = false;\n  for (unsigned long i = 0; i < N; i++) {\n    c = hashlittle(&keys[i*16], lens[i], initvals[i]);\n    if (out[i] != c) {\n      printf(\"Error: at %lu gpu hash is %.8x  cpu hash is %.8x\\n\", i, out[i], c);\n      error = true;\n      break;\n    }\n  }\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(keys);\n  free(lens);\n  free(initvals);\n  free(out);\n\n  return 0;\n}\n"}}
{"kernel_name": "jenkins-hash", "parallel_api": "hip", "code": {"main.cu": "#include <stdio.h>      \n\n#include <stdlib.h>     \n\n#include <string.h>     \n\n#include <chrono>\n#include <hip/hip_runtime.h>\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n\n\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n\n\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\n__device__ __host__\nunsigned int mixRemainder(unsigned int a, \n    unsigned int b, \n    unsigned int c, \n    unsigned int k0,\n    unsigned int k1,\n    unsigned int k2,\n    unsigned int length ) \n{\n  switch(length)\n  {\n    case 12: c+=k2; b+=k1; a+=k0; break;\n    case 11: c+=k2&0xffffff; b+=k1; a+=k0; break;\n    case 10: c+=k2&0xffff; b+=k1; a+=k0; break;\n    case 9 : c+=k2&0xff; b+=k1; a+=k0; break;\n    case 8 : b+=k1; a+=k0; break;\n    case 7 : b+=k1&0xffffff; a+=k0; break;\n    case 6 : b+=k1&0xffff; a+=k0; break;\n    case 5 : b+=k1&0xff; a+=k0; break;\n    case 4 : a+=k0; break;\n    case 3 : a+=k0&0xffffff; break;\n    case 2 : a+=k0&0xffff; break;\n    case 1 : a+=k0&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\nunsigned int hashlittle( const void *key, size_t length, unsigned int initval)\n{\n  unsigned int a,b,c;                                          \n\n\n  \n\n  a = b = c = 0xdeadbeef + ((unsigned int)length) + initval;\n\n  const unsigned int *k = (const unsigned int *)key;         \n\n\n  \n\n  while (length > 12)\n  {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n\n  \n\n  \n\n\n  switch(length)\n  {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\n__global__ void kernel (\n    const unsigned int *__restrict__ lengths,\n    const unsigned int *__restrict__ initvals,\n    const unsigned int *__restrict__ keys,\n    unsigned int *__restrict__ out,\n    const int N ) \n{\n  int id = blockDim.x*blockIdx.x+threadIdx.x;\n  if (id >= N) return;\n  unsigned int length = lengths[id];\n  const unsigned int initval = initvals[id];\n  \n\n  const unsigned int *k = keys+id*16;  \n\n\n  \n\n  unsigned int a,b,c; \n  unsigned int r0,r1,r2;\n  a = b = c = 0xdeadbeef + length + initval;\n\n  \n\n  while (length > 12) {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n  r0 = k[0];\n  r1 = k[1];\n  r2 = k[2];\n\n  \n\n  \n\n  out[id] = mixRemainder(a, b, c, r0, r1, r2, length);\n}\n\nint main(int argc, char** argv) {\n\n  if (argc != 4) {\n    printf(\"Usage: %s <block size> <number of strings> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int block_size = atoi(argv[1]);  \n\n  unsigned long N = atol(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  \n\n  const char* str = \"Four score and seven years ago\";\n  unsigned int c = hashlittle(str, 30, 1);\n  printf(\"input string: %s hash is %.8x\\n\", str, c);   \n\n\n  unsigned int *keys = NULL;\n  unsigned int *lens = NULL;\n  unsigned int *initvals = NULL;\n  unsigned int *out = NULL;\n\n  \n\n  posix_memalign((void**)&keys, 1024, sizeof(unsigned int)*N*16);\n  posix_memalign((void**)&lens, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&initvals, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&out, 1024, sizeof(unsigned int)*N);\n\n  \n\n  srand(2);\n  char src[64];\n  memcpy(src, str, 64);\n  for (unsigned long i = 0; i < N; i++) {\n    memcpy((unsigned char*)keys+i*16*sizeof(unsigned int), src, 64);\n    lens[i] = rand()%61;\n    initvals[i] = i%2;\n  }\n\n  unsigned int* d_keys;\n  hipMalloc((void**)&d_keys, sizeof(unsigned int)*N*16);\n  hipMemcpyAsync(d_keys, keys, sizeof(unsigned int)*N*16, hipMemcpyHostToDevice, 0);\n\n  unsigned int* d_lens;\n  hipMalloc((void**)&d_lens, sizeof(unsigned int)*N);\n  hipMemcpyAsync(d_lens, lens, sizeof(unsigned int)*N, hipMemcpyHostToDevice, 0);\n\n  unsigned int* d_initvals;\n  hipMalloc((void**)&d_initvals, sizeof(unsigned int)*N);\n  hipMemcpyAsync(d_initvals, initvals, sizeof(unsigned int)*N, hipMemcpyHostToDevice, 0);\n\n  unsigned int* d_out;\n  hipMalloc((void**)&d_out, sizeof(unsigned int)*N);\n\n  dim3 grids ((N+block_size-1)/block_size);\n  dim3 threads (block_size);\n\n  hipDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    hipLaunchKernelGGL(kernel, grids, threads, 0, 0, d_lens, d_initvals, d_keys, d_out, N);\n  }\n\n  hipDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time : %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  hipMemcpy(out, d_out, sizeof(unsigned int)*N, hipMemcpyDeviceToHost);\n  hipFree(d_keys);\n  hipFree(d_lens);\n  hipFree(d_initvals);\n  hipFree(d_out);\n\n  printf(\"Verify the results computed on the device..\\n\");\n  bool error = false;\n  for (unsigned long i = 0; i < N; i++) {\n    c = hashlittle(&keys[i*16], lens[i], initvals[i]);\n    if (out[i] != c) {\n      printf(\"Error: at %lu gpu hash is %.8x  cpu hash is %.8x\\n\", i, out[i], c);\n      error = true;\n      break;\n    }\n  }\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(keys);\n  free(lens);\n  free(initvals);\n  free(out);\n\n  return 0;\n}\n"}}
{"kernel_name": "jenkins-hash", "parallel_api": "omp", "code": {"main.cpp": "#include <stdio.h>      \n\n#include <stdlib.h>     \n\n#include <string.h>     \n\n#include <chrono>\n#include <omp.h>\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n\n\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n\n\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\n#pragma omp declare target\nunsigned int mixRemainder(unsigned int a, \n    unsigned int b, \n    unsigned int c, \n    unsigned int k0,\n    unsigned int k1,\n    unsigned int k2,\n    unsigned int length ) \n{\n  switch(length)\n  {\n    case 12: c+=k2; b+=k1; a+=k0; break;\n    case 11: c+=k2&0xffffff; b+=k1; a+=k0; break;\n    case 10: c+=k2&0xffff; b+=k1; a+=k0; break;\n    case 9 : c+=k2&0xff; b+=k1; a+=k0; break;\n    case 8 : b+=k1; a+=k0; break;\n    case 7 : b+=k1&0xffffff; a+=k0; break;\n    case 6 : b+=k1&0xffff; a+=k0; break;\n    case 5 : b+=k1&0xff; a+=k0; break;\n    case 4 : a+=k0; break;\n    case 3 : a+=k0&0xffffff; break;\n    case 2 : a+=k0&0xffff; break;\n    case 1 : a+=k0&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n#pragma omp end declare target\n\nunsigned int hashlittle( const void *key, size_t length, unsigned int initval)\n{\n  unsigned int a,b,c;                                          \n\n\n  \n\n  a = b = c = 0xdeadbeef + ((unsigned int)length) + initval;\n\n  const unsigned int *k = (const unsigned int *)key;         \n\n\n  \n\n  while (length > 12)\n  {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n\n  \n\n  \n\n\n  switch(length)\n  {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\n\nint main(int argc, char** argv) {\n\n  if (argc != 4) {\n    printf(\"Usage: %s <block size> <number of strings> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int block_size = atoi(argv[1]);  \n\n  unsigned long N = atol(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  \n\n  const char* str = \"Four score and seven years ago\";\n  unsigned int c = hashlittle(str, 30, 1);\n  printf(\"input string: %s hash is %.8x\\n\", str, c);   \n\n\n  unsigned int *keys = NULL;\n  unsigned int *lens = NULL;\n  unsigned int *initvals = NULL;\n  unsigned int *out = NULL;\n\n  \n\n  posix_memalign((void**)&keys, 1024, sizeof(unsigned int)*N*16);\n  posix_memalign((void**)&lens, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&initvals, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&out, 1024, sizeof(unsigned int)*N);\n\n  \n\n  srand(2);\n  char src[64];\n  memcpy(src, str, 64);\n  for (unsigned long i = 0; i < N; i++) {\n    memcpy((unsigned char*)keys+i*16*sizeof(unsigned int), src, 64);\n    lens[i] = rand()%61;\n    initvals[i] = i%2;\n  }\n\n  auto start = std::chrono::steady_clock::now();\n\n  #pragma omp target data map(to: keys[0:N*16], lens[0:N], initvals[0:N]) map(from: out[0:N])\n  {\n    for (int n = 0; n < repeat; n++) {\n      #pragma omp target teams distribute parallel for thread_limit(block_size)\n      for (unsigned long id = 0; id < N; id++) {\n        unsigned int length = lens[id];\n        const unsigned int initval = initvals[id];\n        const unsigned int *k = keys+id*16;  \n\n\n        \n\n        unsigned int a,b,c; \n        unsigned int r0,r1,r2;\n        a = b = c = 0xdeadbeef + length + initval;\n\n        \n\n        while (length > 12) {\n          a += k[0];\n          b += k[1];\n          c += k[2];\n          mix(a,b,c);\n          length -= 12;\n          k += 3;\n        }\n        r0 = k[0];\n        r1 = k[1];\n        r2 = k[2];\n\n        \n\n        \n\n        out[id] = mixRemainder(a, b, c, r0, r1, r2, length);\n      }\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time : %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  printf(\"Verify the results computed on the device..\\n\");\n  bool error = false;\n  for (unsigned long i = 0; i < N; i++) {\n    c = hashlittle(&keys[i*16], lens[i], initvals[i]);\n    if (out[i] != c) {\n      printf(\"Error: at %lu gpu hash is %.8x  cpu hash is %.8x\\n\", i, out[i], c);\n      error = true;\n      break;\n    }\n  }\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(keys);\n  free(lens);\n  free(initvals);\n  free(out);\n\n  return 0;\n}\n"}}
{"kernel_name": "jenkins-hash", "parallel_api": "serial", "code": {"main.cpp": "#include <stdio.h>      \n\n#include <stdlib.h>     \n\n#include <string.h>     \n\n#include <chrono>\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n\n\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n\n\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\nunsigned int mixRemainder(unsigned int a, \n    unsigned int b, \n    unsigned int c, \n    unsigned int k0,\n    unsigned int k1,\n    unsigned int k2,\n    unsigned int length ) \n{\n  switch(length)\n  {\n    case 12: c+=k2; b+=k1; a+=k0; break;\n    case 11: c+=k2&0xffffff; b+=k1; a+=k0; break;\n    case 10: c+=k2&0xffff; b+=k1; a+=k0; break;\n    case 9 : c+=k2&0xff; b+=k1; a+=k0; break;\n    case 8 : b+=k1; a+=k0; break;\n    case 7 : b+=k1&0xffffff; a+=k0; break;\n    case 6 : b+=k1&0xffff; a+=k0; break;\n    case 5 : b+=k1&0xff; a+=k0; break;\n    case 4 : a+=k0; break;\n    case 3 : a+=k0&0xffffff; break;\n    case 2 : a+=k0&0xffff; break;\n    case 1 : a+=k0&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\nunsigned int hashlittle( const void *key, size_t length, unsigned int initval)\n{\n  unsigned int a,b,c;                                          \n\n\n  \n\n  a = b = c = 0xdeadbeef + ((unsigned int)length) + initval;\n\n  const unsigned int *k = (const unsigned int *)key;         \n\n\n  \n\n  while (length > 12)\n  {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n\n  \n\n  \n\n\n  switch(length)\n  {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\n\nint main(int argc, char** argv) {\n\n  if (argc != 4) {\n    printf(\"Usage: %s <block size> <number of strings> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int block_size = atoi(argv[1]);  \n\n  unsigned long N = atol(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  \n\n  const char* str = \"Four score and seven years ago\";\n  unsigned int c = hashlittle(str, 30, 1);\n  printf(\"input string: %s hash is %.8x\\n\", str, c);   \n\n\n  unsigned int *keys = NULL;\n  unsigned int *lens = NULL;\n  unsigned int *initvals = NULL;\n  unsigned int *out = NULL;\n\n  \n\n  posix_memalign((void**)&keys, 1024, sizeof(unsigned int)*N*16);\n  posix_memalign((void**)&lens, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&initvals, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&out, 1024, sizeof(unsigned int)*N);\n\n  \n\n  srand(2);\n  char src[64];\n  memcpy(src, str, 64);\n  for (unsigned long i = 0; i < N; i++) {\n    memcpy((unsigned char*)keys+i*16*sizeof(unsigned int), src, 64);\n    lens[i] = rand()%61;\n    initvals[i] = i%2;\n  }\n\n  auto start = std::chrono::steady_clock::now();\n\n    {\n    for (int n = 0; n < repeat; n++) {\n            for (unsigned long id = 0; id < N; id++) {\n        unsigned int length = lens[id];\n        const unsigned int initval = initvals[id];\n        const unsigned int *k = keys+id*16;  \n\n\n        \n\n        unsigned int a,b,c; \n        unsigned int r0,r1,r2;\n        a = b = c = 0xdeadbeef + length + initval;\n\n        \n\n        while (length > 12) {\n          a += k[0];\n          b += k[1];\n          c += k[2];\n          mix(a,b,c);\n          length -= 12;\n          k += 3;\n        }\n        r0 = k[0];\n        r1 = k[1];\n        r2 = k[2];\n\n        \n\n        \n\n        out[id] = mixRemainder(a, b, c, r0, r1, r2, length);\n      }\n    }\n  }\n\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time : %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  printf(\"Verify the results computed on the device..\\n\");\n  bool error = false;\n  for (unsigned long i = 0; i < N; i++) {\n    c = hashlittle(&keys[i*16], lens[i], initvals[i]);\n    if (out[i] != c) {\n      printf(\"Error: at %lu gpu hash is %.8x  cpu hash is %.8x\\n\", i, out[i], c);\n      error = true;\n      break;\n    }\n  }\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(keys);\n  free(lens);\n  free(initvals);\n  free(out);\n\n  return 0;\n}"}}
{"kernel_name": "jenkins-hash", "parallel_api": "sycl", "code": {"main.cpp": "#include <stdio.h>      \n\n#include <stdlib.h>     \n\n#include <string.h>     \n\n#include <sycl/sycl.hpp>\n\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n\n\n\n#define mix(a,b,c) \\\n{ \\\n  a -= c;  a ^= rot(c, 4);  c += b; \\\n  b -= a;  b ^= rot(a, 6);  a += c; \\\n  c -= b;  c ^= rot(b, 8);  b += a; \\\n  a -= c;  a ^= rot(c,16);  c += b; \\\n  b -= a;  b ^= rot(a,19);  a += c; \\\n  c -= b;  c ^= rot(b, 4);  b += a; \\\n}\n\n\n\n#define final(a,b,c) \\\n{ \\\n  c ^= b; c -= rot(b,14); \\\n  a ^= c; a -= rot(c,11); \\\n  b ^= a; b -= rot(a,25); \\\n  c ^= b; c -= rot(b,16); \\\n  a ^= c; a -= rot(c,4);  \\\n  b ^= a; b -= rot(a,14); \\\n  c ^= b; c -= rot(b,24); \\\n}\n\n\nunsigned int mixRemainder(unsigned int a,\n                  unsigned int b,\n                  unsigned int c,\n                  unsigned int k0,\n                  unsigned int k1,\n                  unsigned int k2,\n                  unsigned int length )\n{\n  switch(length)\n  {\n    case 12: c+=k2; b+=k1; a+=k0; break;\n    case 11: c+=k2&0xffffff; b+=k1; a+=k0; break;\n    case 10: c+=k2&0xffff; b+=k1; a+=k0; break;\n    case 9 : c+=k2&0xff; b+=k1; a+=k0; break;\n    case 8 : b+=k1; a+=k0; break;\n    case 7 : b+=k1&0xffffff; a+=k0; break;\n    case 6 : b+=k1&0xffff; a+=k0; break;\n    case 5 : b+=k1&0xff; a+=k0; break;\n    case 4 : a+=k0; break;\n    case 3 : a+=k0&0xffffff; break;\n    case 2 : a+=k0&0xffff; break;\n    case 1 : a+=k0&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\nunsigned int hashlittle( const void *key, size_t length, unsigned int initval)\n{\n  unsigned int a,b,c;                                          \n\n\n  \n\n  a = b = c = 0xdeadbeef + ((unsigned int)length) + initval;\n\n  const unsigned int *k = (const unsigned int *)key;         \n\n\n  \n\n  while (length > 12)\n  {\n    a += k[0];\n    b += k[1];\n    c += k[2];\n    mix(a,b,c);\n    length -= 12;\n    k += 3;\n  }\n\n  \n\n  \n\n\n  switch(length)\n  {\n    case 12: c+=k[2]; b+=k[1]; a+=k[0]; break;\n    case 11: c+=k[2]&0xffffff; b+=k[1]; a+=k[0]; break;\n    case 10: c+=k[2]&0xffff; b+=k[1]; a+=k[0]; break;\n    case 9 : c+=k[2]&0xff; b+=k[1]; a+=k[0]; break;\n    case 8 : b+=k[1]; a+=k[0]; break;\n    case 7 : b+=k[1]&0xffffff; a+=k[0]; break;\n    case 6 : b+=k[1]&0xffff; a+=k[0]; break;\n    case 5 : b+=k[1]&0xff; a+=k[0]; break;\n    case 4 : a+=k[0]; break;\n    case 3 : a+=k[0]&0xffffff; break;\n    case 2 : a+=k[0]&0xffff; break;\n    case 1 : a+=k[0]&0xff; break;\n    case 0 : return c;              \n\n  }\n\n  final(a,b,c);\n  return c;\n}\n\n\nint main(int argc, char** argv) {\n\n  if (argc != 4) {\n    printf(\"Usage: %s <block size> <number of strings> <repeat>\\n\", argv[0]);\n    return 1;\n  }\n\n  int block_size = atoi(argv[1]);  \n\n  unsigned long N = atol(argv[2]); \n\n  int repeat = atoi(argv[3]);\n\n  \n\n  const char* str = \"Four score and seven years ago\";\n  unsigned int c = hashlittle(str, 30, 1);\n  printf(\"input string: %s hash is %.8x\\n\", str, c);   \n\n\n  unsigned int *keys = NULL;\n  unsigned int *lens = NULL;\n  unsigned int *initvals = NULL;\n  unsigned int *out = NULL;\n\n  \n\n  posix_memalign((void**)&keys, 1024, sizeof(unsigned int)*N*16);\n  posix_memalign((void**)&lens, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&initvals, 1024, sizeof(unsigned int)*N);\n  posix_memalign((void**)&out, 1024, sizeof(unsigned int)*N);\n\n  \n\n  srand(2);\n  char src[64];\n  memcpy(src, str, 64);\n  for (unsigned long i = 0; i < N; i++) {\n    memcpy((unsigned char*)keys+i*16*sizeof(unsigned int), src, 64);\n    lens[i] = rand()%61;\n    initvals[i] = i%2;\n  }\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  unsigned int *d_keys = sycl::malloc_device<unsigned int>(N*16, q);\n  q.memcpy(d_keys, keys, sizeof(unsigned int)*N*16);\n\n  unsigned int *d_lens = sycl::malloc_device<unsigned int>(N, q);\n  q.memcpy(d_lens, lens, sizeof(unsigned int)*N);\n\n  unsigned int *d_initvals = sycl::malloc_device<unsigned int>(N, q);\n  q.memcpy(d_initvals, initvals, sizeof(unsigned int)*N);\n\n  unsigned int *d_out = sycl::malloc_device<unsigned int>(N, q);\n\n  \n\n  sycl::range<1> gws ((N+block_size-1)/block_size*block_size);\n  sycl::range<1> lws (block_size);\n\n  q.wait();\n  auto start = std::chrono::steady_clock::now();\n\n  for (int n = 0; n < repeat; n++) {\n    q.submit([&](sycl::handler &h) {\n      h.parallel_for<class jk3_hash>(\n        sycl::nd_range<1>(gws, lws), [=](sycl::nd_item<1> item) {\n        unsigned long id = item.get_global_id(0);\n        if (id >= N) return;\n        unsigned int length = d_lens[id];\n        const unsigned int initval = d_initvals[id];\n        const unsigned int *k = d_keys+id*16;  \n\n\n        \n\n        unsigned int a,b,c;\n        unsigned int r0,r1,r2;\n        a = b = c = 0xdeadbeef + length + initval;\n\n        \n\n        while (length > 12) {\n          a += k[0];\n          b += k[1];\n          c += k[2];\n          mix(a,b,c);\n          length -= 12;\n          k += 3;\n        }\n        r0 = k[0];\n        r1 = k[1];\n        r2 = k[2];\n\n        \n\n        \n\n        d_out[id] = mixRemainder(a, b, c, r0, r1, r2, length);\n      });\n    });\n  }\n\n  q.wait();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time : %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  q.memcpy(out, d_out, sizeof(unsigned int)*N).wait();\n  sycl::free(d_keys, q);\n  sycl::free(d_lens, q);\n  sycl::free(d_initvals, q);\n  sycl::free(d_out, q);\n\n  printf(\"Verify the results computed on the device..\\n\");\n  bool error = false;\n  for (unsigned long i = 0; i < N; i++) {\n    c = hashlittle(&keys[i*16], lens[i], initvals[i]);\n    if (out[i] != c) {\n       printf(\"Error: at %lu gpu hash is %.8x  cpu hash is %.8x\\n\", i, out[i], c);\n       error = true;\n       break;\n    }\n  }\n\n  printf(\"%s\\n\", error ? \"FAIL\" : \"PASS\");\n\n  free(keys);\n  free(lens);\n  free(initvals);\n  free(out);\n\n  return 0;\n}\n"}}
{"kernel_name": "murmurhash3", "parallel_api": "cuda", "code": {"murmurhash3.cu": "\n\n\n\n\n\n\n\n\n#include <cstdlib>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <cuda.h>\n\n#define BLOCK_SIZE 256\n\n#define FORCE_INLINE inline __attribute__((always_inline))\n\n__host__ __device__\ninline uint64_t rotl64 ( uint64_t x, int8_t r )\n{\n  return (x << r) | (x >> (64 - r));\n}\n\n#define BIG_CONSTANT(x) (x##LU)\n\n\n\n\n\n__host__ __device__\nFORCE_INLINE uint64_t getblock64 ( const uint8_t * p, uint32_t i )\n{\n  uint64_t s = 0;\n  for (uint32_t n = 0; n < 8; n++) {\n    s |= ((uint64_t)p[8*i+n] << (n*8));\n  }\n  return s;\n}\n\n\n\n__host__ __device__\nFORCE_INLINE uint64_t fmix64 ( uint64_t k )\n{\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xff51afd7ed558ccd);\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);\n  k ^= k >> 33;\n  return k;\n}\n\n__host__ __device__ \nvoid MurmurHash3_x64_128 (const void * key, const uint32_t len,\n                          const uint32_t seed, void * out)\n{\n  const uint8_t * data = (const uint8_t*)key;\n  const uint32_t nblocks = len / 16;\n\n  uint64_t h1 = seed;\n  uint64_t h2 = seed;\n\n  const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);\n  const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);\n\n  for(uint32_t i = 0; i < nblocks; i++)\n  {\n    uint64_t k1 = getblock64(data,i*2+0);\n    uint64_t k2 = getblock64(data,i*2+1);\n\n    k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n\n    h1 = rotl64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n\n    k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    h2 = rotl64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n  }\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*16);\n\n  uint64_t k1 = 0;\n  uint64_t k2 = 0;\n\n  switch(len & 15)\n  {\n    case 15: k2 ^= ((uint64_t)tail[14]) << 48;\n    case 14: k2 ^= ((uint64_t)tail[13]) << 40;\n    case 13: k2 ^= ((uint64_t)tail[12]) << 32;\n    case 12: k2 ^= ((uint64_t)tail[11]) << 24;\n    case 11: k2 ^= ((uint64_t)tail[10]) << 16;\n    case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;\n    case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;\n       k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;\n    case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;\n    case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;\n    case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;\n    case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;\n    case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;\n    case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;\n    case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;\n       k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n  };\n\n  h1 ^= len; h2 ^= len;\n\n  h1 += h2;\n  h2 += h1;\n\n  h1 = fmix64(h1);\n  h2 = fmix64(h2);\n\n  h1 += h2;\n  h2 += h1;\n\n  ((uint64_t*)out)[0] = h1;\n  ((uint64_t*)out)[1] = h2;\n}\n\n__global__\nvoid MurmurHash3_x64_128_kernel (\n   const uint8_t *__restrict__ d_keys,\n   const uint32_t *__restrict__ d_length,\n   const uint32_t *__restrict__ length, \n         uint64_t *__restrict__ d_out,\n   const uint32_t numKeys )\n{\n  uint32_t i = blockDim.x * blockIdx.x + threadIdx.x;\n  if (i < numKeys) \n    MurmurHash3_x64_128 (d_keys+d_length[i], length[i], i, d_out+i*2);\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of keys> <repeat>\\n\", argv[0]);\n    return 1;\n  } \n  uint32_t numKeys = atoi(argv[1]);\n  uint32_t repeat = atoi(argv[2]);\n\n  srand(3);\n  uint32_t i;\n  \n\n  uint32_t* length = (uint32_t*) malloc (sizeof(uint32_t) * numKeys);\n  \n\n  uint8_t** keys = (uint8_t**) malloc (sizeof(uint8_t*) * numKeys);\n  \n\n  uint64_t** out = (uint64_t**) malloc (sizeof(uint64_t*) * numKeys);\n\n  for (i = 0; i < numKeys; i++) {\n    length[i] = rand() % 10000;\n    keys[i] = (uint8_t*) malloc (length[i]);\n    out[i] = (uint64_t*) malloc (2*sizeof(uint64_t));\n    for (uint32_t c = 0; c < length[i]; c++) {\n      keys[i][c] = c % 256;\n    }\n    MurmurHash3_x64_128 (keys[i], length[i], i, out[i]);\n#ifdef DEBUG\n    printf(\"%lu %lu\\n\", out[i][0], out[i][1]);\n#endif\n  }\n\n  \n\n  uint64_t* d_out = (uint64_t*) malloc (sizeof(uint64_t) * 2 * numKeys);\n  uint32_t* d_length = (uint32_t*) malloc (sizeof(uint32_t) * (numKeys+1));\n\n  \n\n  uint32_t total_length = 0;\n  d_length[0] = 0;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    total_length += length[i];\n    d_length[i+1] = total_length;\n  }\n\n  \n\n  uint8_t* d_keys = (uint8_t*) malloc (sizeof(uint8_t) * total_length);\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    memcpy(d_keys+d_length[i], keys[i], length[i]);\n  }\n\n  \n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    assert (0 == memcmp(d_keys+d_length[i], keys[i], length[i]));\n  }\n\n  uint8_t* dev_keys;\n  cudaMalloc((void**)&dev_keys, sizeof(uint8_t)*total_length);\n  cudaMemcpy(dev_keys, d_keys, sizeof(uint8_t)*total_length, cudaMemcpyHostToDevice);\n\n  uint32_t* dev_length;\n  cudaMalloc((void**)&dev_length, sizeof(uint32_t)*(numKeys+1));\n  cudaMemcpy(dev_length, d_length, sizeof(uint32_t)*(numKeys+1), cudaMemcpyHostToDevice);\n\n  uint32_t* key_length;\n  cudaMalloc((void**)&key_length, sizeof(uint32_t)*(numKeys+1));\n  cudaMemcpy(key_length, length, sizeof(uint32_t)*(numKeys), cudaMemcpyHostToDevice);\n\n  uint64_t* dev_out;\n  cudaMalloc((void**)&dev_out, sizeof(uint64_t)*(numKeys*2));\n\n  dim3 gridDim ((numKeys+BLOCK_SIZE-1)/BLOCK_SIZE*BLOCK_SIZE);\n  dim3 blockDim(BLOCK_SIZE);\n\n  cudaDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  for (uint32_t n = 0; n < repeat; n++)  \n    MurmurHash3_x64_128_kernel<<<gridDim, blockDim>>>(\n      dev_keys, dev_length, key_length, dev_out, numKeys);\n\n  cudaDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  cudaMemcpy(d_out, dev_out, sizeof(uint64_t)*(numKeys*2), cudaMemcpyDeviceToHost);\n\n  \n\n  bool error = false;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    if (d_out[2*i] != out[i][0] ||  d_out[2*i+1] != out[i][1]) {\n      error = true;\n      break;\n    }\n  }\n  if (error) printf(\"FAIL\\n\");\n  else printf(\"SUCCESS\\n\");\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    free(out[i]);\n    free(keys[i]);\n  }\n  free(keys);\n  free(out);\n  free(length);\n  free(d_keys);\n  free(d_out);\n  free(d_length);\n  cudaFree(dev_keys);\n  cudaFree(dev_out);\n  cudaFree(dev_length);\n  cudaFree(key_length);\n  return 0;\n}\n"}}
{"kernel_name": "murmurhash3", "parallel_api": "hip", "code": {"murmurhash3.cu": "\n\n\n\n\n\n\n\n\n#include <cstdlib>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <hip/hip_runtime.h>\n\n#define BLOCK_SIZE 256\n\n#define FORCE_INLINE inline __attribute__((always_inline))\n\n__host__ __device__\ninline uint64_t rotl64 ( uint64_t x, int8_t r )\n{\n  return (x << r) | (x >> (64 - r));\n}\n\n#define BIG_CONSTANT(x) (x##LU)\n\n\n\n\n\n__host__ __device__\nFORCE_INLINE uint64_t getblock64 ( const uint8_t * p, uint32_t i )\n{\n  uint64_t s = 0;\n  for (uint32_t n = 0; n < 8; n++) {\n    s |= ((uint64_t)p[8*i+n] << (n*8));\n  }\n  return s;\n}\n\n\n\n__host__ __device__\nFORCE_INLINE uint64_t fmix64 ( uint64_t k )\n{\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xff51afd7ed558ccd);\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);\n  k ^= k >> 33;\n  return k;\n}\n\n__host__ __device__ \nvoid MurmurHash3_x64_128 (const void * key, const uint32_t len,\n                          const uint32_t seed, void * out)\n{\n  const uint8_t * data = (const uint8_t*)key;\n  const uint32_t nblocks = len / 16;\n\n  uint64_t h1 = seed;\n  uint64_t h2 = seed;\n\n  const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);\n  const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);\n\n  for(uint32_t i = 0; i < nblocks; i++)\n  {\n    uint64_t k1 = getblock64(data,i*2+0);\n    uint64_t k2 = getblock64(data,i*2+1);\n\n    k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n\n    h1 = rotl64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n\n    k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    h2 = rotl64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n  }\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*16);\n\n  uint64_t k1 = 0;\n  uint64_t k2 = 0;\n\n  switch(len & 15)\n  {\n    case 15: k2 ^= ((uint64_t)tail[14]) << 48;\n    case 14: k2 ^= ((uint64_t)tail[13]) << 40;\n    case 13: k2 ^= ((uint64_t)tail[12]) << 32;\n    case 12: k2 ^= ((uint64_t)tail[11]) << 24;\n    case 11: k2 ^= ((uint64_t)tail[10]) << 16;\n    case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;\n    case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;\n       k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;\n    case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;\n    case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;\n    case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;\n    case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;\n    case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;\n    case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;\n    case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;\n       k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n  };\n\n  h1 ^= len; h2 ^= len;\n\n  h1 += h2;\n  h2 += h1;\n\n  h1 = fmix64(h1);\n  h2 = fmix64(h2);\n\n  h1 += h2;\n  h2 += h1;\n\n  ((uint64_t*)out)[0] = h1;\n  ((uint64_t*)out)[1] = h2;\n}\n\n__global__\nvoid MurmurHash3_x64_128_kernel (\n   const uint8_t *__restrict__ d_keys,\n   const uint32_t *__restrict__ d_length,\n   const uint32_t *__restrict__ length, \n         uint64_t *__restrict__ d_out,\n   const uint32_t numKeys )\n{\n  uint32_t i = blockDim.x * blockIdx.x + threadIdx.x;\n  if (i < numKeys) \n    MurmurHash3_x64_128 (d_keys+d_length[i], length[i], i, d_out+i*2);\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of keys> <repeat>\\n\", argv[0]);\n    return 1;\n  } \n  uint32_t numKeys = atoi(argv[1]);\n  uint32_t repeat = atoi(argv[2]);\n\n  srand(3);\n  uint32_t i;\n  \n\n  uint32_t* length = (uint32_t*) malloc (sizeof(uint32_t) * numKeys);\n  \n\n  uint8_t** keys = (uint8_t**) malloc (sizeof(uint8_t*) * numKeys);\n  \n\n  uint64_t** out = (uint64_t**) malloc (sizeof(uint64_t*) * numKeys);\n\n  for (i = 0; i < numKeys; i++) {\n    length[i] = rand() % 10000;\n    keys[i] = (uint8_t*) malloc (length[i]);\n    out[i] = (uint64_t*) malloc (2*sizeof(uint64_t));\n    for (uint32_t c = 0; c < length[i]; c++) {\n      keys[i][c] = c % 256;\n    }\n    MurmurHash3_x64_128 (keys[i], length[i], i, out[i]);\n#ifdef DEBUG\n    printf(\"%lu %lu\\n\", out[i][0], out[i][1]);\n#endif\n  }\n\n  \n\n  uint64_t* d_out = (uint64_t*) malloc (sizeof(uint64_t) * 2 * numKeys);\n  uint32_t* d_length = (uint32_t*) malloc (sizeof(uint32_t) * (numKeys+1));\n\n  \n\n  uint32_t total_length = 0;\n  d_length[0] = 0;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    total_length += length[i];\n    d_length[i+1] = total_length;\n  }\n\n  \n\n  uint8_t* d_keys = (uint8_t*) malloc (sizeof(uint8_t) * total_length);\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    memcpy(d_keys+d_length[i], keys[i], length[i]);\n  }\n\n  \n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    assert (0 == memcmp(d_keys+d_length[i], keys[i], length[i]));\n  }\n\n  uint8_t* dev_keys;\n  hipMalloc((void**)&dev_keys, sizeof(uint8_t)*total_length);\n  hipMemcpy(dev_keys, d_keys, sizeof(uint8_t)*total_length, hipMemcpyHostToDevice);\n\n  uint32_t* dev_length;\n  hipMalloc((void**)&dev_length, sizeof(uint32_t)*(numKeys+1));\n  hipMemcpy(dev_length, d_length, sizeof(uint32_t)*(numKeys+1), hipMemcpyHostToDevice);\n\n  uint32_t* key_length;\n  hipMalloc((void**)&key_length, sizeof(uint32_t)*(numKeys+1));\n  hipMemcpy(key_length, length, sizeof(uint32_t)*(numKeys), hipMemcpyHostToDevice);\n\n  uint64_t* dev_out;\n  hipMalloc((void**)&dev_out, sizeof(uint64_t)*(numKeys*2));\n\n  dim3 gridDim ((numKeys+BLOCK_SIZE-1)/BLOCK_SIZE*BLOCK_SIZE);\n  dim3 blockDim(BLOCK_SIZE);\n\n  hipDeviceSynchronize();\n  auto start = std::chrono::steady_clock::now();\n\n  for (uint32_t n = 0; n < repeat; n++)  \n    hipLaunchKernelGGL(MurmurHash3_x64_128_kernel, gridDim, blockDim, 0, 0, \n      dev_keys, dev_length, key_length, dev_out, numKeys);\n\n  hipDeviceSynchronize();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  hipMemcpy(d_out, dev_out, sizeof(uint64_t)*(numKeys*2), hipMemcpyDeviceToHost);\n\n  \n\n  bool error = false;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    if (d_out[2*i] != out[i][0] ||  d_out[2*i+1] != out[i][1]) {\n      error = true;\n      break;\n    }\n  }\n  if (error) printf(\"FAIL\\n\");\n  else printf(\"SUCCESS\\n\");\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    free(out[i]);\n    free(keys[i]);\n  }\n  free(keys);\n  free(out);\n  free(length);\n  free(d_keys);\n  free(d_out);\n  free(d_length);\n  hipFree(dev_keys);\n  hipFree(dev_out);\n  hipFree(dev_length);\n  hipFree(key_length);\n  return 0;\n}\n"}}
{"kernel_name": "murmurhash3", "parallel_api": "omp", "code": {"murmurhash3.cpp": "\n\n\n\n\n\n\n\n\n#include <cstdlib>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <omp.h>\n\n#define BLOCK_SIZE 256\n\n#define  FORCE_INLINE inline __attribute__((always_inline))\n\ninline uint64_t rotl64 ( uint64_t x, int8_t r )\n{\n  return (x << r) | (x >> (64 - r));\n}\n\n#define ROTL64(x,y)  rotl64(x,y)\n\n#define BIG_CONSTANT(x) (x##LLU)\n\n\n\n\n\n\nFORCE_INLINE uint64_t getblock64 ( const uint8_t * p, uint32_t i )\n{\n  uint64_t s = 0;\n  for (uint32_t n = 0; n < 8; n++) {\n    s |= ((uint64_t)p[8*i+n] << (n*8));\n  }\n  return s;\n}\n\n\n\nFORCE_INLINE uint64_t fmix64 ( uint64_t k )\n{\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xff51afd7ed558ccd);\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);\n  k ^= k >> 33;\n\n  return k;\n}\n\n#pragma omp declare target \nvoid MurmurHash3_x64_128 (const void * key, const uint32_t len,\n                          const uint32_t seed, void * out)\n{\n  const uint8_t * data = (const uint8_t*)key;\n  const uint32_t nblocks = len / 16;\n\n  uint64_t h1 = seed;\n  uint64_t h2 = seed;\n\n  const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);\n  const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);\n\n  for(uint32_t i = 0; i < nblocks; i++)\n  {\n    uint64_t k1 = getblock64(data,i*2+0);\n    uint64_t k2 = getblock64(data,i*2+1);\n\n    k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;\n\n    h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n\n    k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;\n\n    h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n  }\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*16);\n\n  uint64_t k1 = 0;\n  uint64_t k2 = 0;\n\n  switch(len & 15)\n  {\n    case 15: k2 ^= ((uint64_t)tail[14]) << 48;\n    case 14: k2 ^= ((uint64_t)tail[13]) << 40;\n    case 13: k2 ^= ((uint64_t)tail[12]) << 32;\n    case 12: k2 ^= ((uint64_t)tail[11]) << 24;\n    case 11: k2 ^= ((uint64_t)tail[10]) << 16;\n    case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;\n    case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;\n       k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;\n\n    case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;\n    case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;\n    case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;\n    case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;\n    case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;\n    case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;\n    case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;\n    case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;\n       k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;\n  };\n\n  h1 ^= len; h2 ^= len;\n\n  h1 += h2;\n  h2 += h1;\n\n  h1 = fmix64(h1);\n  h2 = fmix64(h2);\n\n  h1 += h2;\n  h2 += h1;\n\n  ((uint64_t*)out)[0] = h1;\n  ((uint64_t*)out)[1] = h2;\n}\n#pragma omp end declare target \n\nint main(int argc, char** argv) \n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of keys> <repeat>\\n\", argv[0]);\n    return 1;\n  } \n  uint32_t numKeys = atoi(argv[1]);\n  uint32_t repeat = atoi(argv[2]);\n\n  srand(3);\n  uint32_t i;\n  \n\n  uint32_t* length = (uint32_t*) malloc (sizeof(uint32_t) * numKeys);\n  \n\n  uint8_t** keys = (uint8_t**) malloc (sizeof(uint8_t*) * numKeys);\n  \n\n  uint64_t** out = (uint64_t**) malloc (sizeof(uint64_t*) * numKeys);\n\n  for (i = 0; i < numKeys; i++) {\n    length[i] = rand() % 10000;\n    keys[i] = (uint8_t*) malloc (length[i]);\n    out[i] = (uint64_t*) malloc (2*sizeof(uint64_t));\n    for (uint32_t c = 0; c < length[i]; c++) {\n      keys[i][c] = c % 256;\n    }\n    MurmurHash3_x64_128 (keys[i], length[i], i, out[i]);\n#ifdef DEBUG\n    printf(\"%lu %lu\\n\", out[i][0], out[i][1]);\n#endif\n  }\n\n  \n\n  \n\n  \n\n  uint64_t* d_out = (uint64_t*) malloc (sizeof(uint64_t) * 2 * numKeys);\n  uint32_t* d_length = (uint32_t*) malloc (sizeof(uint32_t) * (numKeys+1));\n\n  \n\n  uint32_t total_length = 0;\n  d_length[0] = 0;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    total_length += length[i];\n    d_length[i+1] = total_length;\n  }\n\n  \n\n  uint8_t* d_keys = (uint8_t*) malloc (sizeof(uint8_t) * total_length);\n  for (uint32_t i = 0; i < numKeys; i++) {\n    memcpy(d_keys+d_length[i], keys[i], length[i]);\n  }\n  \n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    assert (0 == memcmp(d_keys+d_length[i], keys[i], length[i]));\n  }\n\n\n  #pragma omp target data map(to: d_keys[0:total_length], \\\n                                  d_length[0:numKeys+1], \\\n                                  length[0:numKeys]) \\\n                          map(from: d_out[0:2*numKeys])\n  {\n    auto start = std::chrono::steady_clock::now();\n\n    for (uint32_t n = 0; n < repeat; n++) {\n      #pragma omp target teams distribute parallel for thread_limit(BLOCK_SIZE)\n      for (uint32_t i = 0; i < numKeys; i++) {\n        MurmurHash3_x64_128 (d_keys+d_length[i], length[i], i, d_out+i*2);\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  bool error = false;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    if (d_out[2*i] != out[i][0] ||  d_out[2*i+1] != out[i][1]) {\n      error = true;\n      break;\n    }\n  }\n  if (error) printf(\"FAIL\\n\");\n  else printf(\"SUCCESS\\n\");\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    free(out[i]);\n    free(keys[i]);\n  }\n  free(keys);\n  free(out);\n  free(length);\n  free(d_keys);\n  free(d_out);\n  free(d_length);\n  return 0;\n}\n"}}
{"kernel_name": "murmurhash3", "parallel_api": "serial", "code": {"murmurhash3.cpp": "\n\n\n\n\n\n\n\n\n#include <cstdlib>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n\n#define BLOCK_SIZE 256\n\n#define  FORCE_INLINE inline __attribute__((always_inline))\n\ninline uint64_t rotl64 ( uint64_t x, int8_t r )\n{\n  return (x << r) | (x >> (64 - r));\n}\n\n#define ROTL64(x,y)  rotl64(x,y)\n\n#define BIG_CONSTANT(x) (x##LLU)\n\n\n\n\n\n\nFORCE_INLINE uint64_t getblock64 ( const uint8_t * p, uint32_t i )\n{\n  uint64_t s = 0;\n  for (uint32_t n = 0; n < 8; n++) {\n    s |= ((uint64_t)p[8*i+n] << (n*8));\n  }\n  return s;\n}\n\n\n\nFORCE_INLINE uint64_t fmix64 ( uint64_t k )\n{\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xff51afd7ed558ccd);\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);\n  k ^= k >> 33;\n\n  return k;\n}\n\nvoid MurmurHash3_x64_128 (const void * key, const uint32_t len,\n                          const uint32_t seed, void * out)\n{\n  const uint8_t * data = (const uint8_t*)key;\n  const uint32_t nblocks = len / 16;\n\n  uint64_t h1 = seed;\n  uint64_t h2 = seed;\n\n  const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);\n  const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);\n\n  for(uint32_t i = 0; i < nblocks; i++)\n  {\n    uint64_t k1 = getblock64(data,i*2+0);\n    uint64_t k2 = getblock64(data,i*2+1);\n\n    k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;\n\n    h1 = ROTL64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n\n    k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;\n\n    h2 = ROTL64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n  }\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*16);\n\n  uint64_t k1 = 0;\n  uint64_t k2 = 0;\n\n  switch(len & 15)\n  {\n    case 15: k2 ^= ((uint64_t)tail[14]) << 48;\n    case 14: k2 ^= ((uint64_t)tail[13]) << 40;\n    case 13: k2 ^= ((uint64_t)tail[12]) << 32;\n    case 12: k2 ^= ((uint64_t)tail[11]) << 24;\n    case 11: k2 ^= ((uint64_t)tail[10]) << 16;\n    case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;\n    case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;\n       k2 *= c2; k2  = ROTL64(k2,33); k2 *= c1; h2 ^= k2;\n\n    case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;\n    case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;\n    case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;\n    case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;\n    case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;\n    case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;\n    case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;\n    case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;\n       k1 *= c1; k1  = ROTL64(k1,31); k1 *= c2; h1 ^= k1;\n  };\n\n  h1 ^= len; h2 ^= len;\n\n  h1 += h2;\n  h2 += h1;\n\n  h1 = fmix64(h1);\n  h2 = fmix64(h2);\n\n  h1 += h2;\n  h2 += h1;\n\n  ((uint64_t*)out)[0] = h1;\n  ((uint64_t*)out)[1] = h2;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of keys> <repeat>\\n\", argv[0]);\n    return 1;\n  } \n  uint32_t numKeys = atoi(argv[1]);\n  uint32_t repeat = atoi(argv[2]);\n\n  srand(3);\n  uint32_t i;\n  \n\n  uint32_t* length = (uint32_t*) malloc (sizeof(uint32_t) * numKeys);\n  \n\n  uint8_t** keys = (uint8_t**) malloc (sizeof(uint8_t*) * numKeys);\n  \n\n  uint64_t** out = (uint64_t**) malloc (sizeof(uint64_t*) * numKeys);\n\n  for (i = 0; i < numKeys; i++) {\n    length[i] = rand() % 10000;\n    keys[i] = (uint8_t*) malloc (length[i]);\n    out[i] = (uint64_t*) malloc (2*sizeof(uint64_t));\n    for (uint32_t c = 0; c < length[i]; c++) {\n      keys[i][c] = c % 256;\n    }\n    MurmurHash3_x64_128 (keys[i], length[i], i, out[i]);\n#ifdef DEBUG\n    printf(\"%lu %lu\\n\", out[i][0], out[i][1]);\n#endif\n  }\n\n  \n\n  \n\n  \n\n  uint64_t* d_out = (uint64_t*) malloc (sizeof(uint64_t) * 2 * numKeys);\n  uint32_t* d_length = (uint32_t*) malloc (sizeof(uint32_t) * (numKeys+1));\n\n  \n\n  uint32_t total_length = 0;\n  d_length[0] = 0;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    total_length += length[i];\n    d_length[i+1] = total_length;\n  }\n\n  \n\n  uint8_t* d_keys = (uint8_t*) malloc (sizeof(uint8_t) * total_length);\n  for (uint32_t i = 0; i < numKeys; i++) {\n    memcpy(d_keys+d_length[i], keys[i], length[i]);\n  }\n  \n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    assert (0 == memcmp(d_keys+d_length[i], keys[i], length[i]));\n  }\n\n\n    {\n    auto start = std::chrono::steady_clock::now();\n\n    for (uint32_t n = 0; n < repeat; n++) {\n            for (uint32_t i = 0; i < numKeys; i++) {\n        MurmurHash3_x64_128 (d_keys+d_length[i], length[i], i, d_out+i*2);\n      }\n    }\n\n    auto end = std::chrono::steady_clock::now();\n    auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n    printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n  }\n\n  \n\n  bool error = false;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    if (d_out[2*i] != out[i][0] ||  d_out[2*i+1] != out[i][1]) {\n      error = true;\n      break;\n    }\n  }\n  if (error) printf(\"FAIL\\n\");\n  else printf(\"SUCCESS\\n\");\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    free(out[i]);\n    free(keys[i]);\n  }\n  free(keys);\n  free(out);\n  free(length);\n  free(d_keys);\n  free(d_out);\n  free(d_length);\n  return 0;\n}"}}
{"kernel_name": "murmurhash3", "parallel_api": "sycl", "code": {"murmurhash3.cpp": "\n\n\n\n\n\n\n\n\n#include <cstdlib>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <sycl/sycl.hpp>\n\n#define BLOCK_SIZE 256\n\n#define  FORCE_INLINE inline __attribute__((always_inline))\n\ninline uint64_t rotl64 ( uint64_t x, int8_t r )\n{\n  return (x << r) | (x >> (64 - r));\n}\n\n#define BIG_CONSTANT(x) (x##LU)\n\n\n\n\n\nFORCE_INLINE uint64_t getblock64 ( const uint8_t * p, uint32_t i )\n{\n  uint64_t s = 0;\n  for (uint32_t n = 0; n < 8; n++) {\n    s |= ((uint64_t)p[8*i+n] << (n*8));\n  }\n  return s;\n}\n\n\n\n\n\nFORCE_INLINE uint64_t fmix64 ( uint64_t k )\n{\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xff51afd7ed558ccd);\n  k ^= k >> 33;\n  k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);\n  k ^= k >> 33;\n  return k;\n}\n\nvoid MurmurHash3_x64_128 (const void * key, const uint32_t len,\n                          const uint32_t seed, void * out)\n{\n  const uint8_t * data = (const uint8_t*)key;\n  const uint32_t nblocks = len / 16;\n\n  uint64_t h1 = seed;\n  uint64_t h2 = seed;\n\n  const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);\n  const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);\n\n  for(uint32_t i = 0; i < nblocks; i++)\n  {\n    uint64_t k1 = getblock64(data,i*2+0);\n    uint64_t k2 = getblock64(data,i*2+1);\n\n    k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n\n    h1 = rotl64(h1,27); h1 += h2; h1 = h1*5+0x52dce729;\n\n    k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    h2 = rotl64(h2,31); h2 += h1; h2 = h2*5+0x38495ab5;\n  }\n\n  const uint8_t * tail = (const uint8_t*)(data + nblocks*16);\n\n  uint64_t k1 = 0;\n  uint64_t k2 = 0;\n\n  switch(len & 15)\n  {\n    case 15: k2 ^= ((uint64_t)tail[14]) << 48;\n    case 14: k2 ^= ((uint64_t)tail[13]) << 40;\n    case 13: k2 ^= ((uint64_t)tail[12]) << 32;\n    case 12: k2 ^= ((uint64_t)tail[11]) << 24;\n    case 11: k2 ^= ((uint64_t)tail[10]) << 16;\n    case 10: k2 ^= ((uint64_t)tail[ 9]) << 8;\n    case  9: k2 ^= ((uint64_t)tail[ 8]) << 0;\n       k2 *= c2; k2  = rotl64(k2,33); k2 *= c1; h2 ^= k2;\n\n    case  8: k1 ^= ((uint64_t)tail[ 7]) << 56;\n    case  7: k1 ^= ((uint64_t)tail[ 6]) << 48;\n    case  6: k1 ^= ((uint64_t)tail[ 5]) << 40;\n    case  5: k1 ^= ((uint64_t)tail[ 4]) << 32;\n    case  4: k1 ^= ((uint64_t)tail[ 3]) << 24;\n    case  3: k1 ^= ((uint64_t)tail[ 2]) << 16;\n    case  2: k1 ^= ((uint64_t)tail[ 1]) << 8;\n    case  1: k1 ^= ((uint64_t)tail[ 0]) << 0;\n       k1 *= c1; k1  = rotl64(k1,31); k1 *= c2; h1 ^= k1;\n  };\n\n  h1 ^= len; h2 ^= len;\n\n  h1 += h2;\n  h2 += h1;\n\n  h1 = fmix64(h1);\n  h2 = fmix64(h2);\n\n  h1 += h2;\n  h2 += h1;\n\n  ((uint64_t*)out)[0] = h1;\n  ((uint64_t*)out)[1] = h2;\n}\n\nint main(int argc, char** argv) \n{\n  if (argc != 3) {\n    printf(\"Usage: %s <number of keys> <repeat>\\n\", argv[0]);\n    return 1;\n  } \n  uint32_t numKeys = atoi(argv[1]);\n  uint32_t repeat = atoi(argv[2]);\n\n  srand(3);\n  uint32_t i;\n  \n\n  uint32_t* length = (uint32_t*) malloc (sizeof(uint32_t) * numKeys);\n  \n\n  uint8_t** keys = (uint8_t**) malloc (sizeof(uint8_t*) * numKeys);\n  \n\n  uint64_t** out = (uint64_t**) malloc (sizeof(uint64_t*) * numKeys);\n\n  for (i = 0; i < numKeys; i++) {\n    length[i] = rand() % 10000;\n    keys[i] = (uint8_t*) malloc (length[i]);\n    out[i] = (uint64_t*) malloc (2*sizeof(uint64_t));\n    for (uint32_t c = 0; c < length[i]; c++) {\n      keys[i][c] = c % 256;\n    }\n    MurmurHash3_x64_128 (keys[i], length[i], i, out[i]);\n#ifdef DEBUG\n    printf(\"%lu %lu\\n\", out[i][0], out[i][1]);\n#endif\n  }\n\n  \n\n  uint64_t* d_out = (uint64_t*) malloc (sizeof(uint64_t) * 2 * numKeys);\n  uint32_t* d_length = (uint32_t*) malloc (sizeof(uint32_t) * (numKeys+1));\n\n  \n\n  uint32_t total_length = 0;\n  d_length[0] = 0;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    total_length += length[i];\n    d_length[i+1] = total_length;\n  }\n\n  \n\n  uint8_t* d_keys = (uint8_t*) malloc (sizeof(uint8_t) * total_length);\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    memcpy(d_keys+d_length[i], keys[i], length[i]);\n  }\n\n  \n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    assert (0 == memcmp(d_keys+d_length[i], keys[i], length[i]));\n  }\n\n#ifdef USE_GPU\n  sycl::queue q(sycl::gpu_selector_v, sycl::property::queue::in_order());\n#else\n  sycl::queue q(sycl::cpu_selector_v, sycl::property::queue::in_order());\n#endif\n\n  uint8_t *dev_keys = sycl::malloc_device<uint8_t>(total_length, q);\n  q.memcpy(dev_keys, d_keys, sizeof(uint8_t)*total_length);\n\n  uint64_t *dev_out = sycl::malloc_device<uint64_t>(2*numKeys, q);\n\n  uint32_t *dev_length = sycl::malloc_device<uint32_t>(numKeys+1, q);\n  q.memcpy(dev_length, d_length, sizeof(uint32_t)*(numKeys+1));\n\n  uint32_t *key_length = sycl::malloc_device<uint32_t>(numKeys, q);\n  q.memcpy(key_length, length, sizeof(uint32_t)*(numKeys));\n\n  sycl::range<1> global_work_size ((numKeys+BLOCK_SIZE-1)/BLOCK_SIZE*BLOCK_SIZE);\n  sycl::range<1> local_work_size (BLOCK_SIZE);\n\n  q.wait();\n  auto start = std::chrono::steady_clock::now();\n\n  for (uint32_t n = 0; n < repeat; n++) {\n    q.submit([&](sycl::handler &h) {\n      h.parallel_for<class mmh>(\n        sycl::nd_range<1>(global_work_size, local_work_size), [=](sycl::nd_item<1> item) {\n        int i = item.get_global_id(0); \n        if (i < numKeys) \n          MurmurHash3_x64_128 (dev_keys+dev_length[i], key_length[i], i, dev_out+i*2);\n        });\n    });\n  }\n\n  q.wait();\n  auto end = std::chrono::steady_clock::now();\n  auto time = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();\n  printf(\"Average kernel execution time %f (s)\\n\", (time * 1e-9f) / repeat);\n\n  q.memcpy(d_out, dev_out, sizeof(uint64_t)*(numKeys*2)).wait();\n\n  \n\n  bool error = false;\n  for (uint32_t i = 0; i < numKeys; i++) {\n    if (d_out[2*i] != out[i][0] ||  d_out[2*i+1] != out[i][1]) {\n      error = true;\n      break;\n    }\n  }\n  if (error) printf(\"FAIL\\n\");\n  else printf(\"SUCCESS\\n\");\n\n  for (uint32_t i = 0; i < numKeys; i++) {\n    free(out[i]);\n    free(keys[i]);\n  }\n  free(keys);\n  free(out);\n  free(length);\n  free(d_keys);\n  free(d_out);\n  free(d_length);\n  sycl::free(dev_keys, q);\n  sycl::free(dev_out, q);\n  sycl::free(dev_length, q);\n  sycl::free(key_length, q);\n  return 0;\n}\n"}}
